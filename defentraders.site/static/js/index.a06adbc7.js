(() => {
    var e, t, i, s, o, r, a, n, l = {
            51017() {},
            90952(e, t, i) {
                var s = {
                    "./en-nz": "79402",
                    "./ku-kmr": "6181",
                    "./id.js": "74063",
                    "./km": "96870",
                    "./he.js": "11713",
                    "./me": "58076",
                    "./tk": "59527",
                    "./ko.js": "63164",
                    "./tet.js": "28861",
                    "./es-do": "20838",
                    "./ku": "98174",
                    "./hr": "26308",
                    "./zh-tw.js": "50304",
                    "./gom-deva.js": "32124",
                    "./hy-am": "17160",
                    "./en-in": "9033",
                    "./de-at": "26111",
                    "./pt-br": "48303",
                    "./en-sg": "43004",
                    "./en-il.js": "65543",
                    "./lo": "15867",
                    "./tlh": "31052",
                    "./mi.js": "41848",
                    "./el": "54691",
                    "./ur.js": "57777",
                    "./sq": "86794",
                    "./pa-in.js": "29849",
                    "./ar-kw.js": "58676",
                    "./fr-ca.js": "26435",
                    "./de-ch.js": "54697",
                    "./ru": "82271",
                    "./eo.js": "32934",
                    "./nb": "22274",
                    "./br": "11470",
                    "./fo": "52477",
                    "./vi": "21135",
                    "./fr-ch.js": "37892",
                    "./ms-my": "92297",
                    "./bo.js": "31545",
                    "./lo.js": "15867",
                    "./my.js": "72264",
                    "./et": "3035",
                    "./br.js": "11470",
                    "./gu": "95050",
                    "./it-ch": "21827",
                    "./zh-cn.js": "52648",
                    "./ne.js": "8235",
                    "./gom-latn.js": "93383",
                    "./bg.js": "47777",
                    "./mr.js": "86169",
                    "./cv.js": "73635",
                    "./lt.js": "45766",
                    "./pt": "79834",
                    "./th.js": "55802",
                    "./cs.js": "56464",
                    "./es.js": "97650",
                    "./bn.js": "61290",
                    "./ar-tn": "89756",
                    "./mi": "41848",
                    "./sr.js": "45719",
                    "./tr": "85096",
                    "./bn-bd": "17357",
                    "./fa.js": "119",
                    "./it": "88383",
                    "./nl": "92572",
                    "./zh-hk": "1632",
                    "./fo.js": "52477",
                    "./bs.js": "44429",
                    "./ja.js": "23827",
                    "./my": "72264",
                    "./es-do.js": "20838",
                    "./gl": "77329",
                    "./nl-be.js": "43784",
                    "./en-ca.js": "28298",
                    "./tzm-latn.js": "97711",
                    "./ru.js": "82271",
                    "./sq.js": "86794",
                    "./cv": "73635",
                    "./km.js": "96870",
                    "./fa": "119",
                    "./cs": "56464",
                    "./ms": "73386",
                    "./x-pseudo": "64051",
                    "./ca": "7306",
                    "./tr.js": "85096",
                    "./tzm-latn": "97711",
                    "./kn": "84451",
                    "./jv": "89722",
                    "./ms-my.js": "92297",
                    "./be": "28959",
                    "./gd": "70217",
                    "./en-au": "53872",
                    "./ka": "41794",
                    "./ka.js": "41794",
                    "./ur": "57777",
                    "./sv.js": "41011",
                    "./zh-cn": "52648",
                    "./pl.js": "94418",
                    "./hi": "43861",
                    "./ug-cn": "48414",
                    "./ar-kw": "58676",
                    "./dv.js": "60708",
                    "./id": "74063",
                    "./dv": "60708",
                    "./vi.js": "21135",
                    "./de-ch": "54697",
                    "./en-in.js": "9033",
                    "./es-us.js": "56575",
                    "./fi.js": "90527",
                    "./ca.js": "7306",
                    "./ms.js": "73386",
                    "./zh-tw": "50304",
                    "./bs": "44429",
                    "./fil.js": "95995",
                    "./fy": "37071",
                    "./uz-latn": "72475",
                    "./mt.js": "77075",
                    "./fr.js": "85498",
                    "./hu": "90609",
                    "./lv.js": "69532",
                    "./sr-cyrl.js": "3322",
                    "./gom-deva": "32124",
                    "./tzl": "79846",
                    "./mn": "99053",
                    "./fil": "95995",
                    "./nl-be": "43784",
                    "./pa-in": "29849",
                    "./kk": "27088",
                    "./kk.js": "27088",
                    "./ar-ly.js": "42353",
                    "./hr.js": "26308",
                    "./nl.js": "92572",
                    "./ar": "61509",
                    "./ar-dz.js": "41488",
                    "./ar-sa": "82682",
                    "./ku-kmr.js": "6181",
                    "./cy": "64226",
                    "./en-ie": "66584",
                    "./lb.js": "79680",
                    "./ar-ly": "42353",
                    "./de.js": "77853",
                    "./lv": "69532",
                    "./tg": "86571",
                    "./de-at.js": "26111",
                    "./sl": "46637",
                    "./tg.js": "86571",
                    "./ky.js": "78474",
                    "./kn.js": "84451",
                    "./bo": "31545",
                    "./da": "93601",
                    "./ss.js": "56000",
                    "./uz": "57609",
                    "./fr-ch": "37892",
                    "./zh-mo.js": "31541",
                    "./sk": "5784",
                    "./hu.js": "90609",
                    "./sr": "45719",
                    "./he": "11713",
                    "./uk.js": "16618",
                    "./es-mx": "17730",
                    "./se.js": "33478",
                    "./oc-lnc": "69330",
                    "./pt-br.js": "48303",
                    "./ar-sa.js": "82682",
                    "./nb.js": "22274",
                    "./fr-ca": "26435",
                    "./ar-ps.js": "6947",
                    "./gl.js": "77329",
                    "./hi.js": "43861",
                    "./en-ie.js": "66584",
                    "./me.js": "58076",
                    "./fy.js": "37071",
                    "./ar.js": "61509",
                    "./az": "95533",
                    "./lt": "45766",
                    "./ro.js": "24457",
                    "./sw": "40748",
                    "./te.js": "11885",
                    "./tl-ph.js": "29231",
                    "./es-mx.js": "17730",
                    "./ky": "78474",
                    "./it.js": "88383",
                    "./zh-hk.js": "1632",
                    "./da.js": "93601",
                    "./te": "11885",
                    "./mt": "77075",
                    "./lb": "79680",
                    "./uz-latn.js": "72475",
                    "./ml.js": "73739",
                    "./en-sg.js": "43004",
                    "./uz.js": "57609",
                    "./tzm.js": "81765",
                    "./tet": "28861",
                    "./oc-lnc.js": "69330",
                    "./ar-ps": "6947",
                    "./az.js": "95533",
                    "./en-au.js": "53872",
                    "./fr": "85498",
                    "./gd.js": "70217",
                    "./yo.js": "82218",
                    "./nn": "54566",
                    "./bm": "54903",
                    "./sw.js": "40748",
                    "./af": "25177",
                    "./en-il": "65543",
                    "./eu": "3508",
                    "./et.js": "3035",
                    "./se": "33478",
                    "./gu.js": "95050",
                    "./gom-latn": "93383",
                    "./pl": "94418",
                    "./ar-dz": "41488",
                    "./ar-ma": "24496",
                    "./eu.js": "3508",
                    "./ss": "56000",
                    "./tk.js": "59527",
                    "./es-us": "56575",
                    "./ug-cn.js": "48414",
                    "./mn.js": "99053",
                    "./pt.js": "79834",
                    "./cy.js": "64226",
                    "./mr": "86169",
                    "./ga.js": "41734",
                    "./ko": "63164",
                    "./ku.js": "98174",
                    "./af.js": "25177",
                    "./hy-am.js": "17160",
                    "./es": "97650",
                    "./ml": "73739",
                    "./en-ca": "28298",
                    "./bn": "61290",
                    "./ga": "41734",
                    "./is.js": "89374",
                    "./sd.js": "1221",
                    "./sl.js": "46637",
                    "./tlh.js": "31052",
                    "./tl-ph": "29231",
                    "./uk": "16618",
                    "./x-pseudo.js": "64051",
                    "./is": "89374",
                    "./jv.js": "89722",
                    "./el.js": "54691",
                    "./fi": "90527",
                    "./bn-bd.js": "17357",
                    "./en-gb": "56195",
                    "./en-gb.js": "56195",
                    "./mk": "30306",
                    "./ne": "8235",
                    "./ro": "24457",
                    "./mk.js": "30306",
                    "./si": "17538",
                    "./tzm": "81765",
                    "./be.js": "28959",
                    "./de": "77853",
                    "./si.js": "17538",
                    "./yo": "82218",
                    "./bg": "47777",
                    "./sv": "41011",
                    "./th": "55802",
                    "./bm.js": "54903",
                    "./nn.js": "54566",
                    "./ar-ma.js": "24496",
                    "./ta.js": "11025",
                    "./ja": "23827",
                    "./zh-mo": "31541",
                    "./ar-tn.js": "89756",
                    "./sd": "1221",
                    "./sk.js": "5784",
                    "./tzl.js": "79846",
                    "./en-nz.js": "79402",
                    "./eo": "32934",
                    "./ta": "11025",
                    "./it-ch.js": "21827",
                    "./sr-cyrl": "3322"
                };

                function o(e) {
                    return Promise.resolve().then(function() {
                        if (!i.o(s, e)) {
                            var t = Error("Cannot find module '" + e + "'");
                            throw t.code = "MODULE_NOT_FOUND", t
                        }
                        var o = s[e];
                        return i.t(o, 23)
                    })
                }
                o.keys = () => Object.keys(s), o.id = 90952, e.exports = o
            },
            35358(e, t, i) {
                var s = {
                    "./af": "25177",
                    "./af.js": "25177",
                    "./ar": "61509",
                    "./ar-dz": "41488",
                    "./ar-dz.js": "41488",
                    "./ar-kw": "58676",
                    "./ar-kw.js": "58676",
                    "./ar-ly": "42353",
                    "./ar-ly.js": "42353",
                    "./ar-ma": "24496",
                    "./ar-ma.js": "24496",
                    "./ar-ps": "6947",
                    "./ar-ps.js": "6947",
                    "./ar-sa": "82682",
                    "./ar-sa.js": "82682",
                    "./ar-tn": "89756",
                    "./ar-tn.js": "89756",
                    "./ar.js": "61509",
                    "./az": "95533",
                    "./az.js": "95533",
                    "./be": "28959",
                    "./be.js": "28959",
                    "./bg": "47777",
                    "./bg.js": "47777",
                    "./bm": "54903",
                    "./bm.js": "54903",
                    "./bn": "61290",
                    "./bn-bd": "17357",
                    "./bn-bd.js": "17357",
                    "./bn.js": "61290",
                    "./bo": "31545",
                    "./bo.js": "31545",
                    "./br": "11470",
                    "./br.js": "11470",
                    "./bs": "44429",
                    "./bs.js": "44429",
                    "./ca": "7306",
                    "./ca.js": "7306",
                    "./cs": "56464",
                    "./cs.js": "56464",
                    "./cv": "73635",
                    "./cv.js": "73635",
                    "./cy": "64226",
                    "./cy.js": "64226",
                    "./da": "93601",
                    "./da.js": "93601",
                    "./de": "77853",
                    "./de-at": "26111",
                    "./de-at.js": "26111",
                    "./de-ch": "54697",
                    "./de-ch.js": "54697",
                    "./de.js": "77853",
                    "./dv": "60708",
                    "./dv.js": "60708",
                    "./el": "54691",
                    "./el.js": "54691",
                    "./en-au": "53872",
                    "./en-au.js": "53872",
                    "./en-ca": "28298",
                    "./en-ca.js": "28298",
                    "./en-gb": "56195",
                    "./en-gb.js": "56195",
                    "./en-ie": "66584",
                    "./en-ie.js": "66584",
                    "./en-il": "65543",
                    "./en-il.js": "65543",
                    "./en-in": "9033",
                    "./en-in.js": "9033",
                    "./en-nz": "79402",
                    "./en-nz.js": "79402",
                    "./en-sg": "43004",
                    "./en-sg.js": "43004",
                    "./eo": "32934",
                    "./eo.js": "32934",
                    "./es": "97650",
                    "./es-do": "20838",
                    "./es-do.js": "20838",
                    "./es-mx": "17730",
                    "./es-mx.js": "17730",
                    "./es-us": "56575",
                    "./es-us.js": "56575",
                    "./es.js": "97650",
                    "./et": "3035",
                    "./et.js": "3035",
                    "./eu": "3508",
                    "./eu.js": "3508",
                    "./fa": "119",
                    "./fa.js": "119",
                    "./fi": "90527",
                    "./fi.js": "90527",
                    "./fil": "95995",
                    "./fil.js": "95995",
                    "./fo": "52477",
                    "./fo.js": "52477",
                    "./fr": "85498",
                    "./fr-ca": "26435",
                    "./fr-ca.js": "26435",
                    "./fr-ch": "37892",
                    "./fr-ch.js": "37892",
                    "./fr.js": "85498",
                    "./fy": "37071",
                    "./fy.js": "37071",
                    "./ga": "41734",
                    "./ga.js": "41734",
                    "./gd": "70217",
                    "./gd.js": "70217",
                    "./gl": "77329",
                    "./gl.js": "77329",
                    "./gom-deva": "32124",
                    "./gom-deva.js": "32124",
                    "./gom-latn": "93383",
                    "./gom-latn.js": "93383",
                    "./gu": "95050",
                    "./gu.js": "95050",
                    "./he": "11713",
                    "./he.js": "11713",
                    "./hi": "43861",
                    "./hi.js": "43861",
                    "./hr": "26308",
                    "./hr.js": "26308",
                    "./hu": "90609",
                    "./hu.js": "90609",
                    "./hy-am": "17160",
                    "./hy-am.js": "17160",
                    "./id": "74063",
                    "./id.js": "74063",
                    "./is": "89374",
                    "./is.js": "89374",
                    "./it": "88383",
                    "./it-ch": "21827",
                    "./it-ch.js": "21827",
                    "./it.js": "88383",
                    "./ja": "23827",
                    "./ja.js": "23827",
                    "./jv": "89722",
                    "./jv.js": "89722",
                    "./ka": "41794",
                    "./ka.js": "41794",
                    "./kk": "27088",
                    "./kk.js": "27088",
                    "./km": "96870",
                    "./km.js": "96870",
                    "./kn": "84451",
                    "./kn.js": "84451",
                    "./ko": "63164",
                    "./ko.js": "63164",
                    "./ku": "98174",
                    "./ku-kmr": "6181",
                    "./ku-kmr.js": "6181",
                    "./ku.js": "98174",
                    "./ky": "78474",
                    "./ky.js": "78474",
                    "./lb": "79680",
                    "./lb.js": "79680",
                    "./lo": "15867",
                    "./lo.js": "15867",
                    "./lt": "45766",
                    "./lt.js": "45766",
                    "./lv": "69532",
                    "./lv.js": "69532",
                    "./me": "58076",
                    "./me.js": "58076",
                    "./mi": "41848",
                    "./mi.js": "41848",
                    "./mk": "30306",
                    "./mk.js": "30306",
                    "./ml": "73739",
                    "./ml.js": "73739",
                    "./mn": "99053",
                    "./mn.js": "99053",
                    "./mr": "86169",
                    "./mr.js": "86169",
                    "./ms": "73386",
                    "./ms-my": "92297",
                    "./ms-my.js": "92297",
                    "./ms.js": "73386",
                    "./mt": "77075",
                    "./mt.js": "77075",
                    "./my": "72264",
                    "./my.js": "72264",
                    "./nb": "22274",
                    "./nb.js": "22274",
                    "./ne": "8235",
                    "./ne.js": "8235",
                    "./nl": "92572",
                    "./nl-be": "43784",
                    "./nl-be.js": "43784",
                    "./nl.js": "92572",
                    "./nn": "54566",
                    "./nn.js": "54566",
                    "./oc-lnc": "69330",
                    "./oc-lnc.js": "69330",
                    "./pa-in": "29849",
                    "./pa-in.js": "29849",
                    "./pl": "94418",
                    "./pl.js": "94418",
                    "./pt": "79834",
                    "./pt-br": "48303",
                    "./pt-br.js": "48303",
                    "./pt.js": "79834",
                    "./ro": "24457",
                    "./ro.js": "24457",
                    "./ru": "82271",
                    "./ru.js": "82271",
                    "./sd": "1221",
                    "./sd.js": "1221",
                    "./se": "33478",
                    "./se.js": "33478",
                    "./si": "17538",
                    "./si.js": "17538",
                    "./sk": "5784",
                    "./sk.js": "5784",
                    "./sl": "46637",
                    "./sl.js": "46637",
                    "./sq": "86794",
                    "./sq.js": "86794",
                    "./sr": "45719",
                    "./sr-cyrl": "3322",
                    "./sr-cyrl.js": "3322",
                    "./sr.js": "45719",
                    "./ss": "56000",
                    "./ss.js": "56000",
                    "./sv": "41011",
                    "./sv.js": "41011",
                    "./sw": "40748",
                    "./sw.js": "40748",
                    "./ta": "11025",
                    "./ta.js": "11025",
                    "./te": "11885",
                    "./te.js": "11885",
                    "./tet": "28861",
                    "./tet.js": "28861",
                    "./tg": "86571",
                    "./tg.js": "86571",
                    "./th": "55802",
                    "./th.js": "55802",
                    "./tk": "59527",
                    "./tk.js": "59527",
                    "./tl-ph": "29231",
                    "./tl-ph.js": "29231",
                    "./tlh": "31052",
                    "./tlh.js": "31052",
                    "./tr": "85096",
                    "./tr.js": "85096",
                    "./tzl": "79846",
                    "./tzl.js": "79846",
                    "./tzm": "81765",
                    "./tzm-latn": "97711",
                    "./tzm-latn.js": "97711",
                    "./tzm.js": "81765",
                    "./ug-cn": "48414",
                    "./ug-cn.js": "48414",
                    "./uk": "16618",
                    "./uk.js": "16618",
                    "./ur": "57777",
                    "./ur.js": "57777",
                    "./uz": "57609",
                    "./uz-latn": "72475",
                    "./uz-latn.js": "72475",
                    "./uz.js": "57609",
                    "./vi": "21135",
                    "./vi.js": "21135",
                    "./x-pseudo": "64051",
                    "./x-pseudo.js": "64051",
                    "./yo": "82218",
                    "./yo.js": "82218",
                    "./zh-cn": "52648",
                    "./zh-cn.js": "52648",
                    "./zh-hk": "1632",
                    "./zh-hk.js": "1632",
                    "./zh-mo": "31541",
                    "./zh-mo.js": "31541",
                    "./zh-tw": "50304",
                    "./zh-tw.js": "50304"
                };

                function o(e) {
                    return i(r(e))
                }

                function r(e) {
                    if (!i.o(s, e)) {
                        var t = Error("Cannot find module '" + e + "'");
                        throw t.code = "MODULE_NOT_FOUND", t
                    }
                    return s[e]
                }
                o.keys = function() {
                    return Object.keys(s)
                }, o.resolve = r, e.exports = o, o.id = 35358
            },
            36590(e, t, i) {
                "use strict";
                i.d(t, {
                    default: () => s
                });
                let s = '<xml xmlns="http://www.w3.org/1999/xhtml" collection="false" is_dbot="true">\n  <variables></variables>\n  <block type="trade_definition" x="0" y="0">\n    <statement name="TRADE_OPTIONS">\n      <block type="trade_definition_market" deletable="false" movable="false">\n        <field name="MARKET_LIST"></field>\n        <field name="SUBMARKET_LIST"></field>\n        <field name="SYMBOL_LIST"></field>\n        <next>\n          <block type="trade_definition_tradetype" deletable="false" movable="false">\n            <field name="TRADETYPECAT_LIST"></field>\n            <field name="TRADETYPE_LIST"></field>\n            <next>\n              <block type="trade_definition_contracttype" deletable="false" movable="false">\n                <field name="TYPE_LIST"></field>\n                <next>\n                  <block type="trade_definition_candleinterval" deletable="false" movable="false">\n                    <field name="CANDLEINTERVAL_LIST">60</field>\n                    <next>\n                      <block type="trade_definition_restartbuysell" deletable="false" movable="false">\n                        <field name="TIME_MACHINE_ENABLED">FALSE</field>\n                        <next>\n                          <block type="trade_definition_restartonerror" deletable="false" movable="false">\n                            <field name="RESTARTONERROR">TRUE</field>\n                          </block>\n                        </next>\n                      </block>\n                    </next>\n                  </block>\n                </next>\n              </block>\n            </next>\n          </block>\n        </next>\n      </block>\n    </statement>\n    <statement name="SUBMARKET">\n      <block type="trade_definition_tradeoptions">\n        <mutation has_first_barrier="false" has_second_barrier="false" has_prediction="false"></mutation>\n        <field name="DURATIONTYPE_LIST"></field>\n        <field name="CURRENCY_LIST">USD</field>\n        <value name="DURATION">\n          <shadow type="math_number_positive">\n            <field name="NUM">5</field>\n          </shadow>\n        </value>\n        <value name="AMOUNT">\n          <shadow type="math_number_positive">\n            <field name="NUM">1</field>\n          </shadow>\n        </value>\n        <field name="AMOUNT_LIMITS"></field>\n      </block>\n    </statement>\n  </block>\n  <block type="during_purchase" x="720" y="0">\n    <statement name="DURING_PURCHASE_STACK">\n      <block type="controls_if">\n        <value name="IF0">\n          <block type="check_sell"></block>\n        </value>\n      </block>\n    </statement>\n  </block>\n  <block type="after_purchase" x="720" y="248">\n    <statement name="AFTERPURCHASE_STACK">\n      <block type="trade_again"></block>\n    </statement>\n  </block>\n  <block type="before_purchase" x="0" y="576">\n    <statement name="BEFOREPURCHASE_STACK">\n      <block type="purchase">\n        <field name="PURCHASE_LIST"></field>\n      </block>\n    </statement>\n  </block>\n</xml>'
            },
            73397(e, t, i) {
                var s = {
                    "./accumulators_dalembert.xml": ["28740", "432"],
                    "./dalembert.xml": ["57982", "630"],
                    "./martingale_max-stake.xml": ["46962", "822"],
                    "./dalembert_max-stake.xml": ["81544", "588"],
                    "./accumulators_dalembert_on_stat_reset.xml": ["41233", "3"],
                    "./oscars_grind.xml": ["73548", "212"],
                    "./reverse_martingale.xml": ["16369", "811"],
                    "./accumulators_martingale.xml": ["87522", "22"],
                    "./reverse_dalembert.xml": ["55937", "883"],
                    "./martingale.xml": ["34292", "668"],
                    "./accumulators_martingale_on_stat_reset.xml": ["93007", "489"],
                    "./accumulators_reverse_martingale.xml": ["44691", "561"],
                    "./1_3_2_6.xml": ["20789", "603"],
                    "./accumulators_reverse_dalembert.xml": ["87939", "113"],
                    "./accumulators_reverse_dalembert_on_stat_reset.xml": ["54342", "870"],
                    "./accumulators_reverse_martingale_on_stat_reset.xml": ["26038", "790"],
                    "./oscars_grind_max-stake.xml": ["1434", "230"]
                };

                function o(e) {
                    if (!i.o(s, e)) return Promise.resolve().then(function() {
                        var t = Error("Cannot find module '" + e + "'");
                        throw t.code = "MODULE_NOT_FOUND", t
                    });
                    var t = s[e],
                        o = t[0];
                    return i.e(t[1]).then(function() {
                        return i(o)
                    })
                }
                o.keys = () => Object.keys(s), o.id = 73397, e.exports = o
            },
            10428(e, t, i) {
                "use strict";
                i.d(t, {
                    Lk: () => s,
                    Xj: () => o,
                    hr: () => a
                });
                let s = "ce_bot_form",
                    o = "No results found";
                var r, a = ((r = {}).OPEN = "open", r.CLOSE = "close", r.RUN_BOT = "run_bot", r.RUN_QUICK_STRATEGY = "run_quick_strategy", r.EDIT_QUICK_STRATEGY = "edit_quick_strategy", r.SELECT_QUICK_STRATEGY_GUIDE = "select_quick_strategy_guide", r.SWITCH_QUICK_STRATEGY_TAB = "switch_quick_strategy_tab", r.DASHBOARD_CLICK = "dashboard_click", r.UPLOAD_STRATEGY_START = "upload_strategy_start", r.UPLOAD_STRATEGY_COMPLETED = "upload_strategy_completed", r.UPLOAD_STRATEGY_FAILED = "upload_strategy_failed", r.GOOGLE_DRIVE_CONNECT = "google_drive_connect", r.GOOGLE_DRIVE_DISCONNECT = "google_drive_disconnect", r.SWITCH_LOAD_STRATEGY_TAB = "switch_load_strategy_tab", r.ANNOUNCEMENT_CLICK = "announcement_click", r.ANNOUNCEMENT_ACTION = "announcement_action", r)
            },
            34399(e, t, i) {
                "use strict";
                i.d(t, {
                    X0: () => n,
                    Zj: () => l,
                    lc: () => a,
                    ot: () => d,
                    uv: () => u,
                    xH: () => c
                });
                var s = i(52782),
                    o = i(10428),
                    r = i(40708);
                let a = e => {
                        let {
                            subpage_name: t,
                            subform_source: i,
                            subform_name: r,
                            load_strategy_tab: a
                        } = e;
                        s.Analytics.trackEvent("ce_bot_form", {
                            action: "open",
                            form_name: o.Lk,
                            subpage_name: t,
                            subform_name: r,
                            subform_source: i,
                            load_strategy_tab: a
                        })
                    },
                    n = e => {
                        let {
                            subform_name: t,
                            quick_strategy_tab: i,
                            selected_strategy: a,
                            load_strategy_tab: n,
                            announcement_name: l
                        } = e;
                        s.Analytics.trackEvent("ce_bot_form", {
                            action: "close",
                            form_name: o.Lk,
                            subform_name: t,
                            quick_strategy_tab: i,
                            strategy_name: (0, r.Vw)(a),
                            load_strategy_tab: n,
                            announcement_name: l
                        })
                    },
                    l = e => {
                        let {
                            subpage_name: t
                        } = e;
                        s.Analytics.trackEvent("ce_bot_form", {
                            action: "run_bot",
                            form_name: o.Lk,
                            subpage_name: t
                        })
                    },
                    c = e => {
                        let {
                            upload_provider: t,
                            upload_id: i
                        } = e;
                        s.Analytics.trackEvent("ce_bot_form", {
                            action: "upload_strategy_start",
                            form_name: o.Lk,
                            subform_name: "load_strategy",
                            subpage_name: "bot_builder",
                            upload_provider: t,
                            upload_id: i
                        })
                    },
                    d = e => {
                        let {
                            upload_provider: t,
                            upload_id: i,
                            upload_type: r
                        } = e;
                        s.Analytics.trackEvent("ce_bot_form", {
                            action: "upload_strategy_completed",
                            form_name: o.Lk,
                            subform_name: "load_strategy",
                            subpage_name: "bot_builder",
                            upload_provider: t,
                            upload_id: i,
                            upload_type: r
                        })
                    },
                    u = e => {
                        let {
                            upload_provider: t,
                            upload_id: i,
                            upload_type: r,
                            error_message: a,
                            error_code: n
                        } = e;
                        s.Analytics.trackEvent("ce_bot_form", {
                            action: "upload_strategy_failed",
                            form_name: o.Lk,
                            subform_name: "load_strategy",
                            subpage_name: "bot_builder",
                            upload_provider: t,
                            upload_id: i,
                            upload_type: r,
                            error_message: a,
                            error_code: n
                        })
                    }
            },
            40708(e, t, i) {
                "use strict";
                i.d(t, {
                    Oj: () => u,
                    Vw: () => n,
                    oN: () => c,
                    sU: () => d
                });
                var s, o = i(24020),
                    r = i(10428);
                let a = e => e && e !== r.Xj,
                    n = e => {
                        var t;
                        return null == (t = (0, o.Y)()[e]) ? void 0 : t.rs_strategy_name
                    };
                var l = ((s = l || {}).recent = "recent", s.local = "local", s.google_drive = "google drive", s);
                let c = Object.values(l),
                    d = e => {
                        let {
                            form_values: t
                        } = e;
                        if (!t) return;
                        let {
                            symbol: i,
                            tradetype: s,
                            type: o,
                            stake: r
                        } = t, n = (() => {
                            try {
                                var e;
                                return JSON.parse((null == (e = localStorage) ? void 0 : e.getItem("qs-analytics")) ? ? "{}")
                            } catch (e) {
                                return console.error("Rudderstack: unable to get dropdown text"), {}
                            }
                        })();
                        return {
                            asset_type: a(null == n ? void 0 : n.symbol) ? n.symbol : i,
                            trade_type: a(null == n ? void 0 : n.tradetype) ? null == n ? void 0 : n.tradetype : s,
                            purchase_condition: a(null == n ? void 0 : n.type) ? null == n ? void 0 : n.type : o,
                            initial_stake: a(null == n ? void 0 : n.stake) ? null == n ? void 0 : n.stake : r
                        }
                    },
                    u = e => {
                        try {
                            let t = new DOMParser().parseFromString(e.toString(), "application/xml");
                            if (t.getElementsByTagName("xml").length) {
                                let e = t.documentElement.getAttribute("is_dbot");
                                return "true" === e ? "new" : "old"
                            }
                            return "old"
                        } catch (e) {
                            return "old"
                        }
                    }
            },
            71036(e, t, i) {
                "use strict";
                i.d(t, {
                    EP: () => n,
                    UC: () => a
                });
                var s = i(14606),
                    o = i(39571),
                    r = i(95526);
                let a = () => ({
                        bot_stop: (0, r.kg)("Bot stopped. Check Reports for contract history"),
                        workspace_change: (0, r.kg)("Changes you make will not affect your running bot."),
                        block_delete: (0, r.kg)("You’ve just deleted a block."),
                        invalid_xml: (0, r.kg)("Your import failed due to an invalid file. Upload a complete file in XML format."),
                        BOT_IMPORT: (0, r.kg)("You’ve successfully imported a bot."),
                        BOT_DELETE: (0, r.kg)("You’ve successfully deleted a bot."),
                        strategy_conversion: (0, r.kg)("Save this strategy as an XML file from Defen Traders for faster re-imports."),
                        google_drive_error: (0, r.kg)("Your session has expired. Please sign in again."),
                        xml_import_error: (0, r.kg)("Unsupported file format. Please import a valid XML file.")
                    }),
                    n = {
                        type: s.oR.TYPE.DEFAULT,
                        position: (0, o.Qq)() ? s.oR.POSITION.BOTTOM_RIGHT : s.oR.POSITION.BOTTOM_LEFT,
                        autoClose: 6e3,
                        hideProgressBar: !0,
                        closeOnClick: !1,
                        pauseOnHover: !0,
                        pauseOnFocusLoss: !1
                    }
            },
            88332(e, t, i) {
                "use strict";
                i.d(t, {
                    N: () => l
                });
                var s = i(74848),
                    o = i(96540),
                    r = i(14606),
                    a = i(71036);
                let n = e => {
                        let {
                            message: t,
                            primary_action: i,
                            closeToast: a
                        } = e;
                        return o.useEffect(() => {
                            let e = () => {
                                "hidden" === document.visibilityState && r.oR.dismiss()
                            };
                            return document.addEventListener("visibilitychange", e), () => {
                                document.removeEventListener("visibilitychange", e)
                            }
                        }, []), (0, s.jsxs)("div", {
                            className: "notification-content",
                            "data-testid": "dt_bot_notification",
                            children: [(0, s.jsx)("div", {
                                children: t
                            }), i && (0, s.jsx)("button", {
                                onClick: () => i.onClick(a),
                                children: i.label
                            })]
                        })
                    },
                    l = (e, t, i) => (0, r.oR)(i => {
                        let {
                            closeToast: o
                        } = i;
                        return (0, s.jsx)(n, {
                            message: e,
                            primary_action: t,
                            closeToast: o
                        })
                    }, {
                        type: (null == i ? void 0 : i.type) ? ? a.EP.type,
                        position: (null == i ? void 0 : i.position) ? ? a.EP.position,
                        autoClose: (null == i ? void 0 : i.autoClose) ? ? a.EP.autoClose,
                        hideProgressBar: (null == i ? void 0 : i.hideProgressBar) ? ? a.EP.hideProgressBar,
                        closeOnClick: (null == i ? void 0 : i.closeOnClick) ? ? a.EP.closeOnClick,
                        pauseOnHover: (null == i ? void 0 : i.pauseOnHover) ? ? a.EP.pauseOnHover,
                        pauseOnFocusLoss: (null == i ? void 0 : i.pauseOnFocusLoss) ? ? a.EP.pauseOnFocusLoss,
                        closeButton: (null == i ? void 0 : i.closeButton) ? ? !0,
                        className: (null == i ? void 0 : i.className) ? ? ""
                    })
            },
            22998(e, t, i) {
                "use strict";
                i.d(t, {
                    Kg: () => s,
                    kd: () => o
                }), i(67774);
                let s = () => ({
                        au: "Australian",
                        sg: "Singaporean",
                        it: "Italian",
                        de: "German",
                        fr: "French",
                        lu: "Luxembourgish",
                        gr: "Greek",
                        mf: "Saint Martiner",
                        es: "Spanish",
                        sk: "Slovak",
                        lt: "Lithuanian",
                        nl: "Dutch",
                        at: "Austrian",
                        bg: "Bulgarian",
                        si: "Slovenian",
                        cy: "Cypriot",
                        be: "Belgian",
                        ro: "Romanian",
                        hr: "Croatian",
                        pt: "Portuguese",
                        pl: "Polish",
                        lv: "Latvian",
                        ee: "Estonian",
                        cz: "Czech",
                        fi: "Finnish",
                        hu: "Hungarian",
                        dk: "Danish",
                        se: "Swedish",
                        ie: "Irish",
                        im: "Manx",
                        gb: "British",
                        mt: "Malta"
                    }),
                    o = () => ["za", "ec", "bw"]
            },
            37448(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => r
                });
                var s = i(74848),
                    o = i(49470);

                function r(e) {
                    let {
                        message: t
                    } = e;
                    return (0, s.jsxs)("div", {
                        className: "app-root",
                        children: [(0, s.jsx)(o.a, {}), (0, s.jsx)("div", {
                            className: "load-message",
                            children: t
                        })]
                    })
                }
            },
            29123(e, t, i) {
                "use strict";
                i.d(t, {
                    Bt: () => o,
                    PW: () => l,
                    vv: () => a
                });
                let s = ["it", "de", "fr", "lu", "gr", "mf", "es", "sk", "lt", "nl", "at", "bg", "si", "cy", "be", "ro", "hr", "pt", "pl", "lv", "ee", "cz", "fi", "hu", "dk", "se", "ie", "im", "gb", "mt"],
                    o = e => s.includes(e),
                    r = ["de", "es", "it", "lu", "gr", "au", "fr"],
                    a = e => r.includes(e),
                    n = ["au", "fr"],
                    l = e => n.includes(e)
            },
            28176(e, t, i) {
                "use strict";
                let s;
                i.d(t, {
                    CmZ: () => l.Cm,
                    FrL: () => C.Fr,
                    a8R: () => n.a8,
                    Drx: () => P,
                    OrZ: () => c.Or,
                    R7U: () => n.R7,
                    UpN: () => T.Up,
                    McG: () => d.Mc,
                    K2O: () => T.K2,
                    KVY: () => n.KV,
                    kNj: () => c.kN,
                    ob7: () => T.ob,
                    d2P: () => c.d2,
                    EaA: () => _,
                    T$m: () => c.T$,
                    RIy: () => T.RI,
                    upA: () => c.up,
                    aqL: () => I,
                    pv4: () => u.pv,
                    JN5: () => d.JN,
                    bne: () => r,
                    fv: () => A.f,
                    nrF: () => a,
                    h2C: () => T.h2,
                    vN7: () => c.vN,
                    hE1: () => c.hE,
                    Qsi: () => p,
                    IV4: () => u.IV,
                    Yef: () => l.Ye,
                    _ph: () => c._p,
                    J39: () => n.J3,
                    ry7: () => d.ry,
                    Sh1: () => c.Sh,
                    qIf: () => d.qI,
                    tsP: () => f.ts,
                    Hv4: () => T.Hv,
                    MFp: () => c.MF,
                    upu: () => d.up,
                    nmX: () => d.nm,
                    WeW: () => T.We,
                    plb: () => c.pl,
                    M5x: () => c.M5,
                    ABl: () => c.AB,
                    kuE: () => c.ku,
                    nJz: () => E,
                    PIz: () => c.PI,
                    b$m: () => w.b$,
                    lpQ: () => d.lp,
                    Vse: () => y.Vs,
                    FsZ: () => c.Fs,
                    sf1: () => u.sf,
                    Yq5: () => u.Yq,
                    E6X: () => w.E6,
                    xlR: () => C.xl,
                    nTj: () => c.nT,
                    oEK: () => x,
                    dX3: () => c.dX,
                    QWi: () => d.QW,
                    mRI: () => c.mR,
                    Amx: () => c.Am,
                    F0v: () => d.F0,
                    W3I: () => c.W3,
                    a3k: () => u.a3,
                    tK1: () => c.tK,
                    M9s: () => c.M9,
                    fUm: () => u.fU,
                    gwf: () => c.gw
                }), i(52782);
                var o = JSON.parse('{"Bn":{"trader":{"name":"Deriv Trader","icon":"IcRebrandingDerivTrader"},"dbot":{"name":"Defen Traders","icon":"IcRebrandingDerivBot"},"mt5":{"name":"Deriv MT5","icon":"IcRebrandingDmt5"},"ctrader":{"name":"Deriv cTrader","icon":"IcRebrandingCtrader"},"dxtrade":{"name":"Deriv X","icon":"IcRebrandingDxtrade"},"smarttrader":{"name":"SmartTrader","icon":"IcRebrandingSmarttrader"},"bbot":{"name":"Binary Bot","icon":"IcRebrandingBinaryBot"},"go":{"name":"Deriv GO","icon":"IcRebrandingDerivGo"}}}');
                let r = e => {
                        let t, i = o.Bn[e];
                        return t = window.location.host, /^(((.*)\.)?(localhost:8444|pages.dev|binary\.(sx|com)|deriv.(com|me|be|dev)))$/.test(t) || (i.icon = ""), i
                    },
                    a = () => /constructor/i.test(window.HTMLElement) || "[object SafariRemoteNotification]" === (!window.safari || void 0 !== window.safari && window.safari.pushNotification).toString();
                var n = i(77354),
                    l = i(81753),
                    c = i(67127),
                    d = i(99829),
                    u = i(57662),
                    h = i(29123);
                let p = function(e, t, i, s) {
                        let o = !(arguments.length > 4) || void 0 === arguments[4] || arguments[4],
                            {
                                title: r,
                                text: a,
                                link: n
                            } = t;
                        e({
                            message: a,
                            header: r,
                            redirect_label: n,
                            redirectOnClick: i,
                            should_show_refresh: !1,
                            redirect_to: "/appstore/traders-hub",
                            should_clear_error_on_click: o,
                            should_redirect: s
                        })
                    },
                    _ = e => (null == e ? void 0 : e.length) === 1 && e.every(e => (0, h.Bt)(e.residence ? ? "") && "virtual" === e.landing_company_shortcode);
                i(52527), Object.freeze({
                    amlglobalcheck: "amlglobalcheck",
                    bankstatement: "bankstatement",
                    docverification: "docverification",
                    driverslicense: "driverslicense",
                    driving_licence: "driving_licence",
                    national_identity_card: "national_identity_card",
                    other: "other",
                    passport: "passport",
                    power_of_attorney: "power_of_attorney",
                    proof_of_ownership: "proof_of_ownership",
                    proofaddress: "proofaddress",
                    proofid: "proofid",
                    utility_bill: "utility_bill"
                }), Object.freeze({
                    back: "back",
                    front: "front",
                    photo: "photo"
                });
                var g = i(27813),
                    m = i(95526),
                    y = i(2168),
                    f = i(17276),
                    b = i(62864);
                let k = function(e, t) {
                        let i = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2],
                            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                        if (!e && (0, y.U5)(sessionStorage)) {
                            let e = window.location,
                                o = i ? window.location.href : `${e.protocol}//${e.host}${e.pathname}`;
                            sessionStorage.setItem("redirect_url", o), setTimeout(() => {
                                let e = v({
                                    language: t
                                });
                                window.location.href = e
                            }, s)
                        }
                    },
                    v = e => {
                        let {
                            language: t
                        } = e, i = y.Vs.get("config.server_url"), s = new y.W6("signup_device").get("signup_device"), o = new y.W6("date_first_contact").get("date_first_contact"), r = `${s?`&signup_device=${s}`:""}${o?`&date_first_contact=${o}`:""}`, a = () => `https://oauth.${b.G.DERIV_HOST_NAME}/oauth2/authorize?app_id=${(0,n.R7)()}&l=${t}${r}&brand=deriv`;
                        return i && /qa/.test(i) ? `https://${i}/oauth2/authorize?app_id=${(0,n.R7)()}&l=${t}${r}&brand=deriv` : (0, n.R7)() === n.Yp[window.location.hostname] ? a() : (0, f.IK)(a())
                    };
                (0, g.L3)(function*(e, t) {
                    let i = yield s.wait("website_status"), o = yield s.residenceList(), r = i.website_status.clients_country, a = (o.residence_list.find(e => e.value === r) || {}).text, n = a ? (0, m.kg)("Sorry, this app is unavailable in {{clients_country}}.", {
                        clients_country: a
                    }) : (0, m.kg)("Sorry, this app is unavailable in your current location.");
                    e({
                        message: (0, m.kg)("If you have an account, log in to continue."),
                        header: n,
                        redirect_label: (0, m.kg)("Log in"),
                        redirectOnClick: () => k(t, (0, m.dn)()),
                        should_show_refresh: !1
                    })
                });
                i(74848), m.we, m.we, i(95093);
                var w = i(64067);
                i(99991);
                var T = i(49655);
                i(65823);
                var S = i(96540);
                let I = () => {
                        let e = S.useRef(!1);
                        return S.useEffect(() => (e.current = !0, () => {
                            e.current = !1
                        }), []), () => e.current
                    },
                    E = e => {
                        let [t, i] = S.useState(!e);
                        return S.useEffect(() => {
                            e && i(!0)
                        }, [e]), {
                            in_prop: t
                        }
                    };
                i(53259), i(77232);
                let x = () => {
                    let e = navigator.userAgent || navigator.vendor || window.opera || "";
                    return /windows phone/i.test(e) ? "Windows Phone" : /android/i.test(e) ? /\bK\b|ALP-|AMN-|ANA-|ANE-|ANG-|AQM-|ARS-|ART-|ATU-|BAC-|BLA-|BRQ-|CAG-|CAM-|CAN-|CAZ-|CDL-|CDY-|CLT-|CRO-|CUN-|DIG-|DRA-|DUA-|DUB-|DVC-|ELE-|ELS-|EML-|EVA-|EVR-|FIG-|FLA-|FRL-|GLK-|HMA-|HW-|HWI-|INE-|JAT-|JEF-|JER-|JKM-|JNY-|JSC-|LDN-|LIO-|LON-|LUA-|LYA-|LYO-|MAR-|MED-|MHA-|MLA-|MRD-|MYA-|NCE-|NEO-|NOH-|NOP-|OCE-|PAR-|PIC-|POT-|PPA-|PRA-|RNE-|SEA-|SLA-|SNE-|SPN-|STK-|TAH-|TAS-|TET-|TRT-|VCE-|VIE-|VKY-|VNS-|VOG-|VTR-|WAS-|WKG-|WLZ-|JAD-|WKG-|MLD-|RTE-|NAM-|NEN-|BAL-|JAD-|JLN-|YAL/i.test(e) || /huawei/i.test(e) ? "huawei" : "Android" : /iPad|iPhone|iPod/.test(e) && !window.MSStream ? "iOS" : "unknown"
                };
                var A = i(28960),
                    C = i(33048);
                i(16115);
                var R = i(50467),
                    O = i(2457);
                let D = class {
                        add(e, t) {
                            this.has(e) || (this.errors[e] = []), -1 === this.errors[e].indexOf(t) && this.errors[e].push(t)
                        }
                        all() {
                            return this.errors
                        }
                        first(e) {
                            return this.has(e) ? this.errors[e][0] : null
                        }
                        get(e) {
                            return this.has(e) ? this.errors[e] : []
                        }
                        has(e) {
                            return Object.prototype.hasOwnProperty.call(this.errors, e)
                        }
                        constructor() {
                            (0, R._)(this, "errors", void 0), this.errors = {}
                        }
                    },
                    B = (e, t) => {
                        let i = t;
                        return t && !Array.isArray(t) && (i = [t]), e.replace(/\[_(\d+)]/g, (e, t) => i[t - 1])
                    };
                class L {
                    addFailure(e, t, i) {
                        var s, o;
                        let r = i || t.options.message || (0, O.lo)()[t.name].message();
                        "length" === t.name ? r = B(r, [t.options.min === t.options.max ? (null == (s = t.options.min) ? void 0 : s.toString()) ? ? "" : `${t.options.min}-${t.options.max}`]) : "min" === t.name ? r = B(r, [(null == (o = t.options.min) ? void 0 : o.toString()) ? ? ""]) : "not_equal" === t.name && (r = B(r, [t.options.name1 ? ? "", t.options.name2 ? ? ""])), this.errors.add(e, r), this.error_count++
                    }
                    check() {
                        return Object.keys(this.input).forEach(e => {
                            Object.prototype.hasOwnProperty.call(this.rules, e) && this.rules[e].forEach(t => {
                                let i = L.getRuleObject(t);
                                if (!i.validator && "function" != typeof i.validator || i.options.condition && !i.options.condition(this.store) || "" === this.input[e] && "req" !== i.name) return;
                                let s = i.validator(this.input[e], i.options, this.store, this.input);
                                if ("boolean" != typeof s || s) {
                                    if ("object" == typeof s) {
                                        let {
                                            is_ok: t,
                                            message: o
                                        } = s;
                                        t || this.addFailure(e, i, o)
                                    }
                                } else this.addFailure(e, i)
                            })
                        }), !this.error_count
                    }
                    isPassed() {
                        return this.check()
                    }
                    static getRuleObject(e) {
                        let t = "string" == typeof e,
                            i = t ? e : e[0],
                            s = t ? {} : e[1] || {};
                        return {
                            name: i,
                            options: s,
                            validator: "custom" === i ? s.func : (0, O.lo)()[i].func
                        }
                    }
                    constructor(e, t, i) {
                        (0, R._)(this, "input", void 0), (0, R._)(this, "rules", void 0), (0, R._)(this, "store", void 0), (0, R._)(this, "errors", void 0), (0, R._)(this, "error_count", void 0), this.input = e, this.rules = t, this.store = i, this.errors = new D, this.error_count = 0
                    }
                }
                let P = L
            },
            77354(e, t, i) {
                "use strict";
                i.d(t, {
                    Du: () => o,
                    J3: () => l,
                    KV: () => r,
                    R7: () => n,
                    Yp: () => s,
                    a8: () => a
                }), i(13599);
                let s = {
                        "defentraders.site/": 74892
                    },
                    o = () => !/^staging\./.test(window.location.hostname) && Object.keys(s).find(e => window.location.hostname === e),
                    r = () => {
                        let e = Object.keys(s).map(e => `(www\\.)?${e.replace(".","\\.")}`);
                        return RegExp(`^(${e.join("|")})$`, "i").test(window.location.hostname)
                    },
                    a = () => ({
                        app_id: 74892,
                        server_url: "ws.derivws.com"
                    }),
                    n = () => {
                        let e = window.localStorage.getItem("config.app_id"),
                            t = o() ? ? "";
                        return e || (s[t] ? ? 74892)
                    },
                    l = () => {
                        let e = window.localStorage.getItem("config.server_url");
                        return e || "ws.derivws.com"
                    }
            },
            99991(e, t, i) {
                "use strict";
                i.d(t, {
                    Ye: () => o
                });
                var s = i(95526);
                i(67127);
                let o = () => ({
                    APPLY: (0, s.kg)("Apply"),
                    BARRIER: (0, s.kg)("Barrier:"),
                    BUY_PRICE: (0, s.kg)("Buy price:"),
                    CANCEL: (0, s.kg)("Cancel"),
                    CLOSE: (0, s.kg)("Close"),
                    CLOSED: (0, s.kg)("Closed"),
                    CONTRACT_COST: (0, s.kg)("Contract cost:"),
                    CONTRACT_VALUE: (0, s.kg)("Contract value:"),
                    CURRENT_STAKE: (0, s.kg)("Current stake:"),
                    DAY: (0, s.kg)("day"),
                    DAYS: (0, s.kg)("days"),
                    DEAL_CANCEL_FEE: (0, s.kg)("Deal cancel. fee:"),
                    DECREMENT_VALUE: (0, s.kg)("Decrement value"),
                    DONT_SHOW_THIS_AGAIN: (0, s.kg)("Don't show this again"),
                    ENTRY_SPOT: (0, s.kg)("Entry spot:"),
                    INCREMENT_VALUE: (0, s.kg)("Increment value"),
                    INDICATIVE_PRICE: (0, s.kg)("Indicative price:"),
                    INITIAL_STAKE: (0, s.kg)("Initial stake:"),
                    LOST: (0, s.kg)("Lost"),
                    MULTIPLIER: (0, s.kg)("Multiplier:"),
                    NOT_AVAILABLE: (0, s.kg)("N/A"),
                    PAYOUT: (0, s.kg)("Sell price:"),
                    POTENTIAL_PAYOUT: (0, s.kg)("Potential payout:"),
                    POTENTIAL_PROFIT_LOSS: (0, s.kg)("Potential profit/loss:"),
                    PROFIT_LOSS: (0, s.kg)("Profit/Loss:"),
                    PURCHASE_PRICE: (0, s.kg)("Buy price:"),
                    RESALE_NOT_OFFERED: (0, s.kg)("Resale not offered"),
                    SELL: (0, s.kg)("Sell"),
                    STAKE: (0, s.kg)("Stake:"),
                    STOP_LOSS: (0, s.kg)("Stop loss:"),
                    STRIKE: (0, s.kg)("Strike:"),
                    TAKE_PROFIT: (0, s.kg)("Take profit:"),
                    TICK: (0, s.kg)("Tick "),
                    TICKS: (0, s.kg)("Ticks"),
                    TOTAL_PROFIT_LOSS: (0, s.kg)("Total profit/loss:"),
                    TAKE_PROFIT_LOSS_NOT_AVAILABLE: (0, s.kg)("Take profit and/or stop loss are not available while deal cancellation is active."),
                    WON: (0, s.kg)("Won")
                })
            },
            81753(e, t, i) {
                "use strict";
                i.d(t, {
                    rL: () => a,
                    Cm: () => s,
                    SH: () => n,
                    Ye: () => o.Ye
                });
                let s = Object.freeze({
                    LOW_RISK_CR_EU: "low_risk_cr_eu",
                    LOW_RISK_CR_NON_EU: "low_risk_cr_non_eu",
                    HIGH_RISK_CR: "high_risk_cr",
                    CR_DEMO: "cr_demo",
                    EU_DEMO: "eu_demo",
                    EU_REAL: "eu_real"
                });
                var o = i(99991),
                    r = i(95526);
                let a = () => (0, r.kg)("No results found"),
                    n = () => ({
                        header: (0, r.kg)("Sorry for the interruption"),
                        description: (0, r.kg)("Our servers hit a bump. Let’s refresh to move on."),
                        cta_label: (0, r.kg)("Refresh")
                    });
                Object.freeze({
                    NONE: "none",
                    PENDING: "pending",
                    REJECTED: "rejected",
                    VERIFIED: "verified",
                    EXPIRED: "expired",
                    SUSPECTED: "suspected"
                }), Object.freeze({
                    SVG: "svg",
                    BVI: "bvi",
                    VANUATU: "vanuatu",
                    LABUAN: "labuan",
                    MALTA_INVEST: "maltainvest"
                }), Object.freeze({
                    DXTRADE: "dxtrade",
                    MT5: "mt5"
                }), Object.freeze({
                    FAILED: "failed",
                    MIGRATED_WITH_POSITION: "migrated_with_position",
                    MIGRATED_WITHOUT_POSITION: "migrated_without_position",
                    NEEDS_VERIFICATION: "needs_verification",
                    PENDING: "pending",
                    POA_PENDING: "poa_pending",
                    POA_VERIFIED: "poa_verified"
                });
                var l = i(74848);
                i(96540), Object.freeze({
                    DobMismatch: {
                        code: "DobMismatch",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The <0>date of birth</0> on your identity document doesn't match your profile.",
                            components: [(0, l.jsx)("strong", {}, 0)]
                        })
                    },
                    DocumentRejected: {
                        code: "DocumentRejected",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We were unable to verify the identity document with the details provided."
                        })
                    },
                    EmptyStatus: {
                        code: "EmptyStatus",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The verification status was empty, rejected for lack of information."
                        })
                    },
                    Expired: {
                        code: "Expired",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your identity document has expired."
                        })
                    },
                    InformationLack: {
                        code: "InformationLack",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The verification is passed but the personal info is not available to compare."
                        })
                    },
                    MalformedJson: {
                        code: "MalformedJson",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The verification status is not available, provider says: Malformed JSON."
                        })
                    },
                    NameMismatch: {
                        code: "NameMismatch",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The <0>name</0> on your identity document doesn't match your profile.",
                            components: [(0, l.jsx)("strong", {}, 0)]
                        })
                    },
                    RejectedByProvider: {
                        code: "RejectedByProvider",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The document was rejected by the Provider."
                        })
                    },
                    Underage: {
                        code: "Underage",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "You’re under legal age."
                        })
                    },
                    Deceased: {
                        code: "Deceased",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The document’s owner is deceased."
                        })
                    },
                    Failed: {
                        code: "Failed",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We were unable to verify the identity document with the details provided."
                        })
                    },
                    NameDobMismatch: {
                        code: "NameDobMismatch",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The <0>name</0> and <0>date of birth</0> on your identity document don't match your profile.",
                            components: [(0, l.jsx)("strong", {}, 0)]
                        })
                    },
                    NeedsTechnicalInvestigation: {
                        code: "NeedsTechnicalInvestigation",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The verification status is not available, provider says: Needs Technical Investigation."
                        })
                    },
                    HighRisk: {
                        code: "HighRisk",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "For enhanced security, we need to reverify your identity. Kindly resubmit your proof of identity to unlock your account."
                        })
                    },
                    ReportNotAvailable: {
                        code: "ReportNotAvailable",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We were unable to verify the identity document with the details provided."
                        })
                    }
                }), Object.freeze({
                    AgeValidationMinimumAcceptedAge: {
                        code: "AgeValidationMinimumAcceptedAge",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your age in the document you provided appears to be below 18 years. We’re only allowed to offer our services to clients above 18 years old, so we’ll need to close your account. If you have a balance in your account, contact us via live chat and we’ll help to withdraw your funds before your account is closed."
                        })
                    },
                    CompromisedDocument: {
                        code: "CompromisedDocument",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document failed our verification checks."
                        })
                    },
                    DataComparisonDateOfBirth: {
                        code: "DataComparisonDateOfBirth",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The date of birth on your document doesn’t match your profile."
                        })
                    },
                    DataComparisonDateOfExpiry: {
                        code: "DataComparisonDateOfExpiry",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document has expired."
                        })
                    },
                    DataComparisonDocumentNumbers: {
                        code: "DataComparisonDocumentNumbers",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be invalid."
                        })
                    },
                    DataComparisonDocumentType: {
                        code: "DataComparisonDocumentType",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be invalid."
                        })
                    },
                    DataComparisonIssuingCountry: {
                        code: "DataComparisonIssuingCountry",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be invalid."
                        })
                    },
                    DataComparisonName: {
                        code: "DataComparisonName",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The name on your document doesn’t match your profile."
                        })
                    },
                    DataValidationDateOfBirth: {
                        code: "DataValidationDateOfBirth",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Some details on your document appear to be invalid, missing, or unclear."
                        })
                    },
                    DataValidationDocumentExpiration: {
                        code: "DataValidationDocumentExpiration",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document has expired."
                        })
                    },
                    DataValidationDocumentNumbers: {
                        code: "DataValidationDocumentNumbers",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Some details in your document appear to be invalid, missing, or unclear."
                        })
                    },
                    DataValidationExpiryDate: {
                        code: "DataValidationExpiryDate",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Some details on your document appear to be invalid, missing, or unclear."
                        })
                    },
                    DataValidationMrz: {
                        code: "DataValidationMrz",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Some details on your document appear to be invalid, missing, or unclear."
                        })
                    },
                    DataValidationNoDocumentNumbers: {
                        code: "DataValidationNoDocumentNumbers",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The serial number of your document couldn’t be verified."
                        })
                    },
                    DuplicatedDocument: {
                        code: "DuplicatedDocument",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your verification documents were already used for another account."
                        })
                    },
                    Expired: {
                        code: "Expired",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document has expired."
                        })
                    },
                    ImageIntegrityColourPicture: {
                        code: "ImageIntegrityColourPicture",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be in black and white. Please upload a colour photo of your document."
                        })
                    },
                    ImageIntegrityConclusiveDocumentQuality: {
                        code: "ImageIntegrityConclusiveDocumentQuality",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be invalid."
                        })
                    },
                    ImageIntegrityConclusiveDocumentQualityAbnormalDocumentFeatures: {
                        code: "ImageIntegrityConclusiveDocumentQualityAbnormalDocumentFeatures",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Some details on your document appear to be invalid, missing, or unclear."
                        })
                    },
                    ImageIntegrityConclusiveDocumentQualityCornerRemoved: {
                        code: "ImageIntegrityConclusiveDocumentQualityCornerRemoved",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be damaged or cropped."
                        })
                    },
                    ImageIntegrityConclusiveDocumentQualityDigitalDocument: {
                        code: "ImageIntegrityConclusiveDocumentQualityDigitalDocument",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be a digital document."
                        })
                    },
                    ImageIntegrityConclusiveDocumentQualityMissingBack: {
                        code: "ImageIntegrityConclusiveDocumentQualityMissingBack",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The back of your document appears to be missing. Please include both sides of your identity document."
                        })
                    },
                    ImageIntegrityConclusiveDocumentQualityObscuredDataPoints: {
                        code: "ImageIntegrityConclusiveDocumentQualityObscuredDataPoints",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Some details on your document appear to be invalid, missing, or unclear."
                        })
                    },
                    ImageIntegrityConclusiveDocumentQualityObscuredSecurityFeatures: {
                        code: "ImageIntegrityConclusiveDocumentQualityObscuredSecurityFeatures",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Some details on your document appear to be invalid, missing, or unclear."
                        })
                    },
                    ImageIntegrityConclusiveDocumentQualityPuncturedDocument: {
                        code: "ImageIntegrityConclusiveDocumentQualityPuncturedDocument",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be damaged or cropped."
                        })
                    },
                    ImageIntegrityConclusiveDocumentQualityWatermarksDigitalTextOverlay: {
                        code: "ImageIntegrityConclusiveDocumentQualityWatermarksDigitalTextOverlay",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document contains markings or text that should not be on your document."
                        })
                    },
                    ImageIntegrityImageQuality: {
                        code: "ImageIntegrityImageQuality",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The image quality of your document is too low. Please provide a hi-res photo of your identity document."
                        })
                    },
                    ImageIntegrityImageQualityBlurredPhoto: {
                        code: "ImageIntegrityImageQualityBlurredPhoto",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We were unable to verify your selfie because it’s not clear. Please take a clearer photo and try again. Ensure that there's enough light where you are and that your entire face is in the frame."
                        })
                    },
                    ImageIntegrityImageQualityCoveredPhoto: {
                        code: "ImageIntegrityImageQualityCoveredPhoto",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We’re unable to verify the document you provided because some details appear to be missing. Please try again or provide another document."
                        })
                    },
                    ImageIntegrityImageQualityCutOffDocument: {
                        code: "ImageIntegrityImageQualityCutOffDocument",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We’re unable to verify the document you provided because it appears to be damaged. Please try again or upload another document."
                        })
                    },
                    ImageIntegrityImageQualityDamagedDocument: {
                        code: "ImageIntegrityImageQualityDamagedDocument",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We’re unable to verify the document you provided because it appears to be damaged. Please try again or upload another document."
                        })
                    },
                    ImageIntegrityImageQualityDarkPhoto: {
                        code: "ImageIntegrityImageQualityDarkPhoto",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We were unable to verify your selfie because it’s not clear. Please take a clearer photo and try again. Ensure that there’s enough light where you are and that your entire face is in the frame."
                        })
                    },
                    ImageIntegrityImageQualityGlareOnPhoto: {
                        code: "ImageIntegrityImageQualityGlareOnPhoto",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We were unable to verify your selfie because it’s not clear. Please take a clearer photo and try again. Ensure that there’s enough light where you are and that your entire face is in the frame."
                        })
                    },
                    ImageIntegrityImageQualityIncorrectSide: {
                        code: "ImageIntegrityImageQualityIncorrectSide",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The front of your document appears to be missing. Please provide both sides of your identity document."
                        })
                    },
                    ImageIntegrityImageQualityNoDocumentInImage: {
                        code: "ImageIntegrityImageQualityNoDocumentInImage",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We’re unable to verify the document you provided because it appears to be a blank image. Please try again or upload another document."
                        })
                    },
                    ImageIntegrityImageQualityOtherPhotoIssue: {
                        code: "ImageIntegrityImageQualityOtherPhotoIssue",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We’re unable to verify the document you provided because some details appear to be missing. Please try again or provide another document."
                        })
                    },
                    ImageIntegrityImageQualityTwoDocumentsUploaded: {
                        code: "ImageIntegrityImageQualityTwoDocumentsUploaded",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The document you provided appears to be two different types. Please try again or provide another document."
                        })
                    },
                    ImageIntegritySupportedDocument: {
                        code: "ImageIntegritySupportedDocument",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "The document you provided is not supported for your country. Please provide a supported document for your country."
                        })
                    },
                    SelfieRejected: {
                        code: "SelfieRejected",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your selfie does not match your document."
                        })
                    },
                    VisualAuthenticityDigitalTampering: {
                        code: "VisualAuthenticityDigitalTampering",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be invalid."
                        })
                    },
                    VisualAuthenticityFaceDetection: {
                        code: "VisualAuthenticityFaceDetection",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be invalid."
                        })
                    },
                    VisualAuthenticityFonts: {
                        code: "VisualAuthenticityFonts",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be invalid."
                        })
                    },
                    VisualAuthenticityOriginalDocumentPresent: {
                        code: "VisualAuthenticityOriginalDocumentPresent",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be a scanned copy that contains markings or text that shouldn’t be on your document."
                        })
                    },
                    VisualAuthenticityOriginalDocumentPresentDocumentOnPrintedPaper: {
                        code: "VisualAuthenticityOriginalDocumentPresentDocumentOnPrintedPaper",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be a printed copy."
                        })
                    },
                    VisualAuthenticityOriginalDocumentPresentPhotoOfScreen: {
                        code: "VisualAuthenticityOriginalDocumentPresentPhotoOfScreen",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be a photo of a device screen."
                        })
                    },
                    VisualAuthenticityOriginalDocumentPresentScan: {
                        code: "VisualAuthenticityOriginalDocumentPresentScan",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "We’re unable to verify the document you provided because it contains markings or text that should not be on your document. Please provide a clear photo or a scan of your original identity document."
                        })
                    },
                    VisualAuthenticityOriginalDocumentPresentScreenshot: {
                        code: "VisualAuthenticityOriginalDocumentPresentScreenshot",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be a screenshot."
                        })
                    },
                    VisualAuthenticityPictureFaceIntegrity: {
                        code: "VisualAuthenticityPictureFaceIntegrity",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be invalid."
                        })
                    },
                    VisualAuthenticitySecurityFeatures: {
                        code: "VisualAuthenticitySecurityFeatures",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be invalid."
                        })
                    },
                    VisualAuthenticityTemplate: {
                        code: "VisualAuthenticityTemplate",
                        message: (0, l.jsx)(r.we, {
                            i18n_default_text: "Your document appears to be invalid."
                        })
                    }
                }), Object.freeze({
                    EMPLOYED: "Employed",
                    UNEMPLOYED: "Unemployed",
                    SELF_EMPLOYED: "Self-Employed"
                })
            },
            67127(e, t, i) {
                "use strict";
                i.d(t, {
                    nT: () => _,
                    gw: () => D,
                    PI: () => f,
                    d2: () => x,
                    mR: () => N,
                    _p: () => R,
                    M5: () => b,
                    up: () => g,
                    AB: () => w,
                    W3: () => u,
                    vN: () => I,
                    dX: () => P,
                    tK: () => L,
                    ku: () => C,
                    M9: () => y,
                    hE: () => O,
                    T$: () => d,
                    Or: () => k,
                    Am: () => A,
                    pl: () => p,
                    kN: () => m,
                    Sh: () => v,
                    Fs: () => h,
                    MF: () => S
                });
                var s = i(74848);
                i(96540);
                var o = i(95093),
                    r = i.n(o),
                    a = i(95526),
                    n = i(49655),
                    l = i(64067),
                    c = i(73347);
                let d = {
                    ACCUMULATOR: "ACCU",
                    ASIAN: {
                        UP: "ASIANU",
                        DOWN: "ASIAND"
                    },
                    CALL: "CALL",
                    CALLE: "CALLE",
                    CALL_BARRIER: "CALL_BARRIER",
                    CALL_PUT_SPREAD: {
                        CALL: "CALLSPREAD",
                        PUT: "PUTSPREAD"
                    },
                    END: {
                        IN: "EXPIRYRANGE",
                        OUT: "EXPIRYMISS"
                    },
                    EVEN_ODD: {
                        ODD: "DIGITODD",
                        EVEN: "DIGITEVEN"
                    },
                    EXPIRYRANGEE: "EXPIRYRANGEE",
                    FALL: "FALL",
                    HIGHER: "HIGHER",
                    LB_HIGH_LOW: "LBHIGHLOW",
                    LB_CALL: "LBFLOATCALL",
                    LB_PUT: "LBFLOATPUT",
                    LOWER: "LOWER",
                    MATCH_DIFF: {
                        MATCH: "DIGITMATCH",
                        DIFF: "DIGITDIFF"
                    },
                    MULTIPLIER: {
                        UP: "MULTUP",
                        DOWN: "MULTDOWN"
                    },
                    OVER_UNDER: {
                        OVER: "DIGITOVER",
                        UNDER: "DIGITUNDER"
                    },
                    PUT: "PUT",
                    PUTE: "PUTE",
                    PUT_BARRIER: "PUT_BARRIER",
                    RESET: {
                        CALL: "RESETCALL",
                        PUT: "RESETPUT"
                    },
                    RISE: "RISE",
                    RUN_HIGH_LOW: {
                        HIGH: "RUNHIGH",
                        LOW: "RUNLOW"
                    },
                    STAY: {
                        IN: "RANGE",
                        OUT: "UPORDOWN"
                    },
                    TICK_HIGH_LOW: {
                        HIGH: "TICKHIGH",
                        LOW: "TICKLOW"
                    },
                    TOUCH: {
                        ONE_TOUCH: "ONETOUCH",
                        NO_TOUCH: "NOTOUCH"
                    },
                    TURBOS: {
                        LONG: "TURBOSLONG",
                        SHORT: "TURBOSSHORT"
                    },
                    VANILLA: {
                        CALL: "VANILLALONGCALL",
                        PUT: "VANILLALONGPUT"
                    }
                };
                d.TURBOS.LONG.toLowerCase(), d.TURBOS.SHORT.toLowerCase(), d.VANILLA.CALL.toLowerCase(), d.VANILLA.PUT.toLowerCase();
                let u = e => (e.sell_price || e.bid_price) && p(e) ? e.sell_price || e.bid_price : Number(e.bid_price),
                    h = e => {
                        let {
                            cancellation: {
                                ask_price: t = 0
                            } = {}
                        } = e;
                        return t
                    },
                    p = e => !!(e.status && "open" !== e.status || e.is_expired || e.is_settleable),
                    _ = e => "open" === (e => {
                        let {
                            contract_type: t,
                            exit_tick_time: i,
                            profit: s,
                            status: o
                        } = e;
                        return f(t) ? "open" === o && !i && "open" || (s && s < 0 && i ? "lost" : "won") : o
                    })(e),
                    g = e => !!e.is_valid_to_cancel,
                    m = e => !p(e) && "sold" !== e.status && !!e.is_valid_to_sell,
                    y = e => !!e.entry_spot,
                    f = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return /ACCU/i.test(e)
                    },
                    b = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return /MULT/i.test(e)
                    },
                    k = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return /TURBOS/i.test(e)
                    },
                    v = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return /VANILLA/i.test(e)
                    },
                    w = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return /RUN|EXPIRY|RANGE|UPORDOWN|ASIAN|RESET|TICK|LB/i.test(e)
                    },
                    T = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return /ASIAN/i.test(e)
                    },
                    S = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return /LB/i.test(e)
                    },
                    I = e => {
                        let t = (0, n.Am)(e.tick_stream || [], "epoch"),
                            i = E(e.contract_type) || T(e.contract_type) ? t.length : t.length - 1;
                        return !i || i < 0 ? 0 : i
                    },
                    E = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return /digit/i.test(e)
                    },
                    x = e => Number(e.bid_price) - Number(e.buy_price),
                    A = e => {
                        if (!e) return {
                            stop_loss: null,
                            take_profit: null
                        };
                        let {
                            stop_loss: {
                                order_amount: t
                            } = {},
                            take_profit: {
                                order_amount: i
                            } = {}
                        } = e;
                        return {
                            stop_loss: t,
                            take_profit: i
                        }
                    },
                    C = (e, t, i) => {
                        let s = r().duration(r().unix(i).diff(r().unix(t))),
                            o = r().duration(r().unix(i).diff(e)).asMilliseconds() / s.asMilliseconds() * 100;
                        return o < .5 ? o = 0 : o > 100 && (o = 100), Math.round(o)
                    },
                    R = e => 100 * e,
                    O = e => {
                        let t = "purchased";
                        return p(e) && (t = x(e) >= 0 ? "won" : "lost"), t
                    },
                    D = e => {
                        let {
                            contract_update: t,
                            limit_order: i
                        } = e, {
                            stop_loss: s,
                            take_profit: o
                        } = A(i || t);
                        return {
                            contract_update_stop_loss: s ? Math.abs(s).toString() : "",
                            contract_update_take_profit: o ? o.toString() : "",
                            has_contract_update_stop_loss: !!s,
                            has_contract_update_take_profit: !!o
                        }
                    },
                    B = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return /(VANILLALONG|TURBOS)/i.test(e) ? (0, c.Zr)(e.replace(/(VANILLALONG|TURBOS)/i, "").toLowerCase()) : ""
                    },
                    L = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return k(e) ? "Long" === B(e) ? (0, s.jsx)(a.we, {
                            i18n_default_text: "Up"
                        }) : (0, s.jsx)(a.we, {
                            i18n_default_text: "Down"
                        }) : ""
                    },
                    P = (e, t) => {
                        t ? (t.preventDefault(), ("keydown" !== t.type || "keydown" === t.type && "Enter" === t.key) && (null == e || e())) : null == e || e()
                    },
                    N = (e, t, i) => "buy" === e && !!(0, l.E6)(t, i);
                i(28960)
            },
            99829(e, t, i) {
                "use strict";
                let s;
                i.d(t, {
                    nm: () => h,
                    QW: () => p,
                    Mc: () => c,
                    qI: () => n,
                    ry: () => _,
                    up: () => d,
                    lp: () => a,
                    F0: () => l,
                    JN: () => m
                });
                var o = i(49655);
                let r = {},
                    a = ["USD", "EUR", "GBP", "AUD"],
                    n = ["TUSDT", "BTC", "ETH", "LTC", "UST", "eUSDT", "BUSD", "DAI", "EURS", "IDK", "PAX", "TUSD", "USDC", "USDK", "XRP"],
                    l = (e, t) => Number(Number(e).toFixed(p(t))),
                    c = (e, t) => `${h(e,p(t),_(t))} ${t}`,
                    d = function(e, t, i) {
                        let s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                            o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                            r = t;
                        r && (r = String(r).replace(/,/g, ""));
                        let a = r && 0 > Number(r) ? "-" : "",
                            n = s || p(e);
                        return r = isNaN(+r) ? 0 : Math.abs(+r), r = "undefined" != typeof Intl ? new Intl.NumberFormat("en", {
                            minimumFractionDigits: o || n,
                            maximumFractionDigits: n
                        }).format(r) : h(r, n), a + (i ? "" : u(e)) + r
                    },
                    u = e => `<span class="symbols ${(e||"").toLowerCase()}"></span>`,
                    h = (e, t, i) => {
                        let s = String(e || 0).replace(/,/g, "");
                        return void 0 !== t && (s = (+s).toFixed(t)), i && (s = parseFloat(String(s))), s.toString().replace(/(^|[^\w.])(\d{4,})/g, (e, t, i) => t + i.replace(/\d(?=(?:\d\d\d)+(?!\d))/g, "$&,"))
                    },
                    p = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return r[e] ? (0, o.De)(r, [e, "fractional_digits"]) : _(e) ? (0, o.De)(g.get(), [e, "fractional_digits"]) : 2
                    },
                    _ = e => /crypto/i.test((0, o.De)(r, [e, "type"])) || e in g.get(),
                    g = {
                        get: () => (s || (s = (0, o.ol)({
                            BTC: {
                                display_code: "BTC",
                                name: "Bitcoin",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 8
                            },
                            BUSD: {
                                display_code: "BUSD",
                                name: "Binance USD",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 2
                            },
                            DAI: {
                                display_code: "DAI",
                                name: "Multi-Collateral DAI",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 2
                            },
                            EURS: {
                                display_code: "EURS",
                                name: "STATIS Euro",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 2
                            },
                            IDK: {
                                display_code: "IDK",
                                name: "IDK",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 0
                            },
                            PAX: {
                                display_code: "PAX",
                                name: "Paxos Standard",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 2
                            },
                            TUSD: {
                                display_code: "TUSD",
                                name: "True USD",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 2
                            },
                            USDC: {
                                display_code: "USDC",
                                name: "USD Coin",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 2
                            },
                            USDK: {
                                display_code: "USDK",
                                name: "USDK",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 2
                            },
                            eUSDT: {
                                display_code: "eUSDT",
                                name: "Tether ERC20",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 2
                            },
                            tUSDT: {
                                display_code: "tUSDT",
                                name: "Tether TRC20",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 2
                            },
                            BCH: {
                                display_code: "BCH",
                                name: "Bitcoin Cash",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 8
                            },
                            ETH: {
                                display_code: "ETH",
                                name: "Ether",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 8
                            },
                            ETC: {
                                display_code: "ETC",
                                name: "Ether Classic",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 8
                            },
                            LTC: {
                                display_code: "LTC",
                                name: "Litecoin",
                                min_withdrawal: .002,
                                pa_max_withdrawal: 5,
                                pa_min_withdrawal: .002,
                                fractional_digits: 8
                            },
                            UST: {
                                display_code: "USDT",
                                name: "Tether Omni",
                                min_withdrawal: .02,
                                pa_max_withdrawal: 2e3,
                                pa_min_withdrawal: 10,
                                fractional_digits: 2
                            }
                        })), s)
                    },
                    m = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                        return "eUSDT" !== e && "tUSDT" !== e && (e = e.toUpperCase()), (0, o.De)(g.get(), [e, "display_code"]) || e
                    }
            },
            57662(e, t, i) {
                "use strict";
                i.d(t, {
                    IV: () => c,
                    Yq: () => n,
                    a3: () => d,
                    fU: () => l,
                    pv: () => u,
                    sf: () => a,
                    tD: () => r
                });
                var s = i(95093),
                    o = i.n(s);
                i(95526), o().createFromInputFallback = function(e) {
                    e._d = new Date(NaN)
                };
                let r = e => o().unix(e).utc(),
                    a = e => {
                        if (!e) return o()().utc();
                        if (e instanceof o() && e.isValid() && e.isUTC()) return e;
                        if ("number" == typeof e) return r(e);
                        if (/invalid/i.test(o()(e).toString())) {
                            let t = o()(),
                                i = t.utc().daysInMonth();
                            return o().utc(e, "DD MMM YYYY").valueOf() / 864e5 > i ? o().utc(t.add(e, "d"), "DD MMM YYYY") : o().utc(e, "DD MMM YYYY")
                        }
                        return o().utc(e)
                    },
                    n = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "YYYY-MM-DD",
                            i = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2];
                        return i || null !== e ? a(e).format(t) : void 0
                    },
                    l = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "HH:mm:ss [GMT]";
                        return a(e).format(t)
                    },
                    c = (e, t) => o().duration(o().unix(t).diff(o().unix(e))),
                    d = (e, t) => {
                        let i = Math.floor(e.asDays()),
                            s = e.hours(),
                            r = e.minutes(),
                            a = e.seconds();
                        return {
                            days: i,
                            timestamp: o()(0).hour(s).minute(r).seconds(a).format(t || "HH:mm:ss")
                        }
                    },
                    u = (e, t, i) => o()(e, t).format(i)
            },
            53928(e, t, i) {
                "use strict";
                e = i.hmd(e);
                let s = function() {
                    let e, t, i;

                    function s(e, t) {
                        return null != t && e instanceof t
                    }
                    try {
                        e = Map
                    } catch (t) {
                        e = function() {}
                    }
                    try {
                        t = Set
                    } catch (e) {
                        t = function() {}
                    }
                    try {
                        i = Promise
                    } catch (e) {
                        i = function() {}
                    }

                    function o(r, n, l, c, d) {
                        "object" == typeof n && (l = n.depth, c = n.prototype, d = n.includeNonEnumerable, n = n.circular);
                        let u = [],
                            h = [],
                            p = "undefined" != typeof Buffer;
                        return void 0 === n && (n = !0), void 0 === l && (l = 1 / 0),
                            function r(l, _) {
                                let g;
                                if (null === l) return null;
                                if (0 === _ || "object" != typeof l) return l;
                                if (s(l, e)) g = new e;
                                else if (s(l, t)) g = new t;
                                else if (s(l, i)) g = new i(function(e, t) {
                                    l.then(function(t) {
                                        e(r(t, _ - 1))
                                    }, function(e) {
                                        t(r(e, _ - 1))
                                    })
                                });
                                else if (o.__isArray(l)) g = [];
                                else if (o.__isRegExp(l)) g = new RegExp(l.source, a(l)), l.lastIndex && (g.lastIndex = l.lastIndex);
                                else if (o.__isDate(l)) g = new Date(l.getTime());
                                else {
                                    if (p && Buffer.isBuffer(l)) return Buffer.from ? g = Buffer.from(l) : (g = new Buffer(l.length), l.copy(g)), g;
                                    s(l, Error) ? g = Object.create(l) : void 0 === c ? g = Object.create(Object.getPrototypeOf(l)) : g = Object.create(c)
                                }
                                if (n) {
                                    let e = u.indexOf(l);
                                    if (-1 != e) return h[e];
                                    u.push(l), h.push(g)
                                }
                                for (var m in s(l, e) && l.forEach(function(e, t) {
                                        let i = r(t, _ - 1),
                                            s = r(e, _ - 1);
                                        g.set(i, s)
                                    }), s(l, t) && l.forEach(function(e) {
                                        let t = r(e, _ - 1);
                                        g.add(t)
                                    }), l) {
                                    if (Object.getOwnPropertyDescriptor(l, m)) {
                                        if (0 > Object.keys(l).indexOf(m)) continue;
                                        g[m] = r(l[m], _ - 1)
                                    }
                                    try {
                                        let e = Object.getOwnPropertyDescriptor(l, m);
                                        if ("undefined" === e.set) continue;
                                        g[m] = r(l[m], _ - 1)
                                    } catch (e) {
                                        if (e instanceof TypeError || e instanceof ReferenceError) continue
                                    }
                                }
                                if (Object.getOwnPropertySymbols) {
                                    let e = Object.getOwnPropertySymbols(l);
                                    for (var m = 0; m < e.length; m++) {
                                        let t = e[m];
                                        var y = Object.getOwnPropertyDescriptor(l, t);
                                        (!y || y.enumerable || d) && (g[t] = r(l[t], _ - 1), Object.defineProperty(g, t, y))
                                    }
                                }
                                if (d) {
                                    let e = Object.getOwnPropertyNames(l);
                                    for (var m = 0; m < e.length; m++) {
                                        let t = e[m];
                                        var y = Object.getOwnPropertyDescriptor(l, t);
                                        y && y.enumerable || (g[t] = r(l[t], _ - 1), Object.defineProperty(g, t, y))
                                    }
                                }
                                return g
                            }(r, l)
                    }

                    function r(e) {
                        return Object.prototype.toString.call(e)
                    }

                    function a(e) {
                        let t = "";
                        return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), t
                    }
                    return o.clonePrototype = function(e) {
                        if (null === e) return null;
                        let t = function() {};
                        return t.prototype = e, new t
                    }, o.__objToStr = r, o.__isDate = function(e) {
                        return "object" == typeof e && "[object Date]" === r(e)
                    }, o.__isArray = function(e) {
                        return "object" == typeof e && "[object Array]" === r(e)
                    }, o.__isRegExp = function(e) {
                        return "object" == typeof e && "[object RegExp]" === r(e)
                    }, o.__getRegExpFlags = a, o
                }();
                e.exports && (e.exports = s)
            },
            49655(e, t, i) {
                "use strict";
                i.d(t, {
                    Am: () => s.Am,
                    De: () => s.De,
                    Hv: () => s.Hv,
                    K2: () => s.K2,
                    RI: () => s.RI,
                    Up: () => s.Up,
                    We: () => s.We,
                    h2: () => s.h2,
                    ob: () => s.ob,
                    ol: () => s.ol
                }), i(53928);
                var s = i(55416)
            },
            55416(e, t, i) {
                "use strict";
                i.d(t, {
                    Am: () => l,
                    De: () => c,
                    Hv: () => r,
                    K2: () => d,
                    RI: () => s,
                    Up: () => u,
                    We: () => h,
                    h2: () => o,
                    ob: () => n,
                    ol: () => p
                });
                let s = e => {
                        let t = !0;
                        return e && e instanceof Object && Object.keys(e).forEach(i => {
                            Object.prototype.hasOwnProperty.call(e, i) && (t = !1)
                        }), t
                    },
                    o = e => {
                        if (s(e)) return e;
                        let t = Array.isArray(e) ? [] : {};
                        for (let i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
                        return t
                    },
                    r = (e, t) => typeof e == typeof t && (Array.isArray(e) ? a(e, t) : e && t && "object" == typeof e ? n(e, t) : !!("number" == typeof e && "number" == typeof t && isNaN(e) && isNaN(t)) || e === t),
                    a = (e, t) => e === t || e.length === t.length && e.every((e, i) => r(e, t[i])),
                    n = (e, t) => e === t || Object.keys(e).length === Object.keys(t).length && Object.keys(e).every(i => r(e[i], t[i])),
                    l = (e, t) => e.filter((i, s) => e.findIndex((e, o) => e[t] ? e[t] === i[t] : o === s) === s),
                    c = (e, t) => {
                        let i = t;
                        return (Array.isArray(i) || (i = [i]), !s(e) && i[0] in e && i && i.length > 1) ? c(e[i[0]], i.slice(1)) : e ? o(e[i[0]]) : void 0
                    },
                    d = e => Array.from(Array(e).keys()),
                    u = (e, t) => t.reduce((t, i) => (Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]), t), {}),
                    h = (e, t) => {
                        let i;
                        return Object.keys(e).some(s => {
                            let o = e[s];
                            if (s === t) return i = e[t], !0;
                            if ("object" == typeof o) {
                                let e = h(o, t);
                                if (e) return i = e, !0
                            }
                            return !1
                        }), i
                    },
                    p = e => (Object.getOwnPropertyNames(e).forEach(t => {
                        let i = e[t];
                        i && "object" == typeof i && !Object.isFrozen(i) && p(i)
                    }), Object.freeze(e))
            },
            28960(e, t, i) {
                "use strict";
                i.d(t, {
                    f: () => r
                });
                let s = {
                        derivCom: {
                            staging: "https://staging.deriv.com",
                            production: {
                                me: "https://deriv.me",
                                be: "https://deriv.be",
                                com: "https://deriv.com"
                            }
                        },
                        derivApp: {
                            staging: "https://staging-app.deriv.com",
                            production: {
                                me: "https://app.deriv.me",
                                be: "https://app.deriv.be",
                                com: "https://app.deriv.com"
                            }
                        },
                        smartTrader: {
                            staging: {
                                me: "https://staging-smarttrader.deriv.me",
                                be: "https://staging-smarttrader.deriv.be",
                                com: "https://staging-smarttrader.deriv.com"
                            },
                            production: {
                                me: "https://smarttrader.deriv.me",
                                be: "https://smarttrader.deriv.be",
                                com: "https://smarttrader.deriv.com"
                            }
                        },
                        derivHub: {
                            staging: "https://staging-hub.deriv.com",
                            production: {
                                me: "https://hub.deriv.me",
                                be: "https://hub.deriv.be",
                                com: "https://hub.deriv.com"
                            }
                        }
                    },
                    o = e => {
                        let t = window.location.hostname,
                            i = t.includes("staging"),
                            o = t.endsWith(".me") ? "me" : t.endsWith(".be") ? "be" : "com",
                            r = s[e];
                        return i ? "string" == typeof r.staging ? r.staging : r.staging[o] : r.production[o]
                    },
                    r = {
                        account_settings: `${o("derivHub")}/accounts`,
                        bot: `${window.location.origin}`,
                        cashier: `${o("derivApp")}/cashier/`,
                        cashier_deposit: `${o("derivApp")}/cashier/deposit`,
                        cashier_p2p: `${o("derivApp")}/cashier/p2p`,
                        contract: `${o("derivApp")}/contract/:contract_id`,
                        personal_details: `${o("derivApp")}/account/personal-details`,
                        positions: `${o("derivApp")}/reports/positions`,
                        profit: `${o("derivApp")}/reports/profit`,
                        reports: `${o("derivApp")}/reports`,
                        root: o("derivApp"),
                        smarttrader: o("smartTrader"),
                        statement: `${o("derivApp")}/reports/statement`,
                        trade: `${o("derivApp")}/dtrader`,
                        traders_hub: o("derivApp"),
                        traders_hub_lowcode: o("derivHub"),
                        recent_transactions: `${o("derivHub")}/tradershub/redirect?action=redirect_to&redirect_to=wallet`,
                        wallets_transfer: `${o("derivApp")}/wallet/account-transfer`,
                        signup: `${o("derivHub")}/tradershub/signup`,
                        deriv_com: o("derivCom"),
                        deriv_app: o("derivApp"),
                        endpoint: `${window.location.origin}/endpoint`,
                        account_limits: `${o("derivApp")}/account/account-limits`,
                        help_center: `${o("derivCom")}/help-centre/`,
                        responsible: `${o("derivCom")}/responsible/`
                    }
            },
            33048(e, t, i) {
                "use strict";
                i.d(t, {
                    CN: () => s,
                    Fr: () => o,
                    xl: () => r
                });
                let s = () => "ontouchstart" in window || "ontouchstart" in document.documentElement || window.DocumentTouch && document instanceof window.DocumentTouch || navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints > 0,
                    o = () => window.innerWidth <= 600,
                    r = () => a() || window.innerWidth > 1279,
                    a = () => 600 < window.innerWidth && window.innerWidth <= 1279
            },
            64067(e, t, i) {
                "use strict";
                i.d(t, {
                    E6: () => c,
                    b$: () => l
                });
                let s = "^([A-Z]+)_((?:1HZ[0-9-V]+)|(?:(?:CRASH|BOOM)[0-9\\d]+[A-Z]?)|(?:cry_[A-Z]+)|(?:JD[0-9]+)|(?:OTC_[A-Z0-9]+)|R_[\\d]{2,3}|[A-Z]+)_([\\d.]+)",
                    o = RegExp(`${s}_(\\d+)_(\\d*\\.?\\d*)_(\\d+)_(\\d*\\.?\\d*)_(\\d+)`),
                    r = RegExp(`${s}_(\\d+)_(\\d+)`),
                    a = RegExp(`${s}_([A-Z\\d]+)_([A-Z\\d]+)_?([A-Z\\d]+)?`),
                    n = e => {
                        let t = {
                                category: "",
                                underlying: "",
                                barrier_1: "",
                                multiplier: "",
                                start_time: "",
                                payout_tick: "",
                                growth_rate: "",
                                growth_frequency: ""
                            },
                            i = /^ACCU/i.test(e),
                            s = /^MULT/i.test(e),
                            n = (s ? r : i ? o : a).exec(e);
                        return null !== n && (t.category = n[1].charAt(0).toUpperCase() + n[1].slice(1).toLowerCase(), t.underlying = n[2], s ? (t.multiplier = n[4], t.start_time = n[5]) : i ? (t.payout_tick = n[4], t.growth_rate = n[5], t.growth_frequency = n[6], t.start_time = n[8]) : t.start_time = n[4], /^(CALL|PUT)$/i.test(t.category) && (t.barrier_1 = n[6])), t
                    },
                    l = e => {
                        let {
                            shortcode: t = "",
                            shortcode_info: i
                        } = e, s = t ? n(t) : i;
                        return !!s && !!s.barrier_1 && !/^S0P$/.test(s.barrier_1)
                    },
                    c = (e, t) => {
                        let i, s = (null == (i = n(e)) || !i.multiplier) && ((null == i ? void 0 : i.start_time) || "");
                        return s && t && /f$/gi.test(s)
                    }
            },
            2168(e, t, i) {
                "use strict";
                i.d(t, {
                    Ln: () => c,
                    U5: () => l,
                    Vs: () => _,
                    W6: () => p
                });
                var s = i(18987),
                    o = i(55416),
                    r = i(62864);
                let a = function(e) {
                        return JSON.parse(this.getItem(e) || "{}")
                    },
                    n = function(e, t) {
                        if (t && t instanceof Object) try {
                            this.setItem(e, JSON.stringify(t))
                        } catch (e) {}
                    };
                "undefined" != typeof Storage && (Storage.prototype.getObject = a, Storage.prototype.setObject = n);
                let l = e => {
                        if (void 0 === e) return !1;
                        let t = "test";
                        try {
                            return e.setItem(t, "1"), e.removeItem(t), !0
                        } catch (e) {
                            return !1
                        }
                    },
                    c = () => {
                        let e, t, {
                            cookiesBlocked: i,
                            localStorageBlocked: o
                        } = (e = !(() => {
                            try {
                                let e = "cookie_test";
                                s.A.set(e, "1", {
                                    path: "/"
                                });
                                let t = s.A.get(e);
                                return s.A.remove(e, {
                                    path: "/"
                                }), "1" === t
                            } catch (e) {
                                return !1
                            }
                        })(), {
                            cookiesBlocked: e,
                            localStorageBlocked: t = !l(window.localStorage),
                            anyBlocked: e || t
                        });
                        if (i || o) {
                            let e = [];
                            i && e.push("Cookies"), o && e.push("localStorage"), console.warn(`[Storage Warning] ${e.join(" and ")} ${e.length>1?"are":"is"} blocked or unavailable. This may cause authentication issues. Please check your browser settings or disable third-party cookie blocking for this site.`)
                        }
                    },
                    d = function(e) {
                        this.storage = e, this.storage.getObject = a, this.storage.setObject = n
                    };
                d.prototype = {
                    get(e) {
                        return this.storage.getItem(e) || void 0
                    },
                    set(e, t) {
                        void 0 !== t && this.storage.setItem(e, t)
                    },
                    getObject(e) {
                        return "function" == typeof this.storage.getObject ? this.storage.getObject(e) : JSON.parse(this.storage.getItem(e) || "{}")
                    },
                    setObject(e, t) {
                        "function" == typeof this.storage.setObject ? this.storage.setObject(e, t) : this.storage.setItem(e, JSON.stringify(t))
                    },
                    remove(e) {
                        this.storage.removeItem(e)
                    },
                    clear() {
                        this.storage.clear()
                    }
                };
                let u = function(e) {
                    this.store = void 0 !== e ? e : {}
                };
                u.prototype = {
                    get(e) {
                        return (0, o.De)(this.store, e)
                    },
                    set(e, t) {
                        let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.store,
                            s = e;
                        Array.isArray(s) || (s = [s]), s.length > 1 ? ((!(s[0] in i) || (0, o.RI)(i[s[0]])) && (i[s[0]] = {}), this.set(s.slice(1), t, i[s[0]])) : i[s[0]] = t
                    },
                    getObject(e) {
                        return JSON.parse(this.get(e) || "{}")
                    },
                    setObject(e, t) {
                        this.set(e, JSON.stringify(t))
                    },
                    remove() {
                        for (var e = arguments.length, t = Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                        t.forEach(e => {
                            delete this.store[e]
                        })
                    },
                    clear() {
                        this.store = {}
                    },
                    has(e) {
                        return void 0 !== this.get(e)
                    },
                    keys() {
                        return Object.keys(this.store)
                    },
                    call(e) {
                        "function" == typeof this.get(e) && this.get(e)()
                    }
                };
                let h = new u;
                h.prototype = u.prototype, h.prototype.getResponse = function(e) {
                    let t = e;
                    if ("string" == typeof t) {
                        let e = t.split(".");
                        t = ["response", e[0]].concat(e)
                    }
                    return this.get(t)
                }, h.prototype.getByMsgType = h.getResponse, h.set("response", {});
                let p = function(e, t) {
                    let i = window.location.hostname;
                    this.initialized = !1, this.cookie_name = e, this.domain = t || (i.includes("binary.sx") ? "binary.sx" : r.G.DERIV_HOST_NAME), this.path = "/", this.expires = new Date("Thu, 1 Jan 2037 12:00:00 GMT"), this.value = {}
                };
                p.prototype = {
                    read() {
                        let e = s.A.get(this.cookie_name);
                        try {
                            this.value = e ? JSON.parse(e) : {}
                        } catch (e) {
                            this.value = {}
                        }
                        this.initialized = !0
                    },
                    write(e, t, i) {
                        this.initialized || this.read(), this.value = e, t && (this.expires = t), s.A.set(this.cookie_name, this.value, {
                            expires: this.expires,
                            path: this.path,
                            domain: this.domain,
                            secure: !!i,
                            sameSite: "Lax"
                        })
                    },
                    get(e) {
                        return this.initialized || this.read(), this.value[e]
                    },
                    set(e, t) {
                        this.initialized || this.read(), this.value[e] = t, s.A.set(this.cookie_name, this.value, {
                            expires: new Date(this.expires),
                            path: this.path,
                            domain: this.domain,
                            sameSite: "Lax"
                        })
                    },
                    remove() {
                        s.A.remove(this.cookie_name, {
                            path: this.path,
                            domain: this.domain
                        })
                    }
                };
                let _ = l(window.localStorage) ? new d(window.localStorage) : new u;
                l(window.sessionStorage) ? new d(window.sessionStorage) : new u
            },
            73347(e, t, i) {
                "use strict";
                i.d(t, {
                    Zr: () => n,
                    gW: () => o,
                    ku: () => r,
                    t: () => l
                });
                let s = (e, t, i) => {
                        let s = String(e || "");
                        return s.length >= t ? s : `${Array(t-s.length+1).join(i)}${s}`
                    },
                    o = (e, t) => {
                        let i = a(e),
                            o = a(t);
                        if (!i || !o) return "";
                        let r = Math.max(i.length, o.length);
                        i = s(i, r, "0");
                        let n = 0;
                        return i !== (o = s(o, r, "0")) && (n = i > o ? 1 : -1), n
                    },
                    r = (e, t) => (null == t ? void 0 : t.length) < 1 || RegExp(t.split("").reduce((e, t) => `${e}[^${t}]*${t}`, ""), "i").test(e),
                    a = e => "number" == typeof e ? String(e) : e,
                    n = e => e && e[0].toUpperCase() + e.slice(1),
                    l = e => e.normalize("NFD").split("").filter(e => /^[a-z ]*$/i.test(e)).join("")
            },
            62864(e, t, i) {
                "use strict";
                i.d(t, {
                    G: () => a
                });
                let s = "deriv.com",
                    o = "undefined" != typeof window && window.location.hostname.split("app.")[1] || "",
                    r = [s, "deriv.me", "deriv.be"].includes(o) ? o : s,
                    a = Object.freeze({
                        DERIV_HOST_NAME: r,
                        DERIV_COM_PRODUCTION: `https://${r}`,
                        DERIV_COM_PRODUCTION_EU: `https://eu.${r}`,
                        DERIV_COM_STAGING: `https://staging.${r}`,
                        DERIV_APP_PRODUCTION: `https://app.${r}`,
                        DERIV_APP_STAGING: `https://staging-app.${r}`,
                        SMARTTRADER_PRODUCTION: `https://smarttrader.${r}`,
                        SMARTTRADER_STAGING: `https://staging-smarttrader.${r}`,
                        BINARYBOT_PRODUCTION: `https://bot.${r}`,
                        BINARYBOT_STAGING: `https://staging-bot.${r}`
                    })
            },
            17276(e, t, i) {
                "use strict";
                let s;
                i.d(t, {
                    IK: () => c,
                    I8: () => u,
                    YG: () => h,
                    ts: () => d
                });
                var o = i(62864),
                    r = i(77354);
                i(28960);
                let a = "binary.com",
                    n = {
                        "bot.binary.com": "www.binary.bot",
                        "developers.binary.com": "developers.binary.com",
                        "academy.binary.com": "academy.binary.com",
                        "blog.binary.com": "blog.binary.com"
                    },
                    l = e => e ? e.replace(/(^\/|\/$|[^a-zA-Z0-9-_./()#])/g, "") : "",
                    c = e => {
                        let t = (0, r.Du)();
                        if (!t) return e;
                        let i = new URL(e);
                        if (Object.keys(n).includes(i.hostname)) i.hostname = n[i.hostname];
                        else {
                            if (!i.hostname.match(a)) return e;
                            i.hostname = i.hostname.replace(RegExp(`\\.${a}`, "i"), `.${t}`)
                        }
                        return i.href
                    },
                    d = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                            t = window.location;
                        return /^\/(br_)/.test(t.pathname) ? `/${t.pathname.split("/")[1]}${/^\//.test(e)?e:`/${e}`}` : e
                    },
                    u = e => {
                        s = e
                    },
                    h = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                            t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                            r = i ? o.G.DERIV_COM_PRODUCTION_EU : o.G.DERIV_COM_PRODUCTION,
                            a = null == s ? void 0 : s.toLowerCase();
                        return (a = a && "en" !== a ? `/${a}` : "", t) ? `${r}/${l(e)}` : (r === o.G.DERIV_COM_PRODUCTION && a.includes("_") && (a = a.replace("_", "-")), `${r}${a}/${l(e)}`)
                    }
            },
            2457(e, t, i) {
                "use strict";
                let s, o;
                i.d(t, {
                    BS: () => c,
                    fh: () => I,
                    lo: () => E
                });
                var r = i(99829),
                    a = i(49655),
                    n = i(73347);
                let l = e => null != e && e.toString().replace(/\s/g, "").length > 0,
                    c = ". , ' : ; ( ) \xb0 @ # / -",
                    d = (e, t) => (null == t ? void 0 : t.is_required) && (!e || e.match(/^\s*$/)) ? {
                        is_ok: !1,
                        message: null == o ? void 0 : o.empty_address()
                    } : g(e, {
                        min: 0,
                        max: 70
                    }) ? /^[\p{L}\p{Nd}\s'.,:;()\u00b0@#/-]{0,70}$/u.test(e) ? {
                        is_ok: !0
                    } : {
                        is_ok: !1,
                        message: null == o ? void 0 : o.address()
                    } : {
                        is_ok: !1,
                        message: null == o ? void 0 : o.maxNumber(70)
                    },
                    u = e => "" === e || /^[A-Za-z0-9][A-Za-z0-9\s-]*$/.test(e),
                    h = e => /(?!^$|\s+)[A-Za-z0-9./\s-]$/.test(e),
                    p = e => /^\+?([0-9-]+\s)*[0-9-]+$/.test(e),
                    _ = e => /^(?!.*\s{2,})[\p{L}\s'.-]{2,50}$/u.test(e),
                    g = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                            t = arguments.length > 1 ? arguments[1] : void 0;
                        return (!t.min || e.length >= Number(t.min)) && (!t.max || e.length <= Number(t.max))
                    },
                    m = e => /^(?=.*[a-z])(?=.*\d)(?=.*[A-Z])[!-~]{8,25}$/.test(e),
                    y = e => /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$/.test(e),
                    f = e => /^[+-]?\d+\.?\d*$/.test(e),
                    b = e => !/[`~!@#$%^&*)(_=+[}{\]\\/";:?><|]+/.test(e),
                    k = (e, t) => {
                        var i;
                        return null == (i = t.regex) ? void 0 : i.test(e)
                    },
                    v = e => !!e,
                    w = e => !/p[.\s]+o[.\s]+box/i.test(e),
                    T = e => 8 === e.trim().length,
                    S = (e, t) => "float" === t.type ? +e > Number(t.max) : 1 === (0, n.gW)(e, t.max),
                    I = e => {
                        s || (s = {
                            address: {
                                func: d,
                                message: (o = e).address
                            },
                            barrier: {
                                func: f,
                                message: o.barrier
                            },
                            email: {
                                func: y,
                                message: o.email
                            },
                            general: {
                                func: b,
                                message: o.general
                            },
                            length: {
                                func: g,
                                message: ""
                            },
                            name: {
                                func: _,
                                message: o.name
                            },
                            number: {
                                func: function() {
                                    for (var e = arguments.length, t = Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                                    let [s, n] = t;
                                    return ((e, t) => {
                                        let i = (0, a.h2)(t),
                                            s = null;
                                        if (i.allow_empty && 0 === e.length) return {
                                            is_ok: !0
                                        };
                                        let n = !0;
                                        if ("min" in i && "function" == typeof i.min && (i.min = i.min()), "max" in i && "function" == typeof i.max && (i.max = i.max()), !("float" === i.type ? /^\d*(\.\d+)?$/ : /^\d+$/).test(e) || isNaN(+e)) n = !1, s = o.number();
                                        else if ("min" in i && "max" in i && +i.min == +i.max && +e != +i.min) n = !1, s = o.value((0, r.nm)(i.min, i.decimals));
                                        else if ("min" in i && "max" in i && i.min > 0 && (+e < +i.min || S(+e, i))) {
                                            n = !1;
                                            let e = (0, r.nm)(i.min, i.decimals),
                                                t = (0, r.nm)(i.max, i.decimals);
                                            s = o.betweenMinMax(e, t)
                                        } else if ("float" === i.type && i.decimals && !RegExp(`^\\d+(\\.\\d{0,${i.decimals}})?$`).test(e)) n = !1, s = o.decimalPlaces(i.decimals);
                                        else if ("min" in i && +e < +i.min) {
                                            n = !1;
                                            let e = (0, r.nm)(i.min, i.decimals);
                                            s = o.minNumber(e)
                                        } else if ("max" in i && S(+e, i)) {
                                            n = !1;
                                            let e = (0, r.nm)(i.max, i.decimals);
                                            s = o.maxNumber(e)
                                        }
                                        return {
                                            is_ok: n,
                                            message: s
                                        }
                                    })(s, n)
                                },
                                message: o.number
                            },
                            password: {
                                func: m,
                                message: o.password
                            },
                            phone: {
                                func: p,
                                message: o.phone
                            },
                            po_box: {
                                func: w,
                                message: o.po_box
                            },
                            postcode: {
                                func: u,
                                message: o.postcode
                            },
                            regular: {
                                func: k,
                                message: ""
                            },
                            req: {
                                func: l,
                                message: ""
                            },
                            confirm: {
                                func: v,
                                message: ""
                            },
                            signup_token: {
                                func: T,
                                message: o.signup_token
                            },
                            tax_id: {
                                func: h,
                                message: o.validTaxID
                            }
                        })
                    },
                    E = () => s
            },
            16115(e, t, i) {
                "use strict";
                i.d(t, {
                    BS: () => s.BS
                });
                var s = i(2457);
                i(29340), i(81753)
            },
            92202(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => h
                });
                var s = i(74848);
                i(96540);
                var o = i(46942),
                    r = i.n(o),
                    a = i(39706),
                    n = i(57667),
                    l = i(52217);
                let c = e => {
                        let {
                            className: t,
                            id: i,
                            is_fullscreen: o = !0,
                            is_slow_loading: a,
                            status: n,
                            theme: c
                        } = e, d = c ? `barspinner-${c}` : "barspinner-light";
                        return (0, s.jsxs)("div", {
                            "data-testid": "dt_initial_loader",
                            className: r()("initial-loader", {
                                "initial-loader--fullscreen": o
                            }, t),
                            children: [(0, s.jsx)("div", {
                                id: i,
                                className: r()("initial-loader__barspinner", "barspinner", d),
                                children: Array.from([, , , , , ]).map((e, t) => (0, s.jsx)("div", {
                                    className: `initial-loader__barspinner--rect barspinner__rect barspinner__rect--${t+1} rect${t+1}`
                                }, t))
                            }), a && (null == n ? void 0 : n.map((e, t) => (0, s.jsx)(l.A, {
                                as: "h3",
                                color: "prominent",
                                size: "xs",
                                align: "center",
                                children: e
                            }, t)))]
                        })
                    },
                    d = e => (0, s.jsx)(c, { ...e,
                        is_fullscreen: !1,
                        className: "initial-loader--btn"
                    }),
                    u = e => {
                        let {
                            black: t,
                            blue: i,
                            children: o,
                            className: l = "",
                            classNameSpan: c,
                            green: u,
                            has_effect: h,
                            icon: p,
                            id: _,
                            is_disabled: g,
                            is_loading: m,
                            is_submit_success: y,
                            is_button_toggle: f,
                            is_circle: b,
                            is_circular: k,
                            is_plus: v,
                            large: w,
                            medium: T,
                            onClick: S,
                            rounded: I,
                            tabIndex: E = 0,
                            text: x,
                            wrapperClassName: A,
                            type: C,
                            primary: R,
                            primary_light: O,
                            secondary: D,
                            alternate: B,
                            transparent: L,
                            small: P,
                            tertiary: N,
                            renderText: j,
                            ...U
                        } = e, M = r()("dc-btn", {
                            "dc-btn__effect": h,
                            "dc-btn--primary": R,
                            "dc-btn--black": t,
                            "dc-btn--blue": i,
                            "dc-btn--secondary": D,
                            "dc-btn--tertiary": N,
                            "dc-btn--primary__light": O,
                            "dc-btn--primary__blue": i && R,
                            "dc-btn--tertiary__blue": i && N,
                            "dc-btn--alternate": B,
                            "dc-btn--green": u,
                            "dc-btn__rounded": I,
                            "dc-btn__large": w,
                            "dc-btn__medium": T,
                            "dc-btn__small": P,
                            "dc-btn__toggle": f,
                            "dc-btn--plus": v,
                            "dc-btn--circle": b,
                            "dc-btn--circular": k,
                            "dc-btn--transparent": L
                        }, l), H = (0, s.jsxs)("button", {
                            id: _,
                            className: M,
                            onClick: S,
                            disabled: g,
                            tabIndex: E,
                            type: y ? "button" : C || "submit",
                            ...U,
                            children: [p && (0, s.jsx)("div", {
                                className: r()("dc-btn__icon", {
                                    "dc-btn__icon--circle": b
                                }),
                                children: p
                            }), x && !(m || y) && ("function" == typeof j && j(x[0].toUpperCase() + x.substr(1)) || (0, s.jsx)(n.A, {
                                size: "xs",
                                weight: "bold",
                                align: "center",
                                className: r()("dc-btn__text", c),
                                children: x[0].toUpperCase() + x.substr(1)
                            })), m && (0, s.jsx)(d, {}), y && (0, s.jsx)(a.I, {
                                icon: "IcCheckmark",
                                color: "active",
                                size: 24
                            }), v && (0, s.jsx)(a.I, {
                                icon: "IcAddBold",
                                color: "black",
                                size: 18
                            }), !x && !m && o && (0, s.jsx)(n.A, {
                                size: "xs",
                                weight: "bold",
                                align: "center",
                                className: r()("dc-btn__text", c),
                                children: o
                            })]
                        }), F = (0, s.jsx)("div", {
                            className: A,
                            children: H
                        });
                        return A ? F : H
                    };
                u.Group = e => {
                    let {
                        children: t,
                        className: i
                    } = e;
                    return (0, s.jsx)("div", {
                        className: r()("dc-btn__group", i),
                        children: t
                    })
                };
                let h = u
            },
            77682(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => p
                });
                var s = i(74848),
                    o = i(96540),
                    r = i(46942),
                    a = i.n(r),
                    n = i(40961),
                    l = i(62846),
                    c = i(71699),
                    d = i(64192),
                    u = i(92202),
                    h = i(57667);
                let p = e => {
                    var t;
                    let {
                        disableApp: i,
                        dismissable: r,
                        enableApp: p,
                        is_closed_on_cancel: _ = !0,
                        is_closed_on_confirm: g = !0,
                        is_visible: m,
                        onCancel: y,
                        onClose: f,
                        onConfirm: b,
                        onEscapeButtonCancel: k,
                        ...v
                    } = e, {
                        cancel_button_text: w,
                        className: T,
                        children: S,
                        confirm_button_text: I,
                        is_loading: E,
                        is_mobile_full_width: x = !0,
                        is_content_centered: A,
                        portal_element_id: C,
                        title: R,
                        has_close_icon: O
                    } = v, D = o.useRef();
                    o.useEffect(() => {
                        m && i && i()
                    }, [m, i]), o.useEffect(() => {
                        let e = e => {
                            "Escape" === e.key && (null == k || k())
                        };
                        return window.addEventListener("keydown", e), () => window.removeEventListener("keydown", e)
                    }, []);
                    let B = () => {
                            _ && p && p(), null == y || y()
                        },
                        L = () => {
                            g && p && p(), b()
                        },
                        P = () => {
                            f ? f() : y ? B() : L()
                        };
                    (0, c.W)(D, P, () => !!r || !!(O && m && _));
                    let N = a()("dc-dialog__content", {
                            "dc-dialog__content--centered": A
                        }),
                        j = "string" == typeof S || o.isValidElement(S) && "string" == typeof(null == S || null == (t = S.props) ? void 0 : t.i18n_default_text),
                        U = (0, s.jsx)(l.A, {
                            appear: !0,
                            in: m && !E,
                            timeout: 50,
                            classNames: {
                                appear: "dc-dialog__wrapper--enter",
                                enter: "dc-dialog__wrapper--enter",
                                enterDone: "dc-dialog__wrapper--enter-done",
                                exit: "dc-dialog__wrapper--exit"
                            },
                            unmountOnExit: !0,
                            children: (0, s.jsx)("div", {
                                className: a()("dc-dialog__wrapper", T, {
                                    "dc-dialog__wrapper--has-portal": !!C
                                }),
                                children: (0, s.jsxs)("div", {
                                    className: a()("dc-dialog__dialog", {
                                        "dc-dialog__dialog--has-margin": !x
                                    }),
                                    role: "dialog",
                                    ref: D,
                                    children: [(R || O) && (0, s.jsxs)("div", {
                                        className: a()("dc-dialog__header-wrapper", {
                                            "dc-dialog__header-wrapper--end": !R
                                        }),
                                        children: [!!R && (0, s.jsx)(h.A, {
                                            as: "h1",
                                            color: "prominent",
                                            weight: "bold",
                                            className: "dc-dialog__header--title",
                                            children: R
                                        }), O && (0, s.jsx)("div", {
                                            onClick: P,
                                            className: "dc-dialog__header--close",
                                            children: (0, s.jsx)(d.A, {
                                                height: "20px",
                                                width: "20px",
                                                fill: "var(--text-general)",
                                                className: "icon-general-fill-path"
                                            })
                                        })]
                                    }), j ? (0, s.jsx)(h.A, {
                                        as: "p",
                                        size: "xs",
                                        styles: {
                                            lineHeight: "1.43"
                                        },
                                        className: N,
                                        children: S
                                    }) : (0, s.jsx)("div", {
                                        className: N,
                                        children: S
                                    }), (0, s.jsxs)("div", {
                                        className: "dc-dialog__footer",
                                        children: [!!y && (0, s.jsx)(u.A, {
                                            className: "dc-dialog__button",
                                            has_effect: !0,
                                            text: w,
                                            onClick: B,
                                            secondary: !0,
                                            large: !0
                                        }), !!I && (0, s.jsx)(u.A, {
                                            className: "dc-dialog__button",
                                            has_effect: !0,
                                            text: I,
                                            onClick: L,
                                            primary: !0,
                                            large: !0
                                        })]
                                    })]
                                })
                            })
                        });
                    if (C) {
                        let e = document.getElementById(C);
                        if (e) return n.createPortal(U, e)
                    }
                    return U
                }
            },
            65823(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => a
                });
                var s = i(74848),
                    o = i(96540),
                    r = i(28176);
                let a = o.memo(e => {
                    let {
                        amount: t = 0,
                        className: i,
                        currency: a = "USD",
                        has_sign: n,
                        should_format: l = !0,
                        show_currency: c = !1
                    } = e, d = "";
                    Number(t) && (0 > Number(t) || n) && (d = Number(t) > 0 ? "+" : "-");
                    let u = n || l ? Math.abs(Number(t)) : t,
                        h = l ? (0, r.upu)(a, u, !0, 0, 0) : u;
                    return (0, s.jsxs)(o.Fragment, {
                        children: [(0, s.jsx)("span", {
                            children: n && d
                        }), (0, s.jsxs)("span", {
                            "data-testid": "dt_span",
                            className: i,
                            children: [h, " ", c && (0, r.JN5)(a)]
                        })]
                    })
                })
            },
            168(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => a
                });
                var s = i(74848);
                i(96540);
                var o = i(17276),
                    r = i(95526);
                let a = e => {
                    let {
                        href: t,
                        is_document: i,
                        is_eu_url: a = !1,
                        children: n = null,
                        ...l
                    } = e;
                    return (0, s.jsx)("a", {
                        href: ((0, o.I8)((0, r.dn)()), (0, o.YG)(t, i, a)),
                        rel: "noopener noreferrer",
                        target: "_blank",
                        ...l,
                        children: n
                    })
                }
            },
            57667(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => s
                });
                let s = i(52217).A
            },
            52217(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => n
                });
                var s = i(96540),
                    o = i(46942),
                    r = i.n(o),
                    a = i(28176);
                let n = e => {
                    let {
                        children: t,
                        size: i = "s",
                        color: o = "general",
                        align: n = "left",
                        weight: l = "normal",
                        lineHeight: c = "m",
                        as: d,
                        className: u,
                        styles: h,
                        ...p
                    } = e, _ = {
                        "--text-size": `var(--text-size-${i})`,
                        "--text-color": `var(--text-${o})`,
                        "--text-lh": `var(--text-lh-${c})`,
                        "--text-weight": `var(--text-weight-${l})`,
                        "--text-align": `var(--text-align-${n})`
                    }, [g, m] = s.useState(_);
                    s.useEffect(() => {
                        (0, a.RIy)(h) ? m(_): m({ ..._,
                            ...h
                        })
                    }, [i, o, c, l, n]);
                    let y = r()("dc-text", u);
                    return s.createElement(d || "span", {
                        className: y,
                        style: g,
                        ...p
                    }, t)
                }
            },
            61944(e, t, i) {
                "use strict";
                i.d(t, {
                    CU: () => s,
                    HL: () => o,
                    rH: () => r
                });
                let s = Object.freeze({
                        WORKSPACE: "Workspace",
                        CHART: "Chart"
                    }),
                    o = Object.freeze({
                        DASHBOARD: 0,
                        BOT_BUILDER: 1,
                        BOTS: 2,
                        SPEED: 3,
                        AUTO: 4,
                        ANALYSIS: 5,
                        DTRADER: 6,
                        MANUAL: 7,
                        SIGNALS: 8,
                        CHART: 9,
                        TUTORIAL: 10,
                        RISK: 11,
                        TRADER: 12
                    }),
                    r = ["id-dbot-dashboard", "id-bot-builder", "id-free-bots", "id-speed", "id-auto-bots", "id-analysis", "id-dtrader", "id-manual", "id-signals", "id-charts", "id-tutorials", "id-risk", "id-trader"]
            },
            47967(e, t, i) {
                "use strict";
                i.d(t, {
                    H: () => s
                });
                let s = Object.freeze({
                    NOT_RUNNING: 0,
                    STARTING: 1,
                    RUNNING: 2,
                    PURCHASE_SENT: 3,
                    PURCHASE_RECEIVED: 4,
                    IS_STOPPING: 5,
                    CONTRACT_CLOSED: 6
                })
            },
            85372(e, t, i) {
                "use strict";
                i.d(t, {
                    Fn: () => n,
                    hY: () => a
                });
                var s = i(28176),
                    o = i(95526);
                let r = e => ({ ...{
                            ACCU: {
                                name: (0, o.kg)("Accumulators"),
                                position: "top"
                            },
                            ASIANU: {
                                name: (0, o.kg)("Asian Up"),
                                position: "top"
                            },
                            ASIAND: {
                                name: (0, o.kg)("Asian Down"),
                                position: "bottom"
                            },
                            CALL: {
                                name: e.isHighLow ? (0, o.kg)("Higher") : (0, o.kg)("Rise"),
                                position: "top"
                            },
                            PUT: {
                                name: e.isHighLow ? (0, o.kg)("Lower") : (0, o.kg)("Fall"),
                                position: "bottom"
                            },
                            CALLE: {
                                name: (0, o.kg)("Rise"),
                                position: "top"
                            },
                            PUTE: {
                                name: (0, o.kg)("Fall"),
                                position: "bottom"
                            },
                            CALLSPREAD: {
                                name: (0, o.kg)("Spread Up"),
                                position: "top"
                            },
                            PUTSPREAD: {
                                name: (0, o.kg)("Spread Down"),
                                position: "bottom"
                            },
                            DIGITMATCH: {
                                name: (0, o.kg)("Matches"),
                                position: "top"
                            },
                            DIGITDIFF: {
                                name: (0, o.kg)("Differs"),
                                position: "bottom"
                            },
                            DIGITEVEN: {
                                name: (0, o.kg)("Even"),
                                position: "top"
                            },
                            DIGITODD: {
                                name: (0, o.kg)("Odd"),
                                position: "bottom"
                            },
                            DIGITOVER: {
                                name: (0, o.kg)("Over"),
                                position: "top"
                            },
                            DIGITUNDER: {
                                name: (0, o.kg)("Under"),
                                position: "bottom"
                            },
                            EXPIRYMISS: {
                                name: (0, o.kg)("Ends Outside"),
                                position: "top"
                            },
                            EXPIRYRANGE: {
                                name: (0, o.kg)("Ends Between"),
                                position: "bottom"
                            },
                            LBFLOATCALL: {
                                name: (0, o.kg)("Close-to-Low"),
                                position: "top"
                            },
                            LBFLOATPUT: {
                                name: (0, o.kg)("High-to-Close"),
                                position: "top"
                            },
                            LBHIGHLOW: {
                                name: (0, o.kg)("High-to-Low"),
                                position: "top"
                            },
                            MULTUP: {
                                name: (0, o.kg)("Up"),
                                position: "top"
                            },
                            MULTDOWN: {
                                name: (0, o.kg)("Down"),
                                position: "bottom"
                            },
                            ONETOUCH: {
                                name: (0, o.kg)("Touch"),
                                position: "top"
                            },
                            NOTOUCH: {
                                name: (0, o.kg)("No Touch"),
                                position: "bottom"
                            },
                            RANGE: {
                                name: (0, o.kg)("Stays Between"),
                                position: "top"
                            },
                            UPORDOWN: {
                                name: (0, o.kg)("Goes Outside"),
                                position: "bottom"
                            },
                            RESETCALL: {
                                name: (0, o.kg)("Reset Call"),
                                position: "top"
                            },
                            RESETPUT: {
                                name: (0, o.kg)("Reset Put"),
                                position: "bottom"
                            },
                            RUNHIGH: {
                                name: (0, o.kg)("Only Ups"),
                                position: "top"
                            },
                            RUNLOW: {
                                name: (0, o.kg)("Only Downs"),
                                position: "bottom"
                            },
                            TICKHIGH: {
                                name: (0, o.kg)("High Tick"),
                                position: "top"
                            },
                            TICKLOW: {
                                name: (0, o.kg)("Low Tick"),
                                position: "bottom"
                            }
                        }
                    }),
                    a = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        return r(t)[e] ? r(t)[e.toUpperCase()].name : ""
                    },
                    n = () => ({
                        has_contract_update_stop_loss: {
                            trigger: "contract_update_stop_loss"
                        },
                        has_contract_update_take_profit: {
                            trigger: "contract_update_take_profit"
                        },
                        contract_update_stop_loss: {
                            rules: [
                                ["req", {
                                    condition: e => !e.contract_update_stop_loss,
                                    message: (0, o.kg)("Please enter a stop loss amount.")
                                }],
                                ["custom", {
                                    func: (e, t, i) => {
                                        let o = (0, s.d2P)(i.contract_info);
                                        return !(o < 0 && -e > o)
                                    },
                                    message: (0, o.kg)("Please enter a stop loss amount that's higher than the current potential loss.")
                                }],
                                ["custom", {
                                    func: (e, t, i) => {
                                        var s;
                                        return e < ((null == i || null == (s = i.contract_info) ? void 0 : s.buy_price) || 0) + 1
                                    },
                                    message: (0, o.kg)("Invalid stop loss. Stop loss cannot be more than stake.")
                                }]
                            ]
                        },
                        contract_update_take_profit: {
                            rules: [
                                ["req", {
                                    condition: e => !e.contract_update_take_profit,
                                    message: (0, o.kg)("Please enter a take profit amount.")
                                }],
                                ["custom", {
                                    func: (e, t, i) => {
                                        let o = (0, s.d2P)(i.contract_info);
                                        return !(o > 0 && +e < o)
                                    },
                                    message: (0, o.kg)("Please enter a take profit amount that's higher than the current potential profit.")
                                }]
                            ]
                        }
                    })
            },
            73842(e, t, i) {
                "use strict";
                i.d(t, {
                    C: () => s
                });
                let s = Object.freeze({
                    TAB_LOCAL: "local_tab",
                    TAB_GOOGLE: "google_tab",
                    TAB_RECENT: "recent_tab"
                })
            },
            3673(e, t, i) {
                "use strict";
                i.r(t), i.d(t, {
                    MARTINGALE: () => a,
                    STRATEGY_1_3_2_6: () => d,
                    REVERSE_MARTINGALE: () => c,
                    D_ALEMBERT: () => r,
                    OSCARS_GRIND: () => n,
                    REVERSE_D_ALEMBERT: () => l
                });
                var s = i(24509),
                    o = i(95526);
                let r = () => [{
                        type: "subtitle",
                        content: [(0, o.kg)("Exploring the D’Alembert strategy in Defen Traders")],
                        expanded: !0,
                        no_collapsible: !1
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The D'Alembert strategy involves increasing your stake after a losing trade and reducing it after a successful trade by a predetermined number of units.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Key parameters")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("These are the trade parameters used for D’Alembert strategy in Defen Traders.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Unit:</strong> The number of units that are added in the event of a trade resulting in loss or the number of units removed in the event of a trade resulting in profit. For example, if the unit is set at 2, the stake increases or decreases by two times the initial stake of 1 USD, meaning it changes by 2 USD.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("An example of D’Alembert strategy")]
                    }, {
                        type: "media",
                        src: (0, s.hx)("dalembert.svg"),
                        alt: (0, o.kg)("An example of D’Alembert strategy")
                    }, {
                        type: "text",
                        content: [(0, o.kg)("1. Start with the initial stake. In this example, we’ll use 1 USD."), (0, o.kg)("2. Set your preferred unit. In this example, it is 2 units or 2 USD."), (0, o.kg)("3. If the first trade results in profit, the stake for the following trade will not reduce but remain at the initial stake. The strategy minimally trades at the initial stake of 1 USD. See A1."), (0, o.kg)("4. If the second trade results in a loss, the Defen Traders will automatically increase your stake for the next trade by 2 USD. Defen Traders will continue to add 2 USD to the previous round’s stake after every losing trade. See A2."), (0, o.kg)("5. If the next trades are profitable, the stake for the following trade will be reduced by 2 USD. This can be shown above where the stake of 3 USD is reduced to 1 USD. See A3.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Profit and loss thresholds")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("With Defen Traders, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss thresholds are reached. It's a form of risk management that can potentially enhance returns. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Estimating the lifespan of your trades")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The D’Alembert strategy is less risky than Martingale, but you can still determine how long your funds will last with this strategy before trading. Simply use this formula.")]
                    }, {
                        type: "media",
                        src: (0, s.hx)("dalembert_formula_1.svg"),
                        dark_src: (0, s.hx)("dalembert_formula_dark_1.svg"),
                        alt: (0, o.kg)("D’Alembert formula 1"),
                        className: "formula",
                        styles: {
                            height: "6rem"
                        }
                    }, {
                        type: "text",
                        content: [(0, o.kg)("Where:"), (0, o.kg)("R is the number of rounds a trader can sustain given a specific loss threshold."), (0, o.kg)("B is the loss threshold."), (0, o.kg)("s is the initial stake."), (0, o.kg)("f is the unit increment.")],
                        className: "no-margin"
                    }, {
                        type: "text",
                        content: [(0, o.kg)("For instance, if a trader has a loss threshold (B) of 100 USD, with an initial stake (s) of 1 USD and 2 units of increment (f), the calculation would be as follows:")],
                        className: "top-margin"
                    }, {
                        type: "media",
                        src: (0, s.hx)("dalembert_formula_2.svg"),
                        dark_src: (0, s.hx)("dalembert_formula_dark_2.svg"),
                        alt: (0, o.kg)("D’Alembert formula 2"),
                        className: "formula",
                        styles: {
                            height: "6rem"
                        }
                    }, {
                        type: "text",
                        content: [(0, o.kg)("Number of rounds (R) = 10")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("This means after 10 rounds of consecutive losses, this trader will lose 100 USD. This reaches the loss threshold of 100 USD, stopping the bot.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("This formula helps you plan your trades by considering the amount of money you have and your comfort level with risk. It involves determining your loss threshold and the initial stake you want to trade with. Then, you use this formula to calculate the number of rounds you can trade. This process provides insight into stake sizing and expectations.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Summary")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The D'Alembert system offers more balanced trading through controlled stake progression. With prudent risk management like stake limits, it can be effectively automated in Defen Traders. However, traders should thoroughly assess their risk appetite, test strategies on a demo account to align with their trading style before trading with real money. This allows optimising the approach and striking a balance between potential gains and losses whilst managing risk.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("<strong>Disclaimer:</strong>")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD profit in successful trades.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities.")]
                    }],
                    a = () => [{
                        type: "subtitle",
                        content: [(0, o.kg)("Exploring the Martingale strategy in Defen Traders")],
                        expanded: !0,
                        no_collapsible: !1
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The Martingale strategy involves increasing your stake after each loss to recoup prior losses with a single successful trade."), (0, o.kg)("This article explores the Martingale strategy integrated into Defen Traders, a versatile trading bot designed to trade assets such as forex, commodities, and derived indices. We will delve into the strategy's core parameters, its application, and provide essential takeaways for traders looking to use the bot effectively.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Key parameters")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("These are the trade parameters used in Defen Traders with Martingale strategy.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Multiplier:</strong> The multiplier used to increase your stake if you're losing a trade. The value must be greater than 1.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Maximum stake:</strong> The maximum amount you are willing to pay to enter a single trade. The stake for your next trade will reset to the initial stake if it exceeds this value. This is an optional risk management parameter.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("An example of Martingale strategy")]
                    }, {
                        type: "media",
                        src: (0, s.hx)("martingale.svg"),
                        alt: (0, o.kg)("An example of Martingale strategy")
                    }, {
                        type: "text",
                        content: [(0, o.kg)("1. Start with the initial stake. Let’s say 1 USD."), (0, o.kg)("2. Select your Martingale multiplier. In this example, it is 2."), (0, o.kg)("3. If the first trade ends in a loss, Defen Traders will automatically double your stake for the next trade to 2 USD. Defen Traders will continue to double the stake after every losing trade."), (0, o.kg)("4. If a trade ends in a profit, the stake for the following trade will be reset to the initial stake amount of 1 USD.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The idea is that successful trades may recoup previous losses. However, it is crucial to exercise caution as the risk can quickly increase with this strategy. With Defen Traders, you can minimise your risk by setting a maximum stake. This is an optional risk management feature. Let’s say a maximum stake of 3 USD. If your stake for the next trade is set to exceed 3 USD, your stake will reset to the initial stake of 1 USD. If you didn't set a maximum stake, it would have increased beyond 3 USD.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Profit and loss thresholds")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("With Defen Traders, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss thresholds are reached. It's a form of risk management that can potentially enhance returns. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Estimating the lifespan of your trades")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("If you're about to start trading and haven't established a Maximum Stake as part of your risk management strategy, you can determine how long your funds will last by employing the Martingale strategy. Simply use this formula.")]
                    }, {
                        type: "media",
                        src: (0, s.hx)("martingale_formula_1.svg"),
                        dark_src: (0, s.hx)("martingale_formula_dark_1.svg"),
                        alt: (0, o.kg)("Martingale formula 1"),
                        className: "formula",
                        styles: {
                            height: "6.5rem"
                        }
                    }, {
                        type: "text",
                        content: [(0, o.kg)("Where:"), (0, o.kg)("R is the number of rounds a trader can sustain given a specific loss threshold."), (0, o.kg)("B is the loss threshold."), (0, o.kg)("s is the initial stake."), (0, o.kg)("m is the Martingale multiplier.")],
                        className: "no-margin"
                    }, {
                        type: "text",
                        content: [(0, o.kg)("For instance, if a trader has a loss threshold (B) is 1000 USD, with an initial stake (s) is 1 USD, and the Martingale multiplier (m) is 2, the calculation would be as follows:")],
                        className: "top-margin"
                    }, {
                        type: "media",
                        src: (0, s.hx)("martingale_formula_2.svg"),
                        dark_src: (0, s.hx)("martingale_formula_dark_2.svg"),
                        alt: (0, o.kg)("Martingale formula 2"),
                        className: "formula",
                        styles: {
                            height: "6.5rem"
                        }
                    }, {
                        type: "text",
                        content: [(0, o.kg)("Number of rounds, R ≈ 9.965"), (0, o.kg)("This means that after 10 rounds of consecutive losses, this trader will lose 1023 USD which exceeds the loss threshold of 1000 USD, stopping the bot."), (0, o.kg)("This formula helps you plan your trades by considering the amount of money you have and your comfort level with risk. It involves determining your loss threshold and the initial stake you want to trade with. Then, you use this formula to calculate the number of rounds you can trade. This process provides insight into stake sizing and expectations.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Summary")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The Martingale strategy in trading may offer substantial gains but also comes with significant risks. With your selected strategy, Defen Traders provides automated trading with risk management measures like setting initial stake, stake size, maximum stake, profit threshold and loss threshold. It's crucial for traders to assess their risk tolerance, practice in a demo account, and understand the strategy before trading with real money.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("<strong>Disclaimer:</strong>")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD profit in successful trades.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities.")]
                    }],
                    n = () => [{
                        type: "subtitle",
                        content: [(0, o.kg)("Exploring the Oscar’s Grind strategy in Defen Traders")],
                        expanded: !0,
                        no_collapsible: !1
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The Oscar’s Grind strategy is designed to potentially gain a modest yet steady profit in each trading session. This strategy splits trades into sessions and has three principles.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Key parameters")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("These are the trade parameters used for Oscar’s Grind strategy in Defen Traders.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("An example of Oscar’s Grind strategy")]
                    }, {
                        type: "media",
                        src: (0, s.hx)("oscars_grind.png"),
                        alt: (0, o.kg)("An example of Oscar’s Grind strategy")
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Principle 1: Strategy aims to potentially make one unit of profit per session</strong>")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The table above demonstrates this principle by showing that when a successful trade occurs and meets the target of one unit of potential profit which is 1 USD in this example, the session ends. If trading continues, a new session will begin.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Principle 2: The stake only increases when a loss trade is followed by a successful trade</strong>")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The table illustrates this principle in the second session. After a trade resulting in loss in round 4 followed by a successful trade in round 5, the stake will increase to 2 USD for round 6. This is in line with the strategy's rule of raising the stake only after a loss is followed by a successful trade.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Principle 3: The stake adjusts to the gap size between current loss and the target profit for the session</strong>")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("In round 7, the stake is adjusted downwards from 2 USD to 1 USD, to meet the target profit of 1 USD.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The stake adjustment: target session profit (1 USD) - current session profit (0 USD) = 1 USD")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The second session concludes upon reaching the aim of one unit of potential profit per session, equivalent to 1 USD. If trading continues, a new session will commence again.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Profit and loss thresholds")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("With Defen Traders, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss threshold is reached. This is a form of risk management that can potentially boost successful trades whilst limiting the impact of loss. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Summary")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The Oscar's Grind strategy provides a disciplined approach for incremental gains through systematic stake progression. When integrated into Defen Traders with proper risk management like profit or loss thresholds, it offers traders a potentially powerful automated trading technique. However, traders should first thoroughly assess their risk tolerance and first try trading on a demo account in order to familiarise with the strategy before trading with real funds.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("<strong>Disclaimer:</strong>")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD profit in successful trades.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities.")]
                    }],
                    l = () => [{
                        type: "subtitle",
                        content: [(0, o.kg)("Exploring the Reverse D’Alembert strategy in Defen Traders")],
                        expanded: !0,
                        no_collapsible: !1
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The Reverse D'Alembert strategy involves increasing your stake after a successful trade and reducing it after a losing trade by a predetermined number of units.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Key parameters")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("These are the trade parameters used in Defen Traders with Reverse D’Alembert strategy.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Unit:</strong> The number of units that are added in the event of successful trades or the number of units removed in the event of losing trades. For example, if the unit is set at 2, the stake increases or decreases by two times the initial stake of 1 USD, meaning it changes by 2 USD.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("An example of Reverse D’Alembert strategy")]
                    }, {
                        type: "media",
                        src: (0, s.hx)("reverse_dalembert.svg"),
                        alt: (0, o.kg)("An example of Reverse D’Alembert strategy")
                    }, {
                        type: "text",
                        content: [(0, o.kg)("1. Start with the initial stake. Let’s say 1 USD."), (0, o.kg)("2. Select your unit. In this example, it is 2 units or 2 USD."), (0, o.kg)("3. For trades that result in a profit, the stake for the next trade will be increased by 2 USD. Defen Traders will continue to add 2 USD for every successful trade. See A1."), (0, o.kg)("4. For trades that result in a loss, there are two outcomes.  If it was traded at the initial stake, the next trade will remain at the same amount as the strategy trades minimally at the initial stake, see A2. If it was traded with a higher amount, the stake for the next trade would be reduced by 2 USD, see A3.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Profit and loss thresholds")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("With Defen Traders, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss threshold is reached. This is a form of risk management that can potentially boost successful trades whilst limiting the impact of loss. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Summary")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("Effective trading with the D'Alembert system requires careful consideration of its stake progression and risk management. Traders can automate this approach using Defen Traders, setting profit and loss thresholds to ensure balanced and controlled trading. However, it is crucial for traders to assess their risk appetite, test strategies on a demo account, and align with their own trading style before transitioning to real money trading. This optimization process helps strike a balance between potential gains and losses while managing risk prudently.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("<strong>Disclaimer:</strong>")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD  profit in successful trades.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities.")]
                    }],
                    c = () => [{
                        type: "subtitle",
                        content: [(0, o.kg)("Exploring the Reverse Martingale strategy in Defen Traders")],
                        expanded: !0,
                        no_collapsible: !1
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The Reverse Martingale strategy involves increasing your stake after each successful trade and resets to the initial stake for every losing trade as it aims to secure potential profits from consecutive wins."), (0, o.kg)("This article explores the Reverse Martingale strategy integrated into Defen Traders, a versatile trading bot designed to trade assets such as forex, commodities, and derived indices. We will delve into the strategy's core parameters, its application, and provide essential takeaways for traders looking to use the bot effectively.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Key parameters")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("These are the trade parameters used in Defen Traders with Reverse Martingale strategy.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Multiplier:</strong> The multiplier used to increase your stake if your trade is successful. The value must be greater than 1.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Maximum stake:</strong> The maximum amount you are willing to pay to enter a single trade. The stake for your next trade will reset to the initial stake if it exceeds this value. This is an optional risk management parameter.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("An example of Reverse Martingale strategy")]
                    }, {
                        type: "media",
                        src: (0, s.hx)("reverse_martingale.svg"),
                        alt: (0, o.kg)("An example of Martingale strategy")
                    }, {
                        type: "text",
                        content: [(0, o.kg)("1. Start with the initial stake. Let’s say 1 USD."), (0, o.kg)("2. Select your Martingale multiplier. In this example, it is 2."), (0, o.kg)("3. If the first trade is a successful trade, Defen Traders will automatically double your stake for the next trade to 2 USD. Defen Traders will continue to double the stake after every successful trade."), (0, o.kg)("4. If a trade ends in a loss, the stake for the following trade will be reset to the initial stake amount of 1 USD.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The objective of Martingale strategy is to take advantage of consecutive successful trades and maximise potential profits from them. This strategy is beneficial only if there are consecutive successful trades. Therefore, it is important to set a maximum stake to secure all the potential profits gained from a number of consecutive successful trades, or you could lose all the profits you have accumulated, including your initial stake. For example, if your goal is to maximise profits within 2 consecutive successful trades, you set a maximum stake of 2 USD, given your initial stake is 1 USD. Similarly, if your goal is to maximise profits within 3 consecutive successful trades, you set a maximum stake of 4 USD, given your initial stake is 1 USD.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Profit and loss thresholds")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("With Defen Traders, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss threshold is reached. This is a form of risk management that can potentially boost successful trades whilst limiting the impact of loss. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Summary")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The Reverse Martingale strategy in trading may offer substantial gains but also comes with significant risks. With your selected strategy, Defen Traders provides automated trading with risk management measures like setting initial stake, stake size, maximum stake, profit threshold and loss threshold. It's crucial for traders to assess their risk tolerance, practice in a demo account, and understand the strategy before trading with real money.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("<strong>Disclaimer:</strong>")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD profit in successful trades.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities.")]
                    }],
                    d = () => [{
                        type: "subtitle",
                        content: [(0, o.kg)("Exploring the 1-3-2-6 strategy in Defen Traders")],
                        expanded: !0,
                        no_collapsible: !1
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The 1-3-2-6 strategy aims to maximise potential profits with four consecutive successful trades. One unit is equal to the amount of the initial stake. The stake will adjust from 1 unit to 3 units after the first successful trade, then to 2 units after your second successful trade, and to 6 units after the third successful trade. The stake for the next trade will reset to the initial stake if there is a losing trade or a completion of the trade cycle."), (0, o.kg)("This article explores the strategy integrated into Defen Traders, a versatile trading bot designed to trade assets such as Forex, Commodities, and Derived Indices. We will delve into the strategy's core parameters, its application, and provide essential takeaways for traders looking to use the bot effectively.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Key parameters")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("These are the trade parameters used in Defen Traders with 1-3-2-6 strategy.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Initial stake:</strong> The amount that you are willing to place as a stake to enter a trade. This is the starting point for any changes in stake depending on the dynamic of the strategy being used.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Profit threshold:</strong> The bot will stop trading if your total profit exceeds this amount.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("<strong>Loss threshold:</strong> The bot will stop trading if your total loss exceeds this amount.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("An example of 1-3-2-6 strategy")]
                    }, {
                        type: "media",
                        src: (0, s.hx)("1-3-2-6.svg"),
                        alt: (0, o.kg)("An example of 1-3-2-6 strategy")
                    }, {
                        type: "text",
                        content: [(0, o.kg)("1. Start with the initial stake. Let’s say 1 USD."), (0, o.kg)("2. If the trade is successful, this strategy will automatically adjust your stake to 3 units of your initial stake for the next trade. In this case, the stake adjustment is 3 units and the initial stake is 1 USD, hence the next trade will start at 3 USD."), (0, o.kg)("3. If the second trade is also successful, your stake will adjust to 2 USD or 2 units of the initial stake for the next trade."), (0, o.kg)("4. However, if any trade results in a loss, your stake will reset back to the initial stake of 1 USD for the next trade. The third trade results in a loss hence the stake resets to the initial stake of 1 USD for the next trade."), (0, o.kg)("5. Upon reaching the initial stake, if the next trade still results in a loss, your stake will remain at the initial stake of 1 USD. This strategy will minimally trade at the initial stake. Refer to the fourth and fifth trade."), (0, o.kg)("6. If consecutive successful trades were to happen, the stake would follow a sequence of adjustment from 1 to 3, then 2, and 6 units of initial stake. After 4 consecutive successful trades, it completes one cycle and then the strategy will repeat itself for another cycle. If any trade results in a loss, your stake will reset back to the initial stake for the next trade.")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The 1-3-2-6 strategy is designed to capitalise on consecutive successful trades while minimising losses during losing streaks. The rationale behind this strategy lies in statistical probabilities, with adjustments to stake sizes based on the perceived likelihood of success. There is a higher likelihood of success in the second trade after one successful trade. Hence the stake adjusts to 3 in the second trade. In the third trade, the stake adjusts to 2 units due to a lower probability of a successful trade. If the third trade is also successful, the strategy then allocates all the previous gains (a total of 6 units of initial stake) into the fourth trade with the aim of doubling the potential profits. If the fourth trade results in a positive outcome, the strategy helps achieve a total gain of 12 units. However, it is crucial to exercise caution, as the risk can escalate quickly with this strategy, and any loss in the fourth trade forfeits all previous gains.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Profit and loss thresholds")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("With Defen Traders, traders can set the profit and loss thresholds to secure potential profits and limit potential losses. This means that the trading bot will automatically stop when either the profit or loss threshold is reached. This is a form of risk management that can potentially boost successful trades whilst limiting the impact of loss. For example, if a trader sets the profit threshold at 100 USD and the strategy exceeds 100 USD of profit from all trades, then the bot will stop running.")]
                    }, {
                        type: "subtitle",
                        content: [(0, o.kg)("Summary")]
                    }, {
                        type: "text",
                        content: [(0, o.kg)("The 1-3-2-6 strategy in trading may offer substantial gains but also comes with significant risks. Each stake is independent, and the strategy does not increase your chances of successful trades in the long run. If you encounter a series of losses, the strategy can lead to significant losses. Therefore, it is crucial for traders to assess their risk tolerance, practice in a demo account, utilise profit and loss thresholds, and fully comprehend the strategy before engaging in real-money trading.")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("<strong>Disclaimer:</strong>")]
                    }, {
                        type: "text_italic",
                        content: [(0, o.kg)("Please be aware that while we may use rounded figures for illustration, a stake of a specific amount does not guarantee an exact amount in successful trades. For example, a 1 USD stake does not necessarily equate to a 1 USD profit in successful trades."), (0, o.kg)("Trading inherently involves risks, and actual profits can fluctuate due to various factors, including market volatility and other unforeseen variables. As such, exercise caution and conduct thorough research before engaging in any trading activities.")]
                    }]
            },
            28899(e, t, i) {
                "use strict";
                i.d(t, {
                    b: () => s
                });
                let s = Object.freeze({
                    CONTRACT: "contract",
                    DIVIDER: "divider"
                })
            },
            20332(e, t, i) {
                "use strict";
                i.d(t, {
                    $: () => r
                });
                var s = i(95526);
                let o = ["BTC", "ETH", "LTC", "BCH", "UST"],
                    r = () => ({
                        lists: {
                            PAYOUTTYPE: [
                                [(0, s.kg)("Stake"), "stake"]
                            ],
                            CRYPTO_CURRENCIES: o,
                            DETAILS: [
                                [(0, s.kg)("deal reference id"), "1"],
                                [(0, s.kg)("purchase price"), "2"],
                                [(0, s.kg)("payout"), "3"],
                                [(0, s.kg)("profit"), "4"],
                                [(0, s.kg)("contract type"), "5"],
                                [(0, s.kg)("entry spot time"), "6"],
                                [(0, s.kg)("entry spot price"), "7"],
                                [(0, s.kg)("exit spot time"), "8"],
                                [(0, s.kg)("exit spot price"), "9"],
                                [(0, s.kg)("barrier"), "10"],
                                [(0, s.kg)("result"), "11"]
                            ],
                            CHECK_RESULT: [
                                [(0, s.kg)("Win"), "win"],
                                [(0, s.kg)("Loss"), "loss"]
                            ],
                            CHECK_DIRECTION: [
                                [(0, s.kg)("Rise"), "rise"],
                                [(0, s.kg)("Fall"), "fall"],
                                [(0, s.kg)("No Change"), ""]
                            ],
                            BALANCE_TYPE: [
                                [(0, s.kg)("string"), "STR"],
                                [(0, s.kg)("number"), "NUM"]
                            ],
                            NOTIFICATION_TYPE: [
                                [(0, s.kg)("green"), "success"],
                                [(0, s.kg)("blue"), "info"],
                                [(0, s.kg)("yellow"), "warn"],
                                [(0, s.kg)("red"), "error"]
                            ],
                            NOTIFICATION_SOUND: [
                                [(0, s.kg)("Silent"), "silent"],
                                [(0, s.kg)("Announcement"), "announcement"],
                                [(0, s.kg)("Earned money"), "earned-money"],
                                [(0, s.kg)("Job done"), "job-done"],
                                [(0, s.kg)("Error"), "error"],
                                [(0, s.kg)("Severe error"), "severe-error"]
                            ],
                            CURRENCY: ["USD", "EUR", "GBP", "AUD", ...o]
                        },
                        opposites: {
                            ACCUMULATOR: [{
                                ACCU: (0, s.kg)("Buy")
                            }],
                            MULTIPLIER: [{
                                MULTUP: (0, s.kg)("Up")
                            }, {
                                MULTDOWN: (0, s.kg)("Down")
                            }],
                            CALLPUT: [{
                                CALL: (0, s.kg)("Rise")
                            }, {
                                PUT: (0, s.kg)("Fall")
                            }],
                            CALLPUTEQUAL: [{
                                CALLE: (0, s.kg)("Rise Equals")
                            }, {
                                PUTE: (0, s.kg)("Fall Equals")
                            }],
                            HIGHERLOWER: [{
                                CALL: (0, s.kg)("Higher")
                            }, {
                                PUT: (0, s.kg)("Lower")
                            }],
                            TOUCHNOTOUCH: [{
                                ONETOUCH: (0, s.kg)("Touch")
                            }, {
                                NOTOUCH: (0, s.kg)("No Touch")
                            }],
                            ENDSINOUT: [{
                                EXPIRYRANGE: (0, s.kg)("Ends Between")
                            }, {
                                EXPIRYMISS: (0, s.kg)("Ends Outside")
                            }],
                            STAYSINOUT: [{
                                RANGE: (0, s.kg)("Stays Between")
                            }, {
                                UPORDOWN: (0, s.kg)("Goes Outside")
                            }],
                            ASIANS: [{
                                ASIANU: (0, s.kg)("Asian Up")
                            }, {
                                ASIAND: (0, s.kg)("Asian Down")
                            }],
                            MATCHESDIFFERS: [{
                                DIGITMATCH: (0, s.kg)("Matches")
                            }, {
                                DIGITDIFF: (0, s.kg)("Differs")
                            }],
                            EVENODD: [{
                                DIGITEVEN: (0, s.kg)("Even")
                            }, {
                                DIGITODD: (0, s.kg)("Odd")
                            }],
                            OVERUNDER: [{
                                DIGITOVER: (0, s.kg)("Over")
                            }, {
                                DIGITUNDER: (0, s.kg)("Under")
                            }],
                            HIGHLOWTICKS: [{
                                TICKHIGH: (0, s.kg)("High Tick")
                            }, {
                                TICKLOW: (0, s.kg)("Low Tick")
                            }],
                            RESET: [{
                                RESETCALL: (0, s.kg)("Reset Call")
                            }, {
                                RESETPUT: (0, s.kg)("Reset Put")
                            }],
                            RUNS: [{
                                RUNHIGH: (0, s.kg)("Only Ups")
                            }, {
                                RUNLOW: (0, s.kg)("Only Downs")
                            }],
                            CALLPUTSPREAD: [{
                                CALLSPREAD: (0, s.kg)("Call Spread")
                            }, {
                                PUTSPREAD: (0, s.kg)("Put Spread")
                            }]
                        },
                        BARRIER_TYPES: [
                            ["Offset +", "+"],
                            ["Offset -", "-"]
                        ],
                        ohlcFields: [
                            [(0, s.kg)("Open"), "open"],
                            [(0, s.kg)("High"), "high"],
                            [(0, s.kg)("Low"), "low"],
                            [(0, s.kg)("Close"), "close"],
                            [(0, s.kg)("Open Time"), "epoch"]
                        ],
                        candleIntervals: [
                            [(0, s.kg)("Default"), "default"],
                            [(0, s.kg)("1 minute"), "60"],
                            [(0, s.kg)("2 minutes"), "120"],
                            [(0, s.kg)("3 minutes"), "180"],
                            [(0, s.kg)("5 minutes"), "300"],
                            [(0, s.kg)("10 minutes"), "600"],
                            [(0, s.kg)("15 minutes"), "900"],
                            [(0, s.kg)("30 minutes"), "1800"],
                            [(0, s.kg)("1 hour"), "3600"],
                            [(0, s.kg)("2 hours"), "7200"],
                            [(0, s.kg)("4 hours"), "14400"],
                            [(0, s.kg)("8 hours"), "28800"],
                            [(0, s.kg)("1 day"), "86400"]
                        ],
                        mainBlocks: ["trade_definition", "before_purchase", "during_purchase", "after_purchase"],
                        mandatoryMainBlocks: ["trade_definition", "purchase", "before_purchase"],
                        procedureDefinitionBlocks: ["procedures_defnoreturn", "procedures_defreturn"],
                        single_instance_blocks: ["trade_definition", "before_purchase", "during_purchase", "after_purchase"],
                        TRADE_TYPE_TO_CONTRACT_CATEGORY_MAPPING: {
                            callput: ["callput", "higherlower"],
                            asian: ["asians"],
                            digits: ["matchesdiffers", "evenodd", "overunder"]
                        },
                        TRADE_TYPE_CATEGORIES: {
                            multiplier: ["multiplier"],
                            callput: ["callput", "callputequal", "higherlower"],
                            touchnotouch: ["touchnotouch"],
                            inout: ["endsinout", "staysinout"],
                            asian: ["asians"],
                            digits: ["matchesdiffers", "evenodd", "overunder"],
                            reset: ["reset"],
                            callputspread: ["callputspread"],
                            highlowticks: ["highlowticks"],
                            runs: ["runs"],
                            accumulator: ["accumulator"]
                        },
                        TRADE_TYPE_CATEGORY_NAMES: {
                            callput: (0, s.kg)("Up/Down"),
                            touchnotouch: (0, s.kg)("Touch/No Touch"),
                            inout: (0, s.kg)("In/Out"),
                            asian: (0, s.kg)("Asians"),
                            digits: (0, s.kg)("Digits"),
                            reset: (0, s.kg)("Reset Call/Reset Put"),
                            callputspread: (0, s.kg)("Call Spread/Put Spread"),
                            highlowticks: (0, s.kg)("High/Low Ticks"),
                            runs: (0, s.kg)("Only Ups/Only Downs"),
                            multiplier: (0, s.kg)("Multipliers"),
                            accumulator: (0, s.kg)("Accumulators")
                        },
                        BARRIER_CATEGORIES: {
                            euro_atm: ["callput", "callputequal"],
                            euro_non_atm: ["endsinout", "higherlower", "callputspread"],
                            american: ["staysinout", "touchnotouch", "highlowticks", "runs", "multiplier"],
                            non_financial: ["digits", "overunder", "evenodd", "matchesdiffers"],
                            asian: ["asians"],
                            reset: ["reset"],
                            lookback: ["lookback"],
                            accumulator: ["accumulator"]
                        },
                        DEFAULT_DURATION_DROPDOWN_OPTIONS: [
                            [(0, s.kg)("Ticks"), "t"],
                            [(0, s.kg)("Seconds"), "s"],
                            [(0, s.kg)("Minutes"), "m"],
                            [(0, s.kg)("Hours"), "h"],
                            [(0, s.kg)("Days"), "d"]
                        ],
                        BARRIER_LABELS: [(0, s.kg)("High barrier"), (0, s.kg)("Low barrier")],
                        ABSOLUTE_BARRIER_DROPDOWN_OPTION: [
                            [(0, s.kg)("Absolute"), "absolute"]
                        ],
                        NOT_AVAILABLE_DROPDOWN_OPTIONS: [
                            [(0, s.kg)("Not available"), "na"]
                        ],
                        NOT_AVAILABLE_DURATIONS: [{
                            display: (0, s.kg)("Not available"),
                            unit: "na",
                            min: 0
                        }],
                        BARRIER_TRADE_TYPES: ["higherlower", "touchnotouch", "endsinout", "staysinout", "callputspread"],
                        PREDICTION_TRADE_TYPES: ["matchesdiffers", "overunder", "highlowticks"],
                        DIGIT_CATEGORIES: ["digits", "highlowticks"],
                        INDEPEDENT_BLOCKS: ["block_holder", "tick_analysis", "loader", "procedures_defreturn", "procedures_defnoreturn"],
                        bbResult: [
                            [(0, s.kg)("upper"), "1"],
                            [(0, s.kg)("middle"), "0"],
                            [(0, s.kg)("lower"), "2"]
                        ],
                        macdFields: [
                            [(0, s.kg)("Histogram"), "0"],
                            [(0, s.kg)("MACD"), "1"],
                            [(0, s.kg)("Signal"), "2"]
                        ],
                        GOOGLE_DRIVE: {
                            SCOPE: "https://www.googleapis.com/auth/drive.file",
                            DISCOVERY_DOCS: "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"
                        },
                        workspaces: {
                            flyoutWorkspacesStartScale: .7,
                            mainWorkspaceStartScale: .9,
                            previewWorkspaceStartScale: .6,
                            indentWorkspace: {
                                x: 0,
                                y: 60
                            }
                        },
                        strategies: {
                            martingale: {
                                index: 0,
                                label: (0, s.kg)("Martingale"),
                                description: (0, s.kg)("The Martingale Strategy is a classic trading technique that has been used for more than a hundred years, popularised by the French mathematician Paul Pierre Levy in the 18th century.")
                            },
                            dalembert: {
                                index: 1,
                                label: (0, s.kg)("D'Alembert"),
                                description: (0, s.kg)("The concept of the D’Alembert Strategy is said to be similar to the Martingale Strategy where you will increase your contract size after a loss. With the D’Alembert Strategy, you will also decrease your contract size after a successful trade.")
                            },
                            oscars_grind: {
                                index: 2,
                                label: (0, s.kg)("Oscar's Grind"),
                                description: (0, s.kg)("The Oscar's Grind Strategy is a low-risk positive progression strategy that first appeared in 1965. By using this strategy, the size of your contract will increase after successful trades, but remains unchanged after unsuccessful trades.")
                            }
                        },
                        default_file_name: (0, s.kg)("Untitled Bot"),
                        DISABLED_SYMBOLS: ["frxGBPNOK", "frxUSDNOK", "frxUSDNEK", "frxUSDSEK"],
                        DISABLED_SUBMARKETS: ["energy"],
                        QUICK_STRATEGY: {
                            DISABLED: {
                                SYMBOLS: ["1HZ150V", "1HZ250V"],
                                SUBMARKETS: ["crash_index", "non_stable_coin", "step_index"],
                                BARRIER_TRADE_TYPES: ["higherlower", "touchnotouch", "endsinout", "staysinout", "callputspread", "accumulator"],
                                PREDICTION_TRADE_TYPES: ["highlowticks"]
                            },
                            DEFAULT: {
                                symbol: "1HZ100V",
                                tradetype: "callput",
                                durationtype: "t",
                                size: 1,
                                unit: 1,
                                prediction: 0
                            }
                        }
                    })
            },
            28132(e, t, i) {
                "use strict";
                i.d(t, {
                    $W: () => s.$,
                    Uk: () => o.Uk,
                    Yd: () => o.Yd,
                    ep: () => r.e,
                    lA: () => o.lA,
                    wU: () => o.wU
                });
                var s = i(20332),
                    o = i(53734),
                    r = i(75372)
            },
            53734(e, t, i) {
                "use strict";
                i.d(t, {
                    Uk: () => c,
                    Yd: () => s,
                    lA: () => n,
                    wU: () => l
                });
                let s = ["InsufficientBalance", "CustomLimitsReached", "OfferingsValidationError", "InvalidCurrency", "ContractBuyValidationError", "NotDefaultCurrency", "PleaseAuthenticate", "FinancialAssessmentRequired", "PositiveIntegerExpected", "OptionError", "IncorrectPayoutDecimals", "IncorrectStakeDecimals", "NoMFProfessionalClient", "AuthorizationRequired", "InvalidToken", "DailyLossLimitExceeded", "InputValidationFailed", "ClientUnwelcome", "PriceMoved"];
                var o, r, a, n = ((o = {}).ERROR = "error", o.NOTIFY = "notify", o.SUCCESS = "success", o),
                    l = ((r = {}).RECOVERABLE_ERRORS = "recoverable_errors", r.UNRECOVERABLE_ERRORS = "unrecoverable_errors", r),
                    c = ((a = {}).LOAD_BLOCK = "load_block", a.PURCHASE = "purchase", a.SELL = "sell", a.NOT_OFFERED = "not_offered", a.PROFIT = "profit", a.LOST = "lost", a.WELCOME_BACK = "welcome_back", a.WELCOME = "welcome", a)
            },
            75372(e, t, i) {
                "use strict";
                i.d(t, {
                    e: () => s
                });
                let s = Object.freeze({
                    UNSAVED: "unsaved",
                    LOCAL: "local",
                    GOOGLE_DRIVE: "google drive"
                })
            },
            67774(e, t, i) {
                "use strict";
                i.r(t), i.d(t, {
                    save: () => o.UN,
                    importExternal: () => n.JH,
                    TradingTimes: () => a.ew,
                    load: () => o.Hh,
                    observer: () => n.PA,
                    getSavedWorkspaces: () => n.EB,
                    updateWorkspaceName: () => o.Wf,
                    onWorkspaceResize: () => n.Ry,
                    removeExistingWorkspace: () => n.r7,
                    ApiHelpers: () => a.aq,
                    DBot: () => r.A,
                    convertStrategyToIsDbot: () => n.Xz,
                    save_types: () => s.ep,
                    compareXml: () => n.hS,
                    pipe: () => n.Fs,
                    ActiveSymbols: () => a.cJ,
                    NetworkMonitor: () => a.z7,
                    config: () => s.$W,
                    initErrorHandlingListener: () => n.K3,
                    runGroupedEvents: () => o.$d,
                    scrollWorkspace: () => o.xw,
                    ContractsFor: () => a.Zp,
                    handleError: () => n.H4,
                    LogTypes: () => s.Uk,
                    MessageTypes: () => s.lA,
                    createError: () => n.$5,
                    removeErrorHandlingEventListener: () => n.Gi,
                    timeSince: () => n._D,
                    runIrreversibleEvents: () => o.j6,
                    ServerTime: () => a.Fh,
                    trackAndEmitError: () => n.AJ,
                    saveWorkspaceToRecent: () => n.dh,
                    extractBlocksFromXml: () => n.bB,
                    setColors: () => n.hd,
                    ErrorTypes: () => s.wU,
                    getContractTypeName: () => n._l,
                    api_base: () => a.Rk,
                    sortBlockChild: () => n.Yp,
                    unrecoverable_errors: () => s.Yd
                });
                var s = i(28132),
                    o = i(78479),
                    r = i(97019),
                    a = i(67109),
                    n = i(31406)
            },
            2988(e, t, i) {
                "use strict";
                i.d(t, {
                    QY: () => n,
                    XC: () => l,
                    iH: () => a
                });
                var s = i(67109),
                    o = i(69824);
                let r = {
                        amount: void 0,
                        basis: "stake",
                        contract_type: "ACCU",
                        currency: void 0,
                        symbol: void 0,
                        growth_rate: void 0,
                        proposal: 1,
                        subscribe: 1
                    },
                    a = async e => {
                        if (e && !e.is_bot_running) {
                            var t;
                            await (null === s.Rk || void 0 === s.Rk || null == (t = s.Rk.api) ? void 0 : t.send({
                                forget_all: "proposal"
                            })), e.subscription_id_for_accumulators = null, e.is_proposal_requested_for_accumulators = !1, window.Blockly.accumulators_request = {}
                        }
                    },
                    n = e => {
                        var t, i, s;
                        let a = null == e ? void 0 : e.getTopParent(),
                            n = null == a ? void 0 : a.getChildByType("trade_definition_market"),
                            l = null == n ? void 0 : n.getFieldValue("SYMBOL_LIST"),
                            c = o.A.instance.client.currency,
                            d = (null == e ? void 0 : e.getFieldValue("GROWTHRATE_LIST")) || .01,
                            u = (null == e || null == (s = e.childBlocks_) || null == (i = s[0]) || null == (t = i.getField("NUM")) ? void 0 : t.getValue()) || 0,
                            h = { ...r,
                                amount: u,
                                currency: c,
                                symbol: l,
                                growth_rate: d
                            };
                        window.Blockly.accumulators_request = h
                    },
                    l = (e, t) => {
                        let {
                            amount: i,
                            currency: s,
                            symbol: o,
                            growth_rate: a,
                            limit_order: n
                        } = e, {
                            take_profit: l
                        } = n, c = { ...r,
                            amount: i,
                            currency: s,
                            symbol: o,
                            growth_rate: a,
                            subscribe: void 0,
                            limit_order: {
                                take_profit: l
                            }
                        };
                        return null == t ? void 0 : t.send(c).then(e => e.error ? Promise.reject(e.error) : e).catch(e => {
                            throw e
                        })
                    }
            },
            69824(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => l
                });
                var s = i(50467),
                    o = i(27813),
                    r = i(64772);
                class a {
                    constructor() {
                        (0, s._)(this, "handleFileChange", () => {
                            throw Error("handleFileChange has not been implemented.")
                        }), (0, s._)(this, "toggleStrategyModal", () => {
                            throw Error("handleFileChange has not been implemented.")
                        })
                    }
                }
                class n extends a {
                    static setInstance(e) {
                        return this.singleton = new n(e), this.instance
                    }
                    static get instance() {
                        return this.singleton
                    }
                    constructor(e) {
                        super(), this.is_mobile = e.is_mobile || !1, this.is_dark_mode_on = e.is_dark_mode_on || !1, this.client = e.client, this.dashboard = e.dashboard, this.flyout = e.flyout, this.toolbar = e.toolbar, this.toolbox = e.toolbox, this.save_modal = e.save_modal, this.load_modal = e.load_modal, this.setContractUpdateConfig = e.setContractUpdateConfig, this.toggleStrategyModal = e.toggleStrategyModal, this.handleFileChange = e.handleFileChange, this.setLoading = e.setLoading, (0, o.mJ)(() => this.client.loginid, () => r.R.createNewInstance(this.client.loginid))
                    }
                }(0, s._)(n, "singleton", null);
                let l = n
            },
            97019(e, t, i) {
                "use strict";
                let s, o, r;
                i.d(t, {
                    A: () => e$
                });
                var a = i(50467),
                    n = i(28132),
                    l = i(20332),
                    c = i(64772),
                    d = i(29432),
                    u = i(28176);
                let h = function() {
                    let e, t, i;

                    function s(e, t) {
                        return null != t && e instanceof t
                    }
                    try {
                        e = Map
                    } catch (t) {
                        e = function() {}
                    }
                    try {
                        t = Set
                    } catch (e) {
                        t = function() {}
                    }
                    try {
                        i = Promise
                    } catch (e) {
                        i = function() {}
                    }

                    function o(r, n, l, c, d) {
                        "object" == typeof n && (l = n.depth, c = n.prototype, d = n.includeNonEnumerable, n = n.circular);
                        let u = [],
                            h = [],
                            p = "undefined" != typeof Buffer;
                        return void 0 === n && (n = !0), void 0 === l && (l = 1 / 0),
                            function r(l, _) {
                                let g;
                                if (null === l) return null;
                                if (0 === _ || "object" != typeof l) return l;
                                if (s(l, e)) g = new e;
                                else if (s(l, t)) g = new t;
                                else if (s(l, i)) g = new i(function(e, t) {
                                    l.then(function(t) {
                                        e(r(t, _ - 1))
                                    }, function(e) {
                                        t(r(e, _ - 1))
                                    })
                                });
                                else if (o.__isArray(l)) g = [];
                                else if (o.__isRegExp(l)) g = new RegExp(l.source, a(l)), l.lastIndex && (g.lastIndex = l.lastIndex);
                                else if (o.__isDate(l)) g = new Date(l.getTime());
                                else {
                                    if (p && Buffer.isBuffer(l)) return Buffer.from ? g = Buffer.from(l) : (g = new Buffer(l.length), l.copy(g)), g;
                                    s(l, Error) ? g = Object.create(l) : void 0 === c ? g = Object.create(Object.getPrototypeOf(l)) : g = Object.create(c)
                                }
                                if (n) {
                                    let e = u.indexOf(l);
                                    if (-1 != e) return h[e];
                                    u.push(l), h.push(g)
                                }
                                for (var m in s(l, e) && l.forEach(function(e, t) {
                                        let i = r(t, _ - 1),
                                            s = r(e, _ - 1);
                                        g.set(i, s)
                                    }), s(l, t) && l.forEach(function(e) {
                                        let t = r(e, _ - 1);
                                        g.add(t)
                                    }), l) {
                                    if (Object.getOwnPropertyDescriptor(l, m)) {
                                        if (0 > Object.keys(l).indexOf(m)) continue;
                                        g[m] = r(l[m], _ - 1)
                                    }
                                    try {
                                        let e = Object.getOwnPropertyDescriptor(l, m);
                                        if ("undefined" === e.set) continue;
                                        g[m] = r(l[m], _ - 1)
                                    } catch (e) {
                                        if (e instanceof TypeError || e instanceof ReferenceError) continue
                                    }
                                }
                                if (Object.getOwnPropertySymbols) {
                                    let e = Object.getOwnPropertySymbols(l);
                                    for (var m = 0; m < e.length; m++) {
                                        let t = e[m];
                                        var y = Object.getOwnPropertyDescriptor(l, t);
                                        (!y || y.enumerable || d) && (g[t] = r(l[t], _ - 1), Object.defineProperty(g, t, y))
                                    }
                                }
                                if (d) {
                                    let e = Object.getOwnPropertyNames(l);
                                    for (var m = 0; m < e.length; m++) {
                                        let t = e[m];
                                        var y = Object.getOwnPropertyDescriptor(l, t);
                                        y && y.enumerable || (g[t] = r(l[t], _ - 1), Object.defineProperty(g, t, y))
                                    }
                                }
                                return g
                            }(r, l)
                    }

                    function r(e) {
                        return Object.prototype.toString.call(e)
                    }

                    function a(e) {
                        let t = "";
                        return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), t
                    }
                    return o.clonePrototype = function(e) {
                        if (null === e) return null;
                        let t = function() {};
                        return t.prototype = e, new t
                    }, o.__objToStr = r, o.__isDate = function(e) {
                        return "object" == typeof e && "[object Date]" === r(e)
                    }, o.__isArray = function(e) {
                        return "object" == typeof e && "[object Array]" === r(e)
                    }, o.__isRegExp = function(e) {
                        return "object" == typeof e && "[object RegExp]" === r(e)
                    }, o.__getRegExpFlags = a, o
                }();
                var p = i(1628),
                    _ = i.n(p),
                    g = i(53734),
                    m = i(68034),
                    y = i(14644),
                    f = i(27346),
                    b = i(95526),
                    k = i(95388),
                    v = i(85389);
                let w = e => Number.isFinite(e) && e > 0,
                    T = e => w(e) && Number.isInteger(e),
                    S = e => e instanceof Object && ["open", "high", "low", "close"].every(t => w(e[t])) && T(e.epoch),
                    I = e => {
                        if (!S(e)) throw (0, k.$)("CandleExpected", (0, b.kg)("Given candle is not valid"));
                        return e
                    },
                    E = "BEFORE_PURCHASE",
                    x = "DURING_PURCHASE",
                    A = "PROPOSALS_READY",
                    C = "CLEAR_PROPOSALS",
                    R = "PURCHASE_SUCCESSFUL",
                    O = "OPEN_CONTRACT",
                    D = "NEW_TICK",
                    B = e => {
                        let {
                            dispatch: t,
                            getState: i,
                            data: s,
                            scope: o
                        } = e, {
                            scope: r
                        } = i();
                        r === o && t(s)
                    },
                    L = () => ({
                        type: A
                    }),
                    P = e => {
                        let {
                            getState: t
                        } = e, {
                            proposalsReady: i
                        } = t();
                        i && B({ ...e,
                            scope: E
                        }), B({ ...e,
                            scope: E
                        })
                    },
                    N = {
                        scope: "STOP",
                        proposalsReady: !1
                    },
                    j = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : N,
                            t = arguments.length > 1 ? arguments[1] : void 0;
                        switch (t.type) {
                            case "START":
                                return {
                                    scope: E,
                                    proposalsReady: e.proposalsReady
                                };
                            case A:
                                return { ...e,
                                    proposalsReady: !0
                                };
                            case C:
                                return { ...e,
                                    proposalsReady: !1
                                };
                            case R:
                                return {
                                    scope: x,
                                    openContract: !1,
                                    proposalsReady: e.proposalsReady
                                };
                            case O:
                                return {
                                    scope: x,
                                    openContract: !0,
                                    proposalsReady: e.proposalsReady
                                };
                            case "SELL":
                                return {
                                    scope: "STOP",
                                    proposalsReady: e.proposalsReady
                                };
                            case D:
                                return { ...e,
                                    newTick: t.payload
                                };
                            default:
                                return e
                        }
                    };
                var U = i(69824),
                    M = i(71371);
                let H = "",
                    F = e => class extends e {
                        observeBalance() {
                            if (!c.R.api) return;
                            let e = c.R.api.onMessage().subscribe(e => {
                                let {
                                    data: t
                                } = e;
                                if ((null == t ? void 0 : t.msg_type) === "balance" && (null == t ? void 0 : t.balance)) {
                                    let {
                                        balance: {
                                            balance: e,
                                            currency: i
                                        }
                                    } = t;
                                    H = (0, u.McG)(e, i), this.accountInfo && (0, M.pq)({
                                        accountID: this.accountInfo.loginid,
                                        balance: H
                                    })
                                }
                            });
                            c.R.pushSubscription(e)
                        }
                        getBalance(e) {
                            let {
                                client: t
                            } = U.A.instance, i = t && t.balance || 0;
                            return H = (0, u.McG)(i, t.currency, !1), "STR" === e ? H : i
                        }
                    },
                    W = e => class extends e {
                        observeOpenContract() {
                            if (!c.R.api) return;
                            let e = c.R.api.onMessage().subscribe(e => {
                                let {
                                    data: t
                                } = e;
                                if ("proposal_open_contract" === t.msg_type) {
                                    let e = t.proposal_open_contract;
                                    if (!e || !this.expectedContractId(null == e ? void 0 : e.contract_id)) return;
                                    this.setContractFlags(e), this.data.contract = e, (0, M.dz)({
                                        accountID: c.R.account_info.loginid,
                                        ...e
                                    }), this.isSold ? (this.contractId = "", clearTimeout(this.transaction_recovery_timeout), this.updateTotals(e), (0, M.fh)({
                                        id: "contract.sold",
                                        data: e.transaction_ids.sell,
                                        contract: e
                                    }), this.afterPromise && this.afterPromise(), this.store.dispatch((e, t) => B({
                                        dispatch: e,
                                        getState: t,
                                        data: {
                                            type: "SELL"
                                        },
                                        scope: x
                                    }))) : this.store.dispatch((e, t) => {
                                        let {
                                            scope: i
                                        } = t();
                                        i === x && e({
                                            type: O
                                        }), P({
                                            dispatch: e,
                                            getState: t,
                                            data: {
                                                type: O
                                            }
                                        })
                                    })
                                }
                            });
                            c.R.pushSubscription(e)
                        }
                        waitForAfter() {
                            return new Promise(e => {
                                this.afterPromise = e
                            })
                        }
                        setContractFlags(e) {
                            let {
                                is_expired: t,
                                is_valid_to_sell: i,
                                is_sold: s,
                                entry_tick: o
                            } = e;
                            this.isSold = !!s, this.isSellAvailable = !this.isSold && !!i, this.isExpired = !!t, this.hasEntryTick = !!o
                        }
                        expectedContractId(e) {
                            return this.contractId && e === this.contractId
                        }
                        getSellPrice() {
                            let {
                                bid_price: e,
                                buy_price: t,
                                currency: i
                            } = this.data.contract;
                            return (0, u.F0v)(Number(e) - Number(t), i)
                        }
                    },
                    $ = e => class extends e {
                        makeProposals(e) {
                            this.isNewTradeOption(e) && (this.regeneratePurchaseReference(), this.trade_option = e, this.proposal_templates = (0, v.NZ)(e, this.getPurchaseReference()), this.renewProposalsOnPurchase())
                        }
                        selectProposal(e) {
                            let {
                                proposals: t
                            } = this.data;
                            if (0 === t.length) throw Error((0, b.kg)("Proposals are not ready"));
                            let i = t.find(t => {
                                if (t.contract_type === e && t.purchase_reference === this.getPurchaseReference()) {
                                    if (t.error) throw t.error;
                                    return t
                                }
                                return !1
                            });
                            if (!i) throw Error((0, b.kg)("Selected proposal does not exist"));
                            return {
                                id: i.id,
                                askPrice: i.ask_price
                            }
                        }
                        renewProposalsOnPurchase() {
                            this.data.proposals = [], this.store.dispatch({
                                type: C
                            }), this.requestProposals()
                        }
                        requestProposals() {
                            let e = !1;
                            Promise.all(this.proposal_templates.map(t => {
                                (0, v.um)(() => c.R.api.send(t)).catch(t => {
                                    var i;
                                    return (null == t || null == (i = t.error) ? void 0 : i.code) === "ContractBuyValidationError" ? this.data.proposals.push({ ...t.error.echo_req,
                                        ...t.echo_req.passthrough,
                                        error: t
                                    }) : e || (e = !0, this.$scope.observer.emit("Error", t.error)), null
                                })
                            }))
                        }
                        observeProposals() {
                            if (!c.R.api) return;
                            let e = c.R.api.onMessage().subscribe(e => {
                                if ("proposal" === e.data.msg_type) {
                                    let {
                                        passthrough: t,
                                        proposal: i
                                    } = e.data;
                                    i && -1 === this.data.proposals.findIndex(e => e.id === i.id) && (this.data.proposals.push({ ...i,
                                        ...t
                                    }), this.checkProposalReady())
                                }
                            });
                            c.R.pushSubscription(e)
                        }
                        checkProposalReady() {
                            let {
                                proposals: e
                            } = this.data;
                            e.length > 0 && this.proposal_templates && this.proposal_templates.every(t => -1 !== e.findIndex(e => e.purchase_reference === t.passthrough.purchase_reference && e.contract_type === t.contract_type)) && this.startPromise.then(() => this.store.dispatch(L()))
                        }
                        isNewTradeOption(e) {
                            return this.trade_option ? ["amount", "barrierOffset", "basis", "duration", "duration_unit", "prediction", "secondBarrierOffset", "symbol"].some(t => this.trade_option[t] !== e[t]) : (this.trade_option = e, !0)
                        }
                    },
                    X = 0,
                    G = e => class extends e {
                        purchase(e) {
                            if (this.store.getState().scope !== E) return Promise.resolve();
                            let t = t => {
                                let {
                                    buy: i
                                } = t;
                                (0, M.fh)({
                                    id: "contract.purchase_received",
                                    data: i.transaction_id,
                                    buy: i
                                }), this.contractId = i.contract_id, this.store.dispatch((e, t) => P({
                                    dispatch: e,
                                    getState: t,
                                    data: {
                                        type: R
                                    }
                                })), this.is_proposal_subscription_required && this.renewProposalsOnPurchase(), X = 0, (0, M.Rm)(g.Uk.PURCHASE, {
                                    longcode: i.longcode,
                                    transaction_id: i.transaction_id
                                }), (0, M.pq)({
                                    accountID: this.accountInfo.loginid,
                                    totalRuns: this.updateAndReturnTotalRuns(),
                                    transaction_ids: {
                                        buy: i.transaction_id
                                    },
                                    contract_type: e,
                                    buy_price: i.buy_price
                                })
                            };
                            if (this.is_proposal_subscription_required) {
                                let {
                                    id: i,
                                    askPrice: s
                                } = this.selectProposal(e), o = () => c.R.api.send({
                                    buy: i,
                                    price: s
                                });
                                return (this.isSold = !1, (0, M.fh)({
                                    id: "contract.purchase_sent",
                                    data: s
                                }), this.options.timeMachineEnabled) ? (0, v.$)(o, (e, t) => {
                                    "DisconnectError" !== e ? this.renewProposalsOnPurchase() : this.clearProposals();
                                    let i = this.store.subscribe(() => {
                                        let {
                                            scope: e,
                                            proposalsReady: s
                                        } = this.store.getState();
                                        e === E && s && (t().then(() => this.observer.emit("REVERT", "before")), i())
                                    })
                                }, ["PriceMoved", "InvalidContractProposal"], X++).then(t) : (0, v.um)(o).then(t)
                            }
                            let i = (0, v.x9)(e, this.tradeOptions),
                                s = () => c.R.api.send(i);
                            return (this.isSold = !1, (0, M.fh)({
                                id: "contract.purchase_sent",
                                data: this.tradeOptions.amount
                            }), this.options.timeMachineEnabled) ? (0, v.$)(s, (e, t) => {
                                "DisconnectError" === e && this.clearProposals();
                                let i = this.store.subscribe(() => {
                                    let {
                                        scope: e
                                    } = this.store.getState();
                                    e === E && (t().then(() => this.observer.emit("REVERT", "before")), i())
                                })
                            }, ["PriceMoved", "InvalidContractProposal"], X++).then(t) : (0, v.um)(s).then(t)
                        }
                        constructor(...e) {
                            super(...e), (0, a._)(this, "getPurchaseReference", () => s), (0, a._)(this, "regeneratePurchaseReference", () => {
                                s = (0, v.yk)()
                            })
                        }
                    },
                    V = e => class extends e {
                        isSellAtMarketAvailable() {
                            return this.contractId && !this.isSold && this.isSellAvailable && !this.isExpired
                        }
                        sellAtMarket() {
                            if (m.P.emit("bot.sell"), this.store.getState().scope !== x) return Promise.resolve();
                            if (!this.isSellAtMarketAvailable()) return (0, M.Rm)(g.Uk.NOT_OFFERED), Promise.resolve();
                            let e = 1;
                            return new Promise(t => {
                                let i = i => {
                                        if (e = 1, i) {
                                            let {
                                                sold_for: e
                                            } = i.sell;
                                            (0, M.Rm)(g.Uk.SELL, {
                                                sold_for: e
                                            })
                                        }(0, M.fh)("purchase.sold"), this.waitForAfter(), t()
                                    },
                                    s = this.contractId,
                                    o = () => (0, v.um)(() => c.R.api.send({
                                        sell: s,
                                        price: 0
                                    })).then(e => {
                                        (0, v.um)(() => c.R.api.send({
                                            proposal_open_contract: 1,
                                            contract_id: s
                                        })).then(() => e)
                                    }).catch(e => {
                                        let t = e.error;
                                        if ("InvalidOfferings" === t.code) return Promise.resolve();
                                        let i = {
                                            name: t.code,
                                            message: t.message,
                                            msg_type: e.msg_type,
                                            error: { ...t.error
                                            }
                                        };
                                        return "RateLimit" === t.code ? Promise.reject(i) : (0, v.um)(() => c.R.api.send({
                                            proposal_open_contract: 1,
                                            contract_id: s
                                        })).then(e => {
                                            let {
                                                proposal_open_contract: t
                                            } = e;
                                            return t.is_sold ? Promise.resolve({
                                                sell: {
                                                    sold_for: t.sell_price
                                                }
                                            }) : Promise.reject(i)
                                        })
                                    }),
                                    r = ["NoOpenPosition", "InvalidSellContractProposal", "UnrecognisedRequest"];
                                if (!this.options.timeMachineEnabled) return (0, v.um)(o, r).then(e => i(e)).catch(e => e);
                                let a = (e, t) => t().then(() => this.observer.emit("REVERT", "during"));
                                return (0, v.$)(o, a, r, e++).then(e => i(e))
                            })
                        }
                    };
                var q = i(20181),
                    Y = i.n(q);
                let z = e => e && (0 === e.length ? void 0 : e[e.length - 1]),
                    K = e => class extends e {
                        async watchTicks(e) {
                            if (e && this.symbol !== e) {
                                this.symbol = e;
                                let {
                                    ticksService: t
                                } = this.$scope;
                                await t.stopMonitor({
                                    symbol: e,
                                    key: o
                                });
                                let i = e => {
                                    this.is_proposal_subscription_required && this.checkProposalReady();
                                    let {
                                        epoch: t
                                    } = e.slice(-1)[0];
                                    this.store.dispatch({
                                        type: D,
                                        payload: t
                                    })
                                };
                                o = await t.monitor({
                                    symbol: e,
                                    callback: i
                                })
                            }
                        }
                        checkTicksPromiseExists() {
                            return this.$scope.ticksService.ticks_history_promise
                        }
                        getTicks() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                            return new Promise(t => {
                                this.$scope.ticksService.request({
                                    symbol: this.symbol
                                }).then(i => {
                                    t(i.map(t => e ? t.quote.toFixed(this.getPipSize()) : t.quote))
                                })
                            })
                        }
                        getLastTick(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            return new Promise(i => this.$scope.ticksService.request({
                                symbol: this.symbol
                            }).then(s => {
                                let o = e ? z(s) : z(s).quote;
                                !e && t && (o = o.toFixed(this.getPipSize())), i(o)
                            }).catch(e => {
                                "MarketIsClosed" === e.code && (m.P.emit("Error", e), i(e.code))
                            }))
                        }
                        getLastDigit() {
                            return new Promise(e => this.getLastTick(!1, !0).then(t => e((0, v.bJ)(t))))
                        }
                        getLastDigitList() {
                            return new Promise(e => this.getTicks().then(t => e(this.getLastDigitsFromList(t))))
                        }
                        getLastDigitsFromList(e) {
                            return e.map(e => (0, v.bJ)(e.toFixed(this.getPipSize())))
                        }
                        checkDirection(e) {
                            return new Promise(t => this.$scope.ticksService.request({
                                symbol: this.symbol
                            }).then(i => t((0, v.u6)(i) === e)))
                        }
                        getOhlc(e) {
                            let {
                                granularity: t = this.options.candleInterval || 60,
                                field: i
                            } = e || {};
                            return new Promise(e => this.$scope.ticksService.request({
                                symbol: this.symbol,
                                granularity: t
                            }).then(t => e(i ? t.map(e => e[i]) : t)))
                        }
                        getOhlcFromEnd(e) {
                            let {
                                index: t = 1
                            } = e || {}, i = ((e, t) => {
                                if (!T(e)) throw (0, k.$)("PositiveIntegerExpected", t);
                                return e
                            })(Number(t), (0, b.kg)("Index must be a positive integer"));
                            return new Promise(t => this.getOhlc(e).then(e => t(e.slice(-i)[0])))
                        }
                        getPipSize() {
                            return this.$scope.ticksService.pipSizes[this.symbol]
                        }
                        async requestAccumulatorStats() {
                            var e, t, i, s, o, r;
                            let a = this.subscription_id_for_accumulators,
                                n = this.is_proposal_requested_for_accumulators,
                                l = { ...window.Blockly.accumulators_request,
                                    amount: null === this || void 0 === this || null == (e = this.tradeOptions) ? void 0 : e.amount,
                                    basis: null === this || void 0 === this || null == (t = this.tradeOptions) ? void 0 : t.basis,
                                    contract_type: "ACCU",
                                    currency: null === this || void 0 === this || null == (i = this.tradeOptions) ? void 0 : i.currency,
                                    growth_rate: null === this || void 0 === this || null == (s = this.tradeOptions) ? void 0 : s.growth_rate,
                                    proposal: 1,
                                    subscribe: 1,
                                    symbol: null === this || void 0 === this || null == (o = this.tradeOptions) ? void 0 : o.symbol
                                };
                            a || n || (this.is_proposal_requested_for_accumulators = !0, l && await (null === c.R || void 0 === c.R || null == (r = c.R.api) ? void 0 : r.send(l)))
                        }
                        async handleOnMessageForAccumulators() {
                            let e = [];
                            return new Promise(t => {
                                let i = c.R.api.onMessage().subscribe(i => {
                                    let {
                                        data: s
                                    } = i;
                                    if ("proposal" === s.msg_type) try {
                                        this.subscription_id_for_accumulators = s.subscription.id, (e = [...(s.proposal.contract_details.ticks_stayed_in || []).flat().reverse(), ...e]).length > 0 && t(e)
                                    } catch (e) {
                                        m.P.emit("Unexpected message type or no proposal found:", e)
                                    }
                                });
                                c.R.pushSubscription(i)
                            })
                        }
                        async fetchStatsForAccumulators() {
                            try {
                                return Y()(() => this.requestAccumulatorStats(), 300)(), await this.handleOnMessageForAccumulators()
                            } catch (e) {
                                throw m.P.emit("Error in subscription promise:", e), e
                            } finally {
                                var e;
                                await (null === c.R || void 0 === c.R || null == (e = c.R.api) ? void 0 : e.send({
                                    forget_all: "proposal"
                                })), this.is_proposal_requested_for_accumulators = !1, this.subscription_id_for_accumulators = null
                            }
                        }
                        async getCurrentStat() {
                            try {
                                let e = await this.fetchStatsForAccumulators();
                                return null == e ? void 0 : e[0]
                            } catch (e) {
                                m.P.emit("Error fetching current stat:", e)
                            }
                        }
                        async getStatList() {
                            try {
                                let e = await this.fetchStatsForAccumulators();
                                return null == e ? void 0 : e.slice(0, 100)
                            } catch (e) {
                                m.P.emit("Error fetching current stat:", e)
                            }
                        }
                        async getDelayTickValue(e) {
                            return new Promise((t, i) => {
                                try {
                                    let i = [],
                                        s = this.symbol,
                                        o = () => {
                                            this.$scope.ticksService.stopMonitor({
                                                symbol: s,
                                                key: ""
                                            }), t(i), i.length = 0
                                        };
                                    0 >= Number(e) && o(), this.$scope.ticksService.monitor({
                                        symbol: s,
                                        callback: t => {
                                            i.push(t), i.length === e && o()
                                        }
                                    })
                                } catch (e) {
                                    i(Error(`Failed to start tick monitoring: ${e.message}`))
                                }
                            })
                        }
                    },
                    J = {
                        totalProfit: 0,
                        totalWins: 0,
                        totalLosses: 0,
                        totalStake: 0,
                        totalPayout: 0,
                        totalRuns: 0
                    },
                    Q = {},
                    Z = e => class extends e {
                        clearStatistics() {
                            if (this.sessionRuns = 0, this.sessionProfit = 0, !this.accountInfo) return;
                            let {
                                loginid: e
                            } = this.accountInfo;
                            Q[e] = { ...J
                            }
                        }
                        updateTotals(e) {
                            let {
                                sell_price: t,
                                buy_price: i,
                                currency: s
                            } = e, o = (0, u.F0v)(Number(t) - Number(i), s), r = o > 0, a = this.getAccountStat();
                            a.totalWins += +!!r, a.totalLosses += +!r, this.sessionProfit = (0, u.F0v)(Number(this.sessionProfit) + Number(o), s), a.totalProfit = (0, u.F0v)(Number(a.totalProfit) + Number(o), s), a.totalStake = (0, u.F0v)(Number(a.totalStake) + Number(i), s), a.totalPayout = (0, u.F0v)(Number(a.totalPayout) + Number(t), s), (0, M.pq)({
                                profit: o,
                                contract: e,
                                accountID: this.accountInfo.loginid,
                                totalProfit: a.totalProfit,
                                totalWins: a.totalWins,
                                totalLosses: a.totalLosses,
                                totalStake: a.totalStake,
                                totalPayout: a.totalPayout
                            }), (0, M.Rm)(r ? g.Uk.PROFIT : g.Uk.LOST, {
                                currency: s,
                                profit: o
                            })
                        }
                        updateAndReturnTotalRuns() {
                            this.sessionRuns++;
                            let e = this.getAccountStat();
                            return ++e.totalRuns
                        }
                        getTotalRuns() {
                            return this.getAccountStat().totalRuns
                        }
                        getTotalProfit(e, t) {
                            let i = this.getAccountStat();
                            return e && 0 !== i.totalProfit ? (0, u.F0v)(+i.totalProfit, t) : +i.totalProfit
                        }
                        checkLimits(e) {
                            if (!e.limitations) return;
                            let {
                                limitations: {
                                    maxLoss: t,
                                    maxTrades: i
                                }
                            } = e;
                            if (t && i) {
                                if (this.sessionRuns >= i) throw (0, k.$)("CustomLimitsReached", (0, b.kg)("Maximum number of trades reached"));
                                if (this.sessionProfit <= -t) throw (0, k.$)("CustomLimitsReached", (0, b.kg)("Maximum loss amount reached"))
                            }
                        }
                        validateTradeOptions(e) {
                            let t = e.take_profit,
                                i = e.stop_loss;
                            return t && (e.limit_order.take_profit = t), i && (e.limit_order.stop_loss = i), e
                        }
                        getAccountStat() {
                            let {
                                loginid: e
                            } = this.accountInfo;
                            return e in Q || (Q[e] = { ...J
                            }), Q[e]
                        }
                        constructor() {
                            super(), this.sessionRuns = 0, this.sessionProfit = 0, m.P.register("statistics.clear", this.clearStatistics.bind(this))
                        }
                    },
                    ee = e => {
                        let {
                            store: t,
                            stopScope: i,
                            passScope: s,
                            passFlag: o
                        } = e;
                        return t.getState().scope === i ? Promise.resolve(!1) : new Promise(e => {
                            let a = t.subscribe(() => {
                                let n = t.getState();
                                n.newTick !== r && (r = n.newTick, n.scope === s && n[o] && (a(), e(!0)), n.scope === i && (a(), e(!1)))
                            })
                        })
                    };
                class et extends F(G(V(W($(K(Z(class {}))))))) {
                    init() {
                        for (var e = arguments.length, t = Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                        let [s, o] = (e => {
                            let [t, i] = e;
                            if (!t) throw (0, k.$)("LoginError", (0, b.kg)("Please login"));
                            return (e => {
                                let {
                                    symbol: t,
                                    contractTypes: i
                                } = e;
                                if (!t) throw (0, k.$)("OptionError", (0, b.kg)("Underlying market is not selected"));
                                if (!i[0]) throw (0, k.$)("OptionError", (0, b.kg)("Contract type is not selected"))
                            })(i), e
                        })(t), {
                            symbol: r
                        } = o;
                        this.initArgs = t, this.options = o, this.startPromise = this.loginAndGetBalance(s), this.checkTicksPromiseExists() || this.watchTicks(r)
                    }
                    start(e) {
                        if (!this.options) throw (0, k.$)("NotInitialized", (0, b.kg)("Bot.init is not called"));
                        m.P.emit("bot.running");
                        let t = this.validateTradeOptions(e);
                        this.tradeOptions = { ...t,
                            symbol: this.options.symbol
                        }, this.store.dispatch((e, t) => B({
                            dispatch: e,
                            getState: t,
                            data: {
                                type: "START"
                            },
                            scope: "STOP"
                        })), this.checkLimits(t), this.makeDirectPurchaseDecision()
                    }
                    loginAndGetBalance(e) {
                        return this.token === e ? Promise.resolve() : (this.accountInfo = c.R.account_info, this.token = c.R.token, new Promise(e => {
                            let t = c.R.api.onMessage().subscribe(t => {
                                let {
                                    data: i
                                } = t;
                                "transaction" === i.msg_type && "sell" === i.transaction.action && (this.transaction_recovery_timeout = setTimeout(() => {
                                    let {
                                        contract: e
                                    } = this.data, t = e.contract_id === i.transaction.contract_id, s = "open" === e.status;
                                    t && s && (0, v.um)(() => {
                                        c.R.api.send({
                                            proposal_open_contract: 1,
                                            contract_id: e.contract_id
                                        })
                                    }, ["PriceMoved"])
                                }, 1500)), e()
                            });
                            c.R.pushSubscription(t)
                        }))
                    }
                    observe() {
                        this.observeOpenContract(), this.observeBalance(), this.observeProposals()
                    }
                    watch(e) {
                        return "before" === e ? ee({
                            store: this.store,
                            stopScope: x,
                            passScope: E,
                            passFlag: "proposalsReady"
                        }) : ee({
                            store: this.store,
                            stopScope: "STOP",
                            passScope: x,
                            passFlag: "openContract"
                        })
                    }
                    makeDirectPurchaseDecision() {
                        let {
                            has_payout_block: e,
                            is_basis_payout: t
                        } = (0, v.vm)();
                        this.is_proposal_subscription_required = e || t, this.is_proposal_subscription_required ? (this.makeProposals({ ...this.options,
                            ...this.tradeOptions
                        }), this.checkProposalReady()) : this.store.dispatch(L())
                    }
                    constructor(e) {
                        super(), this.observer = e.observer, this.$scope = e, this.observe(), this.data = {
                            contract: {},
                            proposals: []
                        }, this.subscription_id_for_accumulators = null, this.is_proposal_requested_for_accumulators = !1, this.store = (0, y.y$)(j, (0, y.Tw)(f.P))
                    }
                }
                let ei = (e, t) => t.data.proposals.find(i => i.contract_type === e && i.purchase_reference === t.getPurchaseReference()),
                    es = (e, t) => e.map(e => t ? e[t] : e),
                    eo = (e, t, i) => es(e.slice(t > e.length ? 0 : e.length - t, e.length), i),
                    er = e => e.reduce((e, t) => e + t, 0) / e.length,
                    ea = (e, t) => {
                        let {
                            periods: i,
                            field: s
                        } = t;
                        if (e.length < i) throw Error("Periods longer than data length");
                        return eo(e, i, s).reduce((e, t) => e + t, 0) / i
                    },
                    en = (e, t) => {
                        let {
                            periods: i,
                            pipSize: s = 2
                        } = t;
                        return (0, u.K2O)(e.length - i + 1).map((o, r) => +ea(e.slice(r, r + i), t).toFixed(s))
                    },
                    el = (e, t) => {
                        let i, {
                                periods: s = 20,
                                field: o,
                                stdDevUp: r = 2,
                                stdDevDown: a = 2,
                                pipSize: n = 2
                            } = t,
                            l = eo(e, s, o),
                            c = ea(l, {
                                periods: s
                            }),
                            d = (i = er(l), Math.sqrt(er(l.map(e => (e - i) ** 2)))),
                            u = c + d * r,
                            h = c - d * a;
                        return [+c.toFixed(n), +u.toFixed(n), +h.toFixed(n)]
                    },
                    ec = (e, t) => {
                        let {
                            periods: i
                        } = t;
                        return (0, u.K2O)(e.length - i + 1).map((s, o) => el(e.slice(o, o + i), t))
                    },
                    ed = (e, t, i) => {
                        let {
                            periods: s,
                            field: o,
                            pipSize: r = 2
                        } = t, a = 2 / (s + 1), n = es(e, o);
                        if (i) return (n[0] - i) * a + i;
                        if (e.length < s) throw Error("Periods longer than data length");
                        let l = er(es(e.slice(0, s), o));
                        return +n.slice(s).reduce((e, t) => (t - e) * a + e, l).toFixed(r)
                    },
                    eu = (e, t) => {
                        let {
                            periods: i
                        } = t, s = ed(e.slice(0, i), t);
                        return e.slice(i - 1).map((e, i) => i ? s = ed([e], t, s) : s)
                    },
                    eh = (e, t) => {
                        let i = [];
                        return i.length = t - e.length, i.fill(0), [...i, ...e]
                    },
                    ep = (e, t) => {
                        let {
                            field: i,
                            fastEmaPeriod: s = 12,
                            slowEmaPeriod: o = 26,
                            signalEmaPeriod: r = 9,
                            pipSize: a = 2
                        } = t, n = es(e, i), l = n.length, c = eh(eu(n, {
                            periods: s,
                            pipSize: 20,
                            field: i
                        }), l), d = eh(eu(n, {
                            periods: o,
                            pipSize: 20,
                            field: i
                        }), l), u = eh(d.map((e, t) => +(c[t] - e).toFixed(a)), l), h = eh(eu(u.slice(o - 1), {
                            periods: r,
                            pipSize: 20,
                            field: i
                        }), l);
                        return u.map((e, t) => [+(e - h[t]).toFixed(a), e, +h[t].toFixed(a)]).slice(o + r - 2)
                    },
                    e_ = (e, t) => t > e ? t - e : 0,
                    eg = (e, t) => t < e ? e - t : 0,
                    em = (e, t, i) => {
                        let s;
                        return e.reduce((e, i, o) => {
                            1 === o && (s = e);
                            let r = t(s, i);
                            return s = i, r + (1 === o ? 0 : e)
                        }) / i
                    },
                    ey = (e, t, i, s) => {
                        let o;
                        return 1 === e.length ? s : e.reduce((e, r, a) => {
                            1 === a && (o = e);
                            let n = t(o, r);
                            return o = r, ((1 === a ? s : e) * (i - 1) + n) / i
                        })
                    },
                    ef = (e, t, i) => {
                        let s, o, r, {
                            periods: a,
                            field: n
                        } = t;
                        if (e.length < a) throw Error("Periods longer than data length");
                        if (e.length === a) return 0;
                        let l = es(e.slice(0, a + 1), n);
                        i && "gain" in i ? (s = es(e.slice(-2), n), o = i.gain, r = i.loss) : (s = es(e.slice(a, e.length), n), o = em(l, e_, a), r = em(l, eg, a));
                        let c = ey(s, e_, a, o),
                            d = ey(s, eg, a, r);
                        return (i && (i.gain = c, i.loss = d), 0 === c) ? 0 : 0 === d ? 100 : 100 - 100 / (1 + c / d)
                    },
                    eb = (e, t) => {
                        let {
                            periods: i,
                            pipSize: s = 2
                        } = t, o = {};
                        return (0, u.K2O)(e.length - i).map((r, a) => +ef(e.slice(0, a + i + 1), t, o).toFixed(s))
                    },
                    ek = function(e, t, i, s) {
                        for (var o = arguments.length, r = Array(o > 4 ? o - 4 : 0), a = 4; a < o; a++) r[a - 4] = arguments[a];
                        return e(t, {
                            pipSize: i.getPipSize(),
                            ...s
                        }, ...r)
                    },
                    ev = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        return new Promise(i => setTimeout(() => {
                            i(), setTimeout(() => e.emit("CONTINUE"), 0)
                        }, 1e3 * t), () => {})
                    },
                    ew = e => {
                        let t = new et(e),
                            {
                                observer: i
                            } = e;
                        return {
                            tradeEngine: t,
                            observer: i,
                            getInterface: () => {
                                let e;
                                return { ...(e = e => (0, v.n3)(t.data.contract)[e], {
                                        init: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.init(...i)
                                        },
                                        start: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.start(...i)
                                        },
                                        stop: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.stop(...i)
                                        },
                                        purchase: e => t.purchase(e),
                                        getAskPrice: e => Number(ei(e, t).ask_price),
                                        getPayout: e => Number(ei(e, t).payout),
                                        getPurchaseReference: () => t.getPurchaseReference(),
                                        isSellAvailable: () => t.isSellAtMarketAvailable(),
                                        sellAtMarket: () => t.sellAtMarket(),
                                        getSellPrice: () => t.getSellPrice(),
                                        isResult: t => e(10) === t,
                                        isTradeAgain: e => m.P.emit("bot.trade_again", e),
                                        readDetails: t => e(t - 1)
                                    }),
                                    dateTimeStringToTimestamp: e => {
                                        let t, i = (0, b.kg)("Invalid date/time: {{ datetime_string }}", {
                                            datetime_string: e
                                        });
                                        if ("string" != typeof e) return i;
                                        let s = e.replace(/[^0-9.:-\s]/g, "").replace(/\s+/g, " ").trim().split(" "),
                                            o = /^[12]\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$/;
                                        if (t = s.length >= 2 ? o.test(s[0]) && /^(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])(:([0-5][0-9])?)?$/.test(s[1]) ? `${s[0]}T${s[1]}` : null : 1 === s.length && o.test(s[0]) ? s[0] : null) {
                                            let e = new Date(t);
                                            if (e instanceof Date && !isNaN(e)) return e.getTime() / 1e3
                                        }
                                        return i
                                    },
                                    getTime: () => parseInt(new Date().getTime() / 1e3),
                                    isCandleBlack: e => I(e) && e.close < e.open,
                                    candleValues: (e, t) => (e => {
                                        if (!(e instanceof Array) || !e.every(e => S(e))) throw (0, k.$)("CandleListExpected", (0, b.kg)("Given candle list is not valid"));
                                        return e
                                    })(e).map(e => e[t]),
                                    candleField: (e, t) => I(e)[t],
                                    notify: e => m.P.emit("ui.log.notify", e),
                                    console: e => {
                                        let {
                                            type: t,
                                            message: i
                                        } = e;
                                        return console[t](i)
                                    },
                                    notifyTelegram: (e, t, i) => {
                                        let s = () => (0, M.me)("warn", (0, b.kg)("The Telegram notification could not be sent"));
                                        fetch(`https://api.telegram.org/bot${e}/sendMessage`, {
                                            method: "POST",
                                            mode: "cors",
                                            headers: {
                                                "Content-Type": "application/json"
                                            },
                                            body: JSON.stringify({
                                                chat_id: t,
                                                text: i
                                            })
                                        }).then(e => {
                                            e.ok || s()
                                        }).catch(s)
                                    },
                                    getTotalRuns: () => t.getTotalRuns(),
                                    getBalance: e => t.getBalance(e),
                                    getTotalProfit: e => t.getTotalProfit(e, t.tradeOptions.currency),
                                    sma: (e, i) => ek(ea, e, t, {
                                        periods: i
                                    }),
                                    smaa: (e, i) => ek(en, e, t, {
                                        periods: i
                                    }),
                                    ema: (e, i) => ek(ed, e, t, {
                                        periods: i
                                    }),
                                    emaa: (e, i) => ek(eu, e, t, {
                                        periods: i
                                    }),
                                    rsi: (e, i) => ek(ef, e, t, {
                                        periods: i
                                    }),
                                    rsia: (e, i) => ek(eb, e, t, {
                                        periods: i
                                    }),
                                    bb: (e, i, s) => ek(el, e, t, i)[s],
                                    bba: (e, i, s) => ek(ec, e, t, i).map(e => e[s]),
                                    macda: (e, i, s) => ek(ep, e, t, i).map(e => e[s]),
                                    highlightBlock: e => {
                                        let t = window.Blockly.derivWorkspace.getBlockById(e);
                                        window.Blockly.BlockSvg.prototype.highlightExecutedBlock = function() {
                                            let e = "block--execution-highlighted";
                                            window.Blockly.utils.dom.hasClass(this.svgGroup_, e) || (window.Blockly.utils.dom.addClass(this.svgGroup_, e), setTimeout(() => {
                                                this.svgGroup_ && window.Blockly.utils.dom.removeClass(this.svgGroup_, e)
                                            }, 1505))
                                        }, t && t.highlightExecutedBlock(t)
                                    },
                                    getTicksInterface: {
                                        getDelayTickValue: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.getDelayTickValue(...i)
                                        },
                                        getCurrentStat: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.getCurrentStat(...i)
                                        },
                                        getStatList: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.getStatList(...i)
                                        },
                                        getLastTick: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.getLastTick(...i)
                                        },
                                        getLastDigit: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.getLastDigit(...i)
                                        },
                                        getTicks: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.getTicks(...i)
                                        },
                                        checkDirection: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.checkDirection(...i)
                                        },
                                        getOhlcFromEnd: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.getOhlcFromEnd(...i)
                                        },
                                        getOhlc: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.getOhlc(...i)
                                        },
                                        getLastDigitList: function() {
                                            for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                            return t.getLastDigitList(...i)
                                        }
                                    },
                                    watch: function() {
                                        for (var e = arguments.length, i = Array(e), s = 0; s < e; s++) i[s] = arguments[s];
                                        return t.watch(...i)
                                    },
                                    sleep: function() {
                                        for (var e = arguments.length, t = Array(e), s = 0; s < e; s++) t[s] = arguments[s];
                                        return ev(i, ...t)
                                    },
                                    alert: function() {
                                        for (var e = arguments.length, t = Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                                        return alert(...t)
                                    },
                                    prompt: function() {
                                        for (var e = arguments.length, t = Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                                        return prompt(...t)
                                    },
                                    console: {
                                        log() {
                                            for (var e = arguments.length, t = Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                                            console.log(new Date().toLocaleTimeString(), ...t)
                                        }
                                    }
                                }
                            }
                        }
                    };
                var eT = i(49568),
                    eS = i(26008);
                let eI = e => ({
                        open: +e.open,
                        high: +e.high,
                        low: +e.low,
                        close: +e.close,
                        epoch: +(e.open_time || e.epoch)
                    }),
                    eE = e => e ? "candles" : "ticks";
                class ex {
                    requestPipSizes() {
                        return this.pipSizes ? Promise.resolve(this.pipSizes) : (this.active_symbols_promise || (this.active_symbols_promise = new Promise(e => {
                            this.pipSizes = c.R.pip_sizes, e(this.pipSizes)
                        })), this.active_symbols_promise)
                    }
                    async request(e) {
                        return new Promise((t, i) => {
                            let {
                                symbol: s,
                                granularity: o
                            } = e, r = eE(o);
                            "ticks" === r && this.ticks.has(s) && t(this.ticks.get(s)), "candles" === r && this.candles.hasIn([s, Number(o)]) && t(this.candles.getIn([s, Number(o)])), this.requestStream({ ...e,
                                style: r
                            }).then(e => {
                                t(e)
                            }).catch(e => {
                                i(e)
                            })
                        })
                    }
                    monitor(e) {
                        return new Promise((t, i) => {
                            let {
                                symbol: s,
                                granularity: o,
                                callback: r
                            } = e, a = eE(o), n = (0, v.yk)();
                            this.request(e).then(() => {
                                "ticks" === a ? (this.tickListeners = this.tickListeners.setIn([s, n], r), m.P.emit("bot.bot_ready"), c.R.toggleRunButton(!1)) : this.ohlcListeners = this.ohlcListeners.setIn([s, Number(o), n], r), t(n)
                            }).catch(e => {
                                m.P.emit("Error", e), this.ticks_history_promise = null, c.R.toggleRunButton(!1), i(e)
                            })
                        })
                    }
                    async stopMonitor(e) {
                        let {
                            symbol: t,
                            granularity: i,
                            key: s
                        } = e, o = eE(i);
                        "ticks" === o && this.tickListeners.hasIn([t, s]) && (this.tickListeners = this.tickListeners.deleteIn([t, s])), "candles" === o && this.ohlcListeners.hasIn([t, Number(i), s]) && (this.ohlcListeners = this.ohlcListeners.deleteIn([t, Number(i), s])), await this.unsubscribeIfEmptyListeners(e)
                    }
                    async unsubscribeIfEmptyListeners(e) {
                        let {
                            symbol: t,
                            granularity: i
                        } = e, s = !1, o = this.tickListeners.get(t);
                        o && !o.size && (this.tickListeners = this.tickListeners.delete(t), this.ticks = this.ticks.delete(t), s = !0);
                        let r = this.ohlcListeners.getIn([t, Number(i)]);
                        r && !r.size && (this.ohlcListeners = this.ohlcListeners.deleteIn([t, Number(i)]), this.candles = this.candles.deleteIn([t, Number(i)]), s = !0), s && await this.unsubscribeAllAndSubscribeListeners(t)
                    }
                    unsubscribeAllAndSubscribeListeners(e) {
                        let t = this.subscriptions.getIn(["ohlc", e]);
                        Promise.all([...t ? Array.from(t.values()) : []].map(e => (0, v.um)(() => c.R.api.forget(e)))), this.subscriptions = new eT.T5
                    }
                    updateTicksAndCallListeners(e, t) {
                        if (this.ticks.get(e) === t) return;
                        this.ticks = this.ticks.set(e, t);
                        let i = this.tickListeners.get(e);
                        i && i.forEach(t => t(this.ticks.get(e)))
                    }
                    updateCandlesAndCallListeners(e, t) {
                        if (this.ticks.getIn(e) === t) return;
                        this.candles = this.candles.setIn(e, t);
                        let i = this.ohlcListeners.getIn(e);
                        i && i.forEach(t => t(this.candles.getIn(e)))
                    }
                    observe() {
                        if (c.R.api) {
                            let e = c.R.api.onMessage().subscribe(e => {
                                let {
                                    data: t
                                } = e;
                                if ("tick" === t.msg_type) {
                                    let {
                                        tick: e
                                    } = t, {
                                        symbol: i,
                                        id: s
                                    } = e;
                                    if (this.ticks.has(i)) {
                                        let t, o;
                                        this.subscriptions = this.subscriptions.setIn(["tick", i], s), this.updateTicksAndCallListeners(i, (t = this.ticks.get(i), o = {
                                            epoch: +e.epoch,
                                            quote: +e.quote
                                        }, z(t).epoch >= o.epoch ? t : [...t.slice(1), o]))
                                    }
                                }
                                if ("ohlc" === t.msg_type) {
                                    let {
                                        ohlc: e
                                    } = t, {
                                        symbol: o,
                                        granularity: r,
                                        id: a
                                    } = e;
                                    if (this.candles.hasIn([o, Number(r)])) {
                                        var i, s;
                                        let t;
                                        this.subscriptions = this.subscriptions.setIn(["ohlc", o, Number(r)], a);
                                        let n = [o, Number(r)];
                                        this.updateCandlesAndCallListeners(n, (i = this.candles.getIn(n), s = eI(e), (t = z(i)).open === s.open && t.high === s.high && t.low === s.low && t.close === s.close && t.epoch === s.epoch || t.epoch > s.epoch ? i : [...t.epoch === s.epoch ? i.slice(0, -1) : i.slice(1), s]))
                                    }
                                }
                            });
                            c.R.pushSubscription(e)
                        }
                    }
                    requestStream(e) {
                        let {
                            style: t
                        } = e, i = JSON.stringify(e);
                        if ("ticks" === t) {
                            var s;
                            return (null == (s = this.ticks_history_promise) ? void 0 : s.stringified_options) !== i && (this.ticks_history_promise = {
                                promise: this.requestPipSizes().then(() => this.requestTicks(e)),
                                stringified_options: i
                            }), this.ticks_history_promise.promise
                        }
                        return "candles" === t ? (this.candles_promise && this.candles_promise.stringified_options === i || (this.candles_promise = {
                            promise: this.requestPipSizes().then(() => this.requestTicks(e)),
                            stringified_options: i
                        }), this.candles_promise.promise) : []
                    }
                    requestTicks(e) {
                        let {
                            symbol: t,
                            granularity: i,
                            style: s
                        } = e, o = {
                            ticks_history: "na" === t ? "R_100" : t,
                            subscribe: 1,
                            end: "latest",
                            count: 1e3,
                            granularity: i ? Number(i) : void 0,
                            style: s
                        };
                        return new Promise((e, r) => {
                            c.R.api || e([]), (0, v.um)(() => c.R.api.send(o), [], c.R).then(o => {
                                if ("ticks" === s) {
                                    let i, s = (i = o.history).times.map((e, t) => ({
                                        epoch: +e,
                                        quote: +i.prices[t]
                                    }));
                                    this.updateTicksAndCallListeners(t, s), e(s)
                                } else {
                                    let s = o.candles.map(e => eI(e));
                                    this.updateCandlesAndCallListeners([t, Number(i)], s), e(s)
                                }
                            }).catch(e => {
                                (null == e ? void 0 : e.code) === "InvalidSymbol" && (0, eS.m_)(), r(e)
                            })
                        })
                    }
                    unsubscribeFromTicksService() {
                        return new Promise((e, t) => {
                            this.forget().then(() => {
                                this.forgetCandleSubscription().then(() => {
                                    e()
                                }).catch(t)
                            }).catch(t), this.ticks_history_promise = null
                        })
                    }
                    constructor() {
                        (0, a._)(this, "forget", () => new Promise((e, t) => {
                            (null === c.R || void 0 === c.R ? void 0 : c.R.api) ? c.R.api.forgetAll("ticks").then(() => {
                                e()
                            }).catch(t): e()
                        })), (0, a._)(this, "forgetCandleSubscription", () => new Promise((e, t) => {
                            (null === c.R || void 0 === c.R ? void 0 : c.R.api) ? c.R.api.forgetAll("candles").then(() => {
                                e()
                            }).catch(t): e()
                        })), this.ticks = new eT.T5, this.candles = new eT.T5, this.tickListeners = new eT.T5, this.ohlcListeners = new eT.T5, this.subscriptions = new eT.T5, this.ticks_history_promise = null, this.active_symbols_promise = null, this.candles_promise = null, this.observe()
                    }
                }
                let eA = () => {
                    let e = new m.A;
                    return {
                        observer: e,
                        ticksService: new ex,
                        stopped: !1
                    }
                };
                _().prototype.takeStateSnapshot = function() {
                    return h(this.stateStack, void 0, void 0, void 0, !0)
                }, _().prototype.restoreStateSnapshot = function(e) {
                    this.stateStack = h(e, void 0, void 0, void 0, !0), this.global = this.stateStack[0].scope.object || this.stateStack[0].scope, this.initFunc_(this, this.global)
                };
                let eC = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                        return !g.Yd.includes(t) && e && e.tradeEngine.options && e.tradeEngine.options.shouldRestartOnError
                    },
                    eR = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                        return !!["SellNotAvailableCustom", "ContractCreationFailure", "InvalidtoBuy"].includes(t) && !!e && !!e.tradeEngine.options
                    },
                    eO = () => {
                        let e, t = eA(),
                            i = ew(t),
                            s = {};

                        function o(e) {
                            s.restoreStateSnapshot(e), s.paused_ = !1, r()
                        }

                        function r() {
                            (t.stopped || !s.run()) && e(s.pseudoToNative(s.value))
                        }

                        function a(e, i) {
                            let s = function() {
                                for (var s = arguments.length, o = Array(s), a = 0; a < s; a++) o[a] = arguments[a];
                                let n = o.pop(),
                                    l = o.slice().reverse(),
                                    c = l.findIndex(e => void 0 !== e);
                                i(...(c < 0 ? [] : l.slice(c).reverse()).map(t => e.pseudoToNative(t))).then(t => {
                                    n(e.nativeToPseudo(t)), r()
                                }).catch(e => {
                                    t.observer.emit("Error", e.error || e)
                                })
                            };
                            return Object.defineProperty(s, "length", {
                                value: 101
                            }), e.createAsyncFunction(s)
                        }

                        function n(e, o) {
                            let r = i.getInterface(),
                                {
                                    getTicksInterface: n,
                                    alert: l,
                                    prompt: c,
                                    sleep: d,
                                    console: u
                                } = r;
                            e.setProperty(o, "console", e.nativeToPseudo(u)), e.setProperty(o, "alert", e.nativeToPseudo(l)), e.setProperty(o, "prompt", e.nativeToPseudo(c)), e.setProperty(o, "getPurchaseReference", e.nativeToPseudo(r.getPurchaseReference));
                            let h = e.nativeToPseudo(r);
                            Object.entries(n).forEach(t => {
                                let [i, s] = t;
                                return e.setProperty(h, i, a(e, s))
                            }), e.setProperty(h, "start", e.nativeToPseudo(function() {
                                for (var s = arguments.length, o = Array(s), a = 0; a < s; a++) o[a] = arguments[a];
                                let {
                                    start: n
                                } = r;
                                eC(i) && (t.startState = e.takeStateSnapshot()), n(...o)
                            })), e.setProperty(h, "purchase", a(e, r.purchase)), e.setProperty(h, "sellAtMarket", a(e, r.sellAtMarket)), e.setProperty(o, "Bot", h), e.setProperty(o, "watch", a(e, e => {
                                var o;
                                let r, {
                                    watch: a
                                } = i.getInterface();
                                if ((r = o = i) && r.tradeEngine.options && o.tradeEngine.options.timeMachineEnabled) {
                                    let i = s.takeStateSnapshot();
                                    "before" === e ? t.beforeState = i : t.duringState = i
                                }
                                return a(e)
                            })), e.setProperty(o, "sleep", a(e, d))
                        }
                        async function l() {
                            return new Promise((e, i) => {
                                try {
                                    t.stopped = !0, t.is_error_triggered = !1, m.P.emit("bot.stop");
                                    let {
                                        ticksService: i
                                    } = t;
                                    c.R.clearSubscriptions(), i.unsubscribeFromTicksService().then(() => {
                                        e()
                                    })
                                } catch (e) {
                                    i(e)
                                }
                            })
                        }
                        return t.observer.register("REVERT", e => o("before" === e ? t.beforeState : t.duringState)), {
                            stop: async function e() {
                                return new Promise((e, s) => {
                                    try {
                                        var o, r, a;
                                        let s = m.P.getState("global_timeouts") ? ? [],
                                            n = Object.keys(s).every(e => s[e].is_cancellable);
                                        !i.tradeEngine.contractId && n ? (c.R.is_stopping = !0, s.forEach(e => clearTimeout(s[e])), l().then(() => {
                                            c.R.is_stopping = !1, e()
                                        })) : !1 === i.tradeEngine.isSold && !t.is_error_triggered && (0, u.M5x)((null == i || null == (a = i.tradeEngine) || null == (r = a.data) || null == (o = r.contract) ? void 0 : o.contract_type) ? ? "") ? m.P.register("contract.status", async t => {
                                            "contract.sold" === t.id && l().then(() => e())
                                        }) : (c.R.is_stopping = !0, l().then(() => {
                                            c.R.is_stopping = !1, e()
                                        }))
                                    } catch (e) {
                                        s(e)
                                    }
                                })
                            },
                            run: function(a) {
                                return new Promise((c, d) => {
                                    let u = r => {
                                        var a;
                                        let n;
                                        if (t.stopped) return;
                                        if ("InvalidToken" === r.code) return void m.P.emit("client.invalid_token");
                                        if (eR(i, null == r ? void 0 : r.code)) {
                                            m.P.emit("ui.log.error", r.message), m.P.emit("bot.click_stop");
                                            return
                                        }
                                        if (t.is_error_triggered = !0, !eC(i, r.code) || !((n = a = i) && n.tradeEngine.options && a.tradeEngine.tradeOptions)) return void d(r);
                                        m.P.emit("Error", r);
                                        let {
                                            initArgs: c,
                                            tradeOptions: h
                                        } = i.tradeEngine;
                                        l(), i = ew(t = eA()), s = {}, e = () => {}, t.observer.register("Error", u), i.tradeEngine.init(...c), i.tradeEngine.start(h), t.startState && (null == s ? void 0 : s.restoreStateSnapshot) instanceof Function && o(t.startState)
                                    };
                                    t.observer.register("Error", u), s = new(_())(a, n), e = c, r()
                                })
                            },
                            terminateSession: l,
                            bot: i,
                            unsubscribeFromTicksService: async function e() {
                                let {
                                    ticksService: e
                                } = t;
                                return new Promise((t, i) => {
                                    try {
                                        e.unsubscribeFromTicksService().then(() => {
                                            t()
                                        })
                                    } catch (e) {
                                        i(e)
                                    }
                                })
                            }
                        }
                    };
                var eD = i(31406),
                    eB = i(55477),
                    eL = i(39571),
                    eP = i(36590),
                    eN = i(2988),
                    ej = i(50986),
                    eU = i(11771);
                let eM = {};
                eM.inherits = function(e, t) {
                    function i() {}
                    i.prototype = t.prototype, e.superClass_ = t.prototype, e.prototype = new i, e.prototype.constructor = e, e.base = function(e, i) {
                        for (var s = arguments.length, o = Array(s > 2 ? s - 2 : 0), r = 2; r < s; r++) o[r - 2] = arguments[r];
                        return t.prototype[i].apply(e, o)
                    }
                }, eM.math = {}, eM.isDef = function(e) {
                    return void 0 !== e
                }, eM.math.Size = function(e, t) {
                    this.width = e, this.height = t
                }, eM.isNumber = function(e) {
                    return /^\s*-?\d+(\.\d+)?\s*$/.test(e)
                }, eM.dom = {}, eM.dom.removeNode = function(e) {
                    let t = e.parentNode;
                    e && t && (null == t ? void 0 : t.contains(e)) && (null == t || t.removeChild(e))
                }, eM.math.Coordinate = function(e, t) {
                    this.x = eM.isDef(e) ? e : 0, this.y = eM.isDef(t) ? t : 0
                }, eM.math.Coordinate.prototype.scale = function(e, t) {
                    return t = eM.isNumber(t) ? t : e, this.x *= e, this.y *= t, this
                }, eM.math.Coordinate.difference = function(e, t) {
                    return new eM.math.Coordinate(e.x - t.x, e.y - t.y)
                }, window.goog = eM;
                let eH = async e => {
                    let t, s = await i.e("850").then(i.t.bind(i, 47369, 23));
                    window.Blockly = s.default, window.Blockly.Colours = {};
                    let o = new window.Blockly.Generator("code"),
                        r = { ...ej,
                            ...o
                        };
                    window.Blockly.JavaScript = r, window.Blockly.Themes.zelos_renderer = window.Blockly.Theme.defineTheme("zelos_renderer", {
                        base: window.Blockly.Themes.Zelos,
                        componentStyles: {}
                    }), ["blockInline"].forEach(e => {
                        window.Blockly.ContextMenuRegistry.registry.getItem(e).preconditionFn = () => "hidden"
                    }), Object.keys(t = {
                        undoWorkspace: (0, b.kg)("Undo"),
                        redoWorkspace: (0, b.kg)("Redo"),
                        cleanWorkspace: (0, b.kg)("Clean up Blocks"),
                        collapseWorkspace: (0, b.kg)("Collapse Blocks"),
                        expandWorkspace: (0, b.kg)("Expand Blocks"),
                        workspaceDelete: (0, b.kg)("Delete All Blocks")
                    }).forEach(e => {
                        window.Blockly.ContextMenuRegistry.registry.getItem(e).displayText = (0, b.kg)(t[e])
                    }), (0, eU.h)(e), await i.e("385").then(i.bind(i, 53880)), await i.e("341").then(i.bind(i, 54116))
                };
                var eF = i(78479);
                class eW {
                    async initWorkspace(e, t, s, o, r) {
                        await eH(r);
                        let a = await (0, eB.EB)();
                        this.interpreter = eO();
                        var n = this;
                        return window.Blockly.Blocks.trade_definition_tradetype.onchange = function(e) {
                            if (!this.workspace || window.Blockly.derivWorkspace.isFlyoutVisible || this.workspace.isDragging()) return;
                            this.enforceLimitations();
                            let {
                                name: t,
                                type: i
                            } = e;
                            if (i === window.Blockly.Events.BLOCK_CHANGE) {
                                let i = "SYMBOL_LIST" === t,
                                    r = "TRADETYPECAT_LIST" === t;
                                if (i || r) {
                                    var s, o;
                                    let {
                                        contracts_for: t
                                    } = (null === d.A || void 0 === d.A ? void 0 : d.A.instance) ? ? {}, a = this.getTopParent().getChildByType("trade_definition_market"), l = a.getFieldValue("MARKET_LIST"), c = a.getFieldValue("SUBMARKET_LIST"), u = a.getFieldValue("SYMBOL_LIST"), h = this.getFieldValue("TRADETYPECAT_LIST"), p = this.getFieldValue("TRADETYPE_LIST");
                                    if ("accumulator" !== p && (0, eN.iH)(n), i) {
                                        if (null == t || null == (s = t.getTradeTypeCategories) || s.call(t, l, c, u).then(t => {
                                                let i = this.getField("TRADETYPECAT_LIST");
                                                i && i.updateOptions(t, {
                                                    default_value: h,
                                                    should_pretend_empty: !0,
                                                    event_group: e.group
                                                })
                                            }), n.symbol = u, !n.is_bot_running && n.interpreter && !this.workspace.options.readOnly && u !== n.interpreter.bot.tradeEngine.symbol) {
                                            let e = document.querySelector("#db-animation__run-button");
                                            e && (e.disabled = !0), n.interpreter.unsubscribeFromTicksService().then(async () => {
                                                var e;
                                                await (null == (e = n.interpreter) ? void 0 : e.bot.tradeEngine.watchTicks(u))
                                            })
                                        }
                                    } else r && e.blockId === this.id && (null == t || null == (o = t.getTradeTypes) || o.call(t, l, c, u, h).then(t => {
                                        this.getField("TRADETYPE_LIST").updateOptions(t, {
                                            default_value: p,
                                            should_pretend_empty: !0,
                                            event_group: e.group
                                        })
                                    }))
                                }
                            }
                        }, new Promise((r, n) => {
                            i.p = e, d.A.setInstance(s), U.A.setInstance(t);
                            let c = window.innerWidth;
                            try {
                                let e = .7,
                                    {
                                        handleFileChange: t
                                    } = U.A.instance;
                                if (c < 1640)
                                    if (o) e = .6;
                                    else {
                                        var u;
                                        e = (null == (u = document.getElementById("scratch_div")) ? void 0 : u.offsetWidth) / c / 1.5
                                    }
                                let i = document.getElementById("scratch_div");
                                if (!i) return;
                                this.workspace = window.Blockly.inject(i, {
                                    media: "assets/media/",
                                    renderer: "zelos",
                                    trashcan: !o,
                                    zoom: {
                                        wheel: !0,
                                        startScale: e
                                    },
                                    scrollbars: !0,
                                    theme: window.Blockly.Themes.zelos_renderer
                                }), this.workspace.RTL = (0, eL.Qq)(), this.workspace.cached_xml = {
                                    main: eP.default
                                }, this.workspace.addChangeListener(this.valueInputLimitationsListener.bind(this)), this.workspace.addChangeListener(e => (0, eF.Kt)(this.workspace, e)), this.workspace.addChangeListener(e => this.workspace.dispatchBlockEventEffects(e)), this.workspace.addChangeListener(e => {
                                    if ("drag" !== e.type || e.isStart || o || (0, eF.ae)(), e.type == window.Blockly.Events.BLOCK_CHANGE) {
                                        let t = this.workspace.getBlockById(e.blockId);
                                        o && t && "collapsed" == e.element && (t.contextMenu = !1)
                                    }
                                }), window.Blockly.derivWorkspace = this.workspace;
                                let s = new window.Blockly.Names("window");
                                s.variableMap = window.Blockly.derivWorkspace.getVariableMap(), window.Blockly.JavaScript.variableDB_ = s, this.addBeforeRunFunction(this.unselectBlocks.bind(this)), this.addBeforeRunFunction(this.disableStrayBlocks.bind(this)), this.addBeforeRunFunction(this.checkForErroredBlocks.bind(this)), this.addBeforeRunFunction(this.checkForRequiredBlocks.bind(this)), this.workspace.current_strategy_id = window.Blockly.utils.idGenerator.genUid(), window.Blockly.derivWorkspace.strategy_to_load = eP.default, window.Blockly.getMainWorkspace().strategy_to_load = eP.default, window.Blockly.getMainWorkspace().RTL = (0, eL.Qq)();
                                let n = (0, l.$)().default_file_name;
                                if (a && a.length) {
                                    let e = a[0];
                                    window.Blockly.derivWorkspace.strategy_to_load = e.xml, window.Blockly.getMainWorkspace().strategy_to_load = e.xml, n = e.name, window.Blockly.derivWorkspace.current_strategy_id = e.id, window.Blockly.getMainWorkspace().current_strategy_id = e.id
                                }
                                let d = `dbot-load${Date.now()}`;
                                window.Blockly.Events.setGroup(d), window.Blockly.Xml.domToWorkspace(window.Blockly.utils.xml.textToDom(window.Blockly.derivWorkspace.strategy_to_load), this.workspace);
                                let {
                                    save_modal: h
                                } = U.A.instance;
                                h.updateBotName(n), this.workspace.cleanUp(0, o ? 60 : 56), this.workspace.clearUndo(), window.dispatchEvent(new Event("resize")), window.addEventListener("dragover", eW.handleDragOver), window.addEventListener("drop", e => eW.handleDropOver(e, t)), i.parentNode.style.overflow = "hidden", r()
                            } catch (e) {
                                throw n(e), e
                            }
                        })
                    }
                    isStrategyUpdated(e, t) {
                        if (t && t.length) {
                            var i;
                            let s = null == (i = t.filter(e => {
                                var t;
                                return (null == e ? void 0 : e.id) === (null == (t = this.workspace) ? void 0 : t.current_strategy_id)
                            })) ? void 0 : i[0];
                            if (null == s ? void 0 : s.xml) {
                                let t = null == s ? void 0 : s.xml,
                                    i = window.Blockly.Xml.domToText(e);
                                if ((0, eD.hS)(t, i)) return !1
                            }
                        }
                        return !0
                    }
                    async saveRecentWorkspace() {
                        var e, t;
                        let i = (null === this || void 0 === this ? void 0 : this.workspace) ? null == (t = Blockly) || null == (e = t.Xml) ? void 0 : e.workspaceToDom(this.workspace) : null;
                        try {
                            let e = await (0, eB.EB)();
                            i && this.isStrategyUpdated(i, e) && await (0, eB.dh)(i, n.ep.UNSAVED)
                        } catch (e) {
                            eD.PA.emit("Error", e), await (0, eB.dh)(i, n.ep.UNSAVED)
                        }
                    }
                    addBeforeRunFunction(e) {
                        this.before_run_funcs.push(e)
                    }
                    shouldRunBot() {
                        return this.before_run_funcs.every(e => !!e())
                    }
                    async initializeInterpreter() {
                        this.interpreter && await this.interpreter.terminateSession(), this.interpreter = eO()
                    }
                    runBot() {
                        if (!c.R.is_stopping) try {
                            c.R.is_stopping = !1;
                            let e = this.generateCode();
                            this.interpreter.bot.tradeEngine.checkTicksPromiseExists() || (this.interpreter = eO()), this.is_bot_running = !0, c.R.setIsRunning(!0), this.interpreter.run(e).catch(e => {
                                eD.PA.emit("Error", e), this.stopBot()
                            })
                        } catch (e) {
                            eD.PA.emit("Error", e), this.interpreter && this.stopBot()
                        }
                    }
                    generateCode() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        return `
            var BinaryBotPrivateInit;
            var BinaryBotPrivateStart;
            var BinaryBotPrivateBeforePurchase; 
            var BinaryBotPrivateDuringPurchase;
            var BinaryBotPrivateAfterPurchase;
            var BinaryBotPrivateLastTickTime;
            var BinaryBotPrivateTickAnalysisList = [];
            var BinaryBotPrivateHasCalledTradeOptions = false;

           
            function recursiveList(list, final_list){
                for(var i=0; i < list.length; i++){
                    if(typeof(list[i]) === 'object'){
                        recursiveList(list[i], final_list);
                    }
                    if(typeof(list[i]) == 'number'){
                        final_list.push(list[i]);   
                                  
                    }
                }
                return final_list;
            }

            function BinaryBotPrivateRun(f, arg) {
                if (f) return f(arg);
                return false;
            }
            function BinaryBotPrivateTickAnalysis() {
                var currentTickTime = Bot.getLastTick(true);
                while (currentTickTime === 'MarketIsClosed') {
                    sleep(5);
                    currentTickTime = Bot.getLastTick(true);
                }
                currentTickTime = currentTickTime.epoch;
                if (currentTickTime === BinaryBotPrivateLastTickTime) {
                    return;
                }
                BinaryBotPrivateLastTickTime = currentTickTime;
                for (var BinaryBotPrivateI = 0; BinaryBotPrivateI < BinaryBotPrivateTickAnalysisList.length; BinaryBotPrivateI++) {
                    BinaryBotPrivateRun(BinaryBotPrivateTickAnalysisList[BinaryBotPrivateI]);
                }
            }
            var BinaryBotPrivateLimitations = ${JSON.stringify(e)};
            ${window.Blockly.JavaScript.javascriptGenerator.workspaceToCode(this.workspace)}
            BinaryBotPrivateRun(BinaryBotPrivateInit);
            while (true) {
                BinaryBotPrivateTickAnalysis();
                BinaryBotPrivateRun(BinaryBotPrivateStart);
                if (!BinaryBotPrivateHasCalledTradeOptions) {
                    sleep(1);
                    continue;
                }
                while (watch('before')) {
                    BinaryBotPrivateTickAnalysis();
                    BinaryBotPrivateRun(BinaryBotPrivateBeforePurchase);
                }
                while (watch('during')) {
                    BinaryBotPrivateTickAnalysis();
                    BinaryBotPrivateRun(BinaryBotPrivateDuringPurchase);
                }
                BinaryBotPrivateTickAnalysis();
                if (!BinaryBotPrivateRun(BinaryBotPrivateAfterPurchase)) {
                    break;
                }
            }
            
            `
                    }
                    async stopBot() {
                        c.R.is_stopping || (c.R.setIsRunning(!1), await this.interpreter.stop(), this.is_bot_running = !1, this.interpreter = null, this.interpreter = eO(), await this.interpreter.bot.tradeEngine.watchTicks(this.symbol), (0, eN.iH)(this))
                    }
                    async terminateBot() {
                        this.interpreter && (await this.interpreter.terminateSession(), this.interpreter = null, this.interpreter = eO(), await this.interpreter.bot.tradeEngine.watchTicks(this.symbol))
                    }
                    unselectBlocks() {
                        return window.Blockly.getSelected() && window.Blockly.getSelected().unselect(), !0
                    }
                    disableStrayBlocks() {
                        return this.workspace.getTopBlocks().forEach(e => {
                            e.isMainBlock() || e.isIndependentBlock() || this.disableBlocksRecursively(e)
                        }), !0
                    }
                    disableBlocksRecursively(e) {
                        var t;
                        e.setDisabled(!0), (null == (t = e.nextConnection) ? void 0 : t.targetConnection) && this.disableBlocksRecursively(e.nextConnection.targetConnection.sourceBlock_)
                    }
                    checkForErroredBlocks() {
                        this.valueInputLimitationsListener({}, !0);
                        let e = this.workspace.getAllBlocks(!0).filter(e => e.is_error_highlighted && !e.disabled).filter((e, t, i) => t === i.findIndex(t => t.error_message === e.error_message));
                        return !e.length || (this.workspace.centerOnBlock(e[0].id), e.forEach(e => {
                            eD.PA.emit("ui.log.error", e.error_message)
                        }), !1)
                    }
                    centerAndHighlightBlock(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            i = this.workspace.getBlockById(e);
                        i && (this.workspace.getAllBlocks().forEach(e => e.setErrorHighlighted(!1)), t && i.blink(), i.setErrorHighlighted(!0), this.workspace.centerOnBlock(i.id))
                    }
                    unHighlightAllBlocks() {
                        var e;
                        null == (e = this.workspace) || e.getAllBlocks().forEach(e => e.setErrorHighlighted(!1))
                    }
                    checkForRequiredBlocks() {
                        return (0, eF.gh)(this.workspace)
                    }
                    valueInputLimitationsListener(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        !t && (!this.workspace || this.workspace.isDragging()) || (window.Blockly.JavaScript.javascriptGenerator.init(this.workspace), t && window.Blockly.hideChaff(!1), this.workspace.getAllBlocks(!0).forEach(i => {
                            if (t || e.type === window.Blockly.Events.BLOCK_DRAG && !e.isStart || e.type === window.Blockly.Events.BLOCK_DELETE || e.type === window.Blockly.Events.BLOCK_CREATE || e.type === window.Blockly.Events.UI && ("click" === e.element || "selected" === e.element) || e.type === window.Blockly.Events.BLOCK_CHANGE && e.blockId === i.id || e.type === window.Blockly.Events.BLOCK_CHANGE && i.inputList.some(t => {
                                    if (t.connection) {
                                        let i = t.connection.targetBlock();
                                        return i && e.blockId === i.id
                                    }
                                    return !1
                                }) || (t => {
                                    if (e.type === window.Blockly.Events.BLOCK_CHANGE && "disabled" === e.element) {
                                        let i = t.getParent();
                                        for (; null !== i;) {
                                            if (i.id === e.blockId) return !0;
                                            i = i.getParent()
                                        }
                                    }
                                    return !1
                                })(i)) {
                                if (i.disabled) {
                                    let e = t => {
                                        t.forEach(t => {
                                            t.setErrorHighlighted(!1), e(t.getChildren())
                                        })
                                    };
                                    e([i]);
                                    return
                                }
                                if (!i.getRequiredValueInputs) return;
                                let e = i.getRequiredValueInputs(),
                                    s = Object.keys(e).some(t => {
                                        let s = window.Blockly.getSelected() === i,
                                            o = i.disabled || i.getInheritedDisabled();
                                        if (s || o) return !1;
                                        if (i.isCollapsed() && i.hasErrorHighlightedDescendant()) return !0;
                                        let r = i.getInput(t);
                                        if (r || i.domToMutation) {
                                            if (r.connection) {
                                                let s = window.Blockly.JavaScript.javascriptGenerator.ORDER_ATOMIC,
                                                    o = window.Blockly.JavaScript.javascriptGenerator.valueToCode(i, t, s),
                                                    r = e[t];
                                                return "function" == typeof r ? !!r(o) : !o
                                            }
                                        } else console.warn("Detected a non-existent required input.", {
                                            input_name: t,
                                            type: i.type
                                        });
                                        return !0
                                    });
                                if (s && i.removeSelect(), i.setErrorHighlighted(s, i.error_message || void 0), t && (i.is_error_highlighted || i.hasErrorHighlightedDescendant())) {
                                    let e = i;
                                    for (; e;) e.setCollapsed(!1), e = e.getParent()
                                }
                            }
                        }))
                    }
                    getStrategySounds() {
                        let e = this.workspace.getAllBlocks().filter(e => "notify" === e.type),
                            t = [];
                        return e.forEach(e => {
                            let i = e.inputList[0].fieldRow[3].value_;
                            "silent" !== i && t.push(i)
                        }), t
                    }
                    static handleDragOver(e) {
                        e.stopPropagation(), e.preventDefault(), e.dataTransfer.dropEffect = "copy"
                    }
                    static handleDropOver(e, t) {
                        let i = document.getElementById("scratch_div"),
                            s = document.getElementById("load-strategy__local-dropzone-area");
                        i.contains(e.target) ? t(e) : s && s.contains(e.target) ? t(e, !1) : (e.stopPropagation(), e.preventDefault(), e.dataTransfer.effectAllowed = "none", e.dataTransfer.dropEffect = "none")
                    }
                    constructor() {
                        (0, a._)(this, "terminateConnection", () => {
                            c.R.terminate()
                        }), this.interpreter = null, this.workspace = null, this.before_run_funcs = [], this.symbol = null, this.is_bot_running = !1
                    }
                }
                let e$ = new eW
            },
            11771(e, t, i) {
                "use strict";
                i.d(t, {
                    h: () => s
                });
                let s = () => {
                    let e;
                    (e = Blockly).Colours.RootBlock = {
                        colour: "#747d29",
                        colourSecondary: "#747d29",
                        colourTertiary: "#6d7278"
                    }, e.Colours.Base = {
                        colour: "#e5e5e5",
                        colourSecondary: "#ffffff",
                        colourTertiary: "#6d7278"
                    }, e.Colours.Special1 = {
                        colour: "#e5e5e5",
                        colourSecondary: "#ffffff",
                        colourTertiary: "#6d7278"
                    }, e.Colours.Special2 = {
                        colour: "#e5e5e5",
                        colourSecondary: "#ffffff",
                        colourTertiary: "#6d7278"
                    }, e.Colours.Special3 = {
                        colour: "#e5e5e5",
                        colourSecondary: "#ffffff",
                        colourTertiary: "#6d7278"
                    }, e.Colours.Special4 = {
                        colour: "#e5e5e5",
                        colourSecondary: "#000000",
                        colourTertiary: "#0e0e0e"
                    }
                }
            },
            95332(e, t, i) {
                "use strict";
                i.d(t, {
                    F: () => n,
                    U: () => a
                });
                var s = i(4213),
                    o = i.n(s),
                    r = i(20332);
                let a = e => {
                        let {
                            data: t,
                            filename: i,
                            type: s
                        } = e, r = new Blob([t], {
                            type: s
                        });
                        o().saveAs(r, i)
                    },
                    n = (e, t) => {
                        let i = (0, r.$)().opposites[t.toUpperCase()];
                        if (!i) return (0, r.$)().NOT_AVAILABLE_DROPDOWN_OPTIONS;
                        let s = i.map(e => Object.entries(e)[0].reverse());
                        return "both" !== e ? s.filter(t => t[1] === e) : s
                    }
            },
            78479(e, t, i) {
                "use strict";
                i.d(t, {
                    j6: () => L,
                    Kt: () => N,
                    O4: () => X,
                    gh: () => O,
                    NZ: () => f,
                    Wf: () => w,
                    kh: () => k,
                    ae: () => v,
                    MN: () => q,
                    At: () => G,
                    xy: () => $,
                    UN: () => T,
                    A$: () => V,
                    PZ: () => j,
                    Hh: () => S,
                    $d: () => B,
                    xw: () => D,
                    I7: () => M,
                    m6: () => P,
                    T2: () => b,
                    Lv: () => x
                });
                var s = i(88332),
                    o = i(71036),
                    r = i(28176),
                    a = i(95526),
                    n = i(20332),
                    l = i(53734),
                    c = i(15647),
                    d = i(55477),
                    u = i(68034),
                    h = i(39571),
                    p = i(29432),
                    _ = i(31406);
                class g {
                    getConversions() {
                        var e = this;
                        let t = (e, t, i, s) => {
                                let o = this.workspace.newBlock(t),
                                    r = Array.from(e.children),
                                    a = r.find(e => "mutation" === e.tagName.toLowerCase());
                                if (a) {
                                    let e = parseInt(a.getAttribute("items")) || 0;
                                    if (e > 0) {
                                        for (let t = 0; t < e; t++) o.onIconClick();
                                        r.filter(e => "value" === e.tagName.toLowerCase()).forEach(e => {
                                            let t = parseInt(e.getAttribute("name").replace(/[^0-9]+/g, ""));
                                            Array.from(e.children).forEach(e => {
                                                let i = this.convertBlockNode(e, o);
                                                o.getBlocksInStatement("STACK").find((e, i) => t === i).getInput(s).connection.connect(i.outputConnection)
                                            });
                                            let i = e.parentNode;
                                            i && e && (null == i ? void 0 : i.contains(e)) && (null == i || i.removeChild(e))
                                        })
                                    }
                                }
                                let n = this.generateUniqueVariable(i),
                                    l = this.workspace.newBlock("variables_get");
                                return l.setFieldValue(n.getId(), "VAR"), o.setFieldValue(n.getId(), "VARIABLE"), {
                                    block_to_attach: l,
                                    statement_blocks: [o]
                                }
                            },
                            i = (e, t, i) => {
                                let s = this.workspace.newBlock(t),
                                    o = {
                                        input_list: [{
                                            old: "INPUT",
                                            new: "INPUT_LIST"
                                        }],
                                        period: [{
                                            old: "PERIOD",
                                            new: "PERIOD"
                                        }],
                                        fast_ema_period: [{
                                            old: "FAST_EMA_PERIOD",
                                            new: "FAST_EMA_PERIOD"
                                        }],
                                        signal_ema_period: [{
                                            old: "SMA_PERIOD",
                                            new: "SIGNAL_EMA_PERIOD"
                                        }, {
                                            old: "SIGNAL_EMA_PERIOD",
                                            new: "SIGNAL_EMA_PERIOD"
                                        }],
                                        slow_ema_period: [{
                                            old: "SLOW_EMA_PERIOD",
                                            new: "SLOW_EMA_PERIOD"
                                        }],
                                        std_dev_multiplier_up: [{
                                            old: "UPMULTIPLIER",
                                            new: "UPMULTIPLIER"
                                        }],
                                        std_dev_multiplier_down: [{
                                            old: "DOWNMULTIPLIER",
                                            new: "DOWNMULTIPLIER"
                                        }]
                                    };
                                switch (t) {
                                    case "bb_statement":
                                    case "bba_statement":
                                        {
                                            let t = s.getField("BBRESULT_LIST");t && t.setValue(this.getFieldValue(e, "BBRESULT_LIST"));
                                            break
                                        }
                                    case "macda_statement":
                                        {
                                            let t = s.getField("MACDFIELDS_LIST");t && t.setValue(this.getFieldValue(e, "MACDFIELDS_LIST"))
                                        }
                                }(s.required_child_blocks || []).forEach(e => {
                                    let t = this.workspace.newBlock(e);
                                    s.getLastConnectionInStatement("STATEMENT").connect(t.previousConnection)
                                }), s.getBlocksInStatement("STATEMENT").forEach(t => {
                                    let i = o[t.type];
                                    i && i.forEach(i => {
                                        let o = e.querySelector(`value[name="${i.old}"]`);
                                        if (o) {
                                            let e = t.getInput(i.new);
                                            Array.from(o.children).forEach(t => {
                                                let i = this.convertBlockNode(t, s);
                                                "shadow" === t.tagName.toLowerCase() && i.setShadow(!0), e.connection.connect(i.outputConnection)
                                            });
                                            let a = null == o ? void 0 : o.parentNode;
                                            if (a && o && (null == a ? void 0 : a.contains(o))) {
                                                var r;
                                                null == o || null == (r = o.parentNode) || r.removeChild(o)
                                            }
                                        }
                                    })
                                });
                                let r = this.generateUniqueVariable(i),
                                    a = this.workspace.newBlock("variables_get");
                                return a.setFieldValue(r.getId(), "VAR"), s.setFieldValue(r.getId(), "VARIABLE"), {
                                    block_to_attach: a,
                                    statement_blocks: [s]
                                }
                            },
                            s = function(t) {
                                let i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                    s = e.workspace.newBlock("trade_definition_tradeoptions");
                                if (i) return !1;
                                let o = Array.from(t.children),
                                    r = 0,
                                    a = !1;
                                return o.filter(e => "value" === e.tagName.toLowerCase()).forEach(e => {
                                    let t = e.getAttribute("name");
                                    "BARRIEROFFSET" === t || "SECONDBARRIEROFFSET" === t ? r++ : "PREDICTION" === t && (a = !0)
                                }), r > 0 && s.createBarrierInputs({
                                    allow_both_types: !0,
                                    values: [1, -1]
                                }), a && s.createPredictionInput([0]), ["DURATIONTYPE_LIST", "CURRENCY_LIST", "BARRIEROFFSETTYPE_LIST", "SECONDBARRIEROFFSETTYPE_LIST"].forEach(i => {
                                    let o = s.getField(i);
                                    o && o.setValue(e.getFieldValue(t, i))
                                }), {
                                    block_to_attach: s
                                }
                            };
                        return {
                            bb: e => i(e, "bb_statement", "bb"),
                            bba: e => i(e, "bba_statement", "bba"),
                            ema: e => i(e, "ema_statement", "ema"),
                            emaa: e => i(e, "emaa_statement", "emaa"),
                            lists_create_with: e => t(e, "lists_create_with", (0, a.kg)("list"), "VALUE"),
                            macda: e => i(e, "macda_statement", "macda"),
                            market: e => (this.has_market_block = !0, s(e)),
                            rsi: e => i(e, "rsi_statement", "rsi"),
                            rsia: e => i(e, "rsia_statement", "rsia"),
                            sma: e => i(e, "sma_statement", "sma"),
                            smaa: e => i(e, "smaa_statement", "smaa"),
                            text_join: e => t(e, "text_join", (0, a.kg)("text"), "TEXT"),
                            trade: e => {
                                let t = this.workspace.newBlock("trade_definition"),
                                    i = {
                                        trade_definition_market: ["MARKET_LIST", "SUBMARKET_LIST", "SYMBOL_LIST"],
                                        trade_definition_tradetype: ["TRADETYPECAT_LIST", "TRADETYPE_LIST"],
                                        trade_definition_contracttype: ["TYPE_LIST"],
                                        trade_definition_candleinterval: ["CANDLEINTERVAL_LIST"],
                                        trade_definition_restartbuysell: ["TIME_MACHINE_ENABLED"],
                                        trade_definition_restartonerror: ["RESTARTONERROR"]
                                    },
                                    s = {};
                                return Object.keys(i).forEach(t => {
                                    let o = this.workspace.newBlock(t);
                                    i[t].forEach(t => {
                                        o.setFieldValue(this.getFieldValue(e, t), t)
                                    }), s[t] = o
                                }), Object.values(s).forEach(e => {
                                    t.getLastConnectionInStatement("TRADE_OPTIONS").connect(e.previousConnection)
                                }), {
                                    block_to_attach: t
                                }
                            },
                            tradeOptions: s
                        }
                    }
                    getIllegalBlocks() {
                        var e;
                        let t = [],
                            {
                                active_symbols: i
                            } = (null === p.A || void 0 === p.A || null == (e = p.A.instance) ? void 0 : e.active_symbols) ? ? {
                                active_symbols: []
                            },
                            {
                                opposites: s
                            } = (0, n.$)();
                        return i.forEach(e => {
                            let i = e.symbol.toLowerCase();
                            t.includes(i) || t.push(i)
                        }), Object.keys(s).forEach(e => t.push(e)), t
                    }
                    createWorkspace() {
                        let e = new window.Blockly.Options({
                                media: "assets/images"
                            }),
                            t = new DocumentFragment;
                        return window.Blockly.createVirtualWorkspace_(t, e, !1, !1)
                    }
                    getFieldValue(e, t) {
                        let i = e.querySelector(`field[name="${t}"]`);
                        return i ? i.textContent : ""
                    }
                    getFirstBlockInStack(e) {
                        let t = e.previousConnection,
                            i = e.getPreviousBlock();
                        if (!t) return e;
                        for (; i && i !== e.getSurroundParent();) t = i.previousConnection, i = i.getPreviousBlock();
                        return t.sourceBlock_
                    }
                    updateRenamedFields(e) {
                        let t = {
                            MARKET_LIST: {
                                volidx: "synthetic_index"
                            },
                            TRADETYPECAT_LIST: {
                                endsinout: "inout",
                                staysinout: "inout",
                                callputequal: "callput"
                            },
                            TRADETYPE_LIST: {
                                risefall: "callput",
                                risefallequals: "callputequal"
                            }
                        };
                        return Object.keys(t).forEach(i => {
                            let s = e.querySelector(`field[name="${i}"]`);
                            if (s) {
                                let e = s.innerText;
                                Object.keys(t[i]).forEach(o => {
                                    e === o && (s.innerText = t[i][o])
                                })
                            }
                        }), e
                    }
                    naivelyFixLegacyStrategyAfterConversion() {
                        var e;
                        let t = null == (e = this.workspace) ? void 0 : e.getTradeDefinitionBlock(),
                            i = (null == t ? void 0 : t.getBlocksInStatement("INITIALIZATION").length) > 0;
                        t && t.getBlocksInStatement("SUBMARKET").forEach(e => {
                            if ("trade_definition_tradeoptions" !== e.type && this.has_market_block && !i) {
                                let i = t.getLastConnectionInStatement("INITIALIZATION");
                                e.unplug(!0), i.connect(e.previousConnection)
                            }
                        })
                    }
                    generateUniqueVariable(e) {
                        let t = e,
                            i = 0;
                        for (; Object.values(this.workspace_variables).includes(t);) t = e + ++i;
                        let s = window.Blockly.Variables.getOrCreateVariablePackage(this.workspace, "", t, "");
                        return this.workspace_variables[s.id_] = t, s
                    }
                    convertStrategy(e, t) {
                        window.Blockly.Events.disable();
                        let i = this.updateRenamedFields(e);
                        if (e.hasAttribute("is_dbot") && "true" === e.getAttribute("is_dbot")) return window.Blockly.Events.enable(), i;
                        if (this.getIllegalBlocks().some(e => {
                                if (!this.exception_blocks.includes(e)) return !!i.querySelector(`block[type="${e}"]`)
                            })) return t && t(), window.Blockly.Events.enable(), window.Blockly.utils.xml.textToDom("<xml />");
                        let s = [],
                            o = [];
                        Array.from(i.children).forEach(e => {
                            switch (e.nodeName.toLowerCase()) {
                                case "block":
                                case "shadow":
                                    o.push(e);
                                    break;
                                case "variables":
                                    s.push(...e.children)
                            }
                        });
                        let r = e => {
                            e.forEach(e => {
                                let t = e.getAttribute("id"),
                                    i = e.textContent;
                                if (!this.workspace_variables[t]) {
                                    let e = window.Blockly.Variables.getOrCreateVariablePackage(this.workspace, t, i, "");
                                    this.workspace_variables[e.id_] = e.name
                                }
                            })
                        };
                        r(s), r(i.querySelectorAll('field[name="VAR"]')), o.forEach(e => this.convertBlockNode(e)), Object.keys(this.blocks_pending_reconnect).forEach(e => {
                            let t = this.workspace.getBlockById(e),
                                i = this.blocks_pending_reconnect[e],
                                s = t.previousConnection;
                            if (s) {
                                let e = s.targetConnection,
                                    o = s;
                                if (i.reverse().forEach(e => {
                                        o.connect(e.nextConnection), o = e.previousConnection
                                    }), e) {
                                    let i = t.previousConnection,
                                        s = t.getPreviousBlock();
                                    for (; s && s !== s.getSurroundParent();) i = s.previousConnection, s = s.getPreviousBlock();
                                    e.connect(i)
                                }
                            }
                        }), this.naivelyFixLegacyStrategyAfterConversion(), this.workspace.getAllBlocks(!0).forEach(e => {
                            e.initSvg(), e.renderEfficiently()
                        }), this.workspace.cleanUp();
                        let a = window.Blockly.Xml.workspaceToDom(this.workspace);
                        return (0, _.Xz)(a), this.workspace = null, window.Blockly.Events.enable(), a
                    }
                    convertBlockNode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                            i = this.getConversions(),
                            s = e.getAttribute("type"),
                            o = Object.keys(i).includes(s),
                            r = null,
                            a = e.getAttribute("collapsed") && "true" === e.getAttribute("collapsed") || !1,
                            n = e.getAttribute("movable") && "false" === e.getAttribute("movable"),
                            l = e.getAttribute("deletable") && "false" === e.getAttribute("deletable"),
                            c = e.getAttribute("disabled") && "true" === e.getAttribute("disabled"),
                            d = e => {
                                e.setCollapsed(a), e.setMovable(!n), e.setDeletable(!l), e.setDisabled(c)
                            };
                        if (o) {
                            let o = i[s](e);
                            o.block_to_attach && d(r = o.block_to_attach), t && o.statement_blocks && o.statement_blocks.forEach(e => {
                                d(e);
                                let i = this.getClosestLegalPreviousConnection(t);
                                if (i) {
                                    let t = i.sourceBlock_;
                                    this.blocks_pending_reconnect[t.id] || (this.blocks_pending_reconnect[t.id] = []), this.blocks_pending_reconnect[t.id].push(e)
                                }
                            })
                        } else if (Object.keys(window.Blockly.Blocks).includes(s) && (d(r = this.workspace.newBlock(s)), r)) {
                            let t = Array.from(e.children).find(e => "mutation" === e.tagName.toLowerCase());
                            t && r.domToMutation && r.domToMutation(t)
                        }
                        return r ? (t && (r.conversion_parent = t), Array.from(e.children).forEach(e => {
                            switch (e.tagName.toLowerCase()) {
                                case "field":
                                    {
                                        let t = e.getAttribute("name"),
                                            i = r.getField(t);
                                        if (i)
                                            if (i instanceof window.Blockly.FieldVariable) {
                                                let t = e.getAttribute("id"),
                                                    s = e.innerText.trim(),
                                                    o = window.Blockly.Variables.getOrCreateVariablePackage(this.workspace, t, s, "");
                                                this.workspace_variables[o.id_] = s, i.setValue(o.id_)
                                            } else i.setValue(e.innerText);
                                        break
                                    }
                                case "value":
                                    this.processValueInputs(r, e);
                                    break;
                                case "statement":
                                    {
                                        let t = e.getAttribute("name");this.processStatementInputs(r, t, e);
                                        break
                                    }
                                case "next":
                                    {
                                        let t = e.closest("statement");
                                        if (t) {
                                            let i = t.getAttribute("name");
                                            this.processStatementInputs(r, i, e, r.conversion_parent)
                                        } else r.nextConnection && Array.from(e.children).forEach(e => {
                                            let t = this.convertBlockNode(e);
                                            r.nextConnection.connect(t.previousConnection)
                                        })
                                    }
                            }
                        }), r) : (console.warn("Unrecognised block found.", s), !1)
                    }
                    processValueInputs(e, t) {
                        let i = t.getAttribute("name"),
                            s = e.getInput(i);
                        if (!s) return console.warn("Unrecognised value input", i), !1;
                        Array.from(t.children).forEach(t => {
                            let i = this.convertBlockNode(t, e);
                            if (!i) return console.warn("Illegal child.", t.getAttribute("type")), !1;
                            "shadow" === t.tagName.toLowerCase() && i.setShadow(!0), s.connection.connect(i.outputConnection)
                        })
                    }
                    processStatementInputs(e, t, i) {
                        let s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                            o = s || e;
                        if (!o.getInput(t)) return console.warn("Unrecognised statement input", t), !1;
                        Array.from(i.children).forEach(e => {
                            let i = this.convertBlockNode(e, o);
                            if (!i) return console.warn("Unrecognised child in statement", e.getAttribute("type")), !1;
                            let s = o.getInput(t);
                            s && i.previousConnection && s.connection.connect(i.previousConnection)
                        })
                    }
                    getClosestLegalPreviousConnection(e) {
                        if ((0, n.$)().procedureDefinitionBlocks.includes(e.type)) {
                            if (0 === e.getBlocksInStatement("STACK").length) {
                                let t = e.getInput("STACK"),
                                    i = this.workspace.newBlock("useless_block");
                                return t.connection.connect(i.previousConnection), i.previousConnection
                            }
                            return e.getInputTargetBlock("STACK").previousConnection
                        }
                        let t = this.getFirstBlockInStack(e),
                            i = this.isConnectedToProtectedStatementInput(t);
                        for (; i;) {
                            let e = t.getParent();
                            e && (t = e, i = this.isConnectedToProtectedStatementInput(t))
                        }
                        return t.previousConnection ? t.previousConnection : !!e.conversion_parent && this.getClosestLegalPreviousConnection(e.conversion_parent)
                    }
                    isConnectedToProtectedStatementInput(e) {
                        let t = this.getFirstBlockInStack(e).previousConnection;
                        if (t) {
                            let e = t.targetConnection;
                            if (e) {
                                let t = e.sourceBlock_,
                                    i = t.getInputWithConnection(e),
                                    s = t.protected_statements || [];
                                if (i && s.includes(i.name)) return !0
                            }
                        }
                        return !1
                    }
                    constructor() {
                        this.blocks_pending_reconnect = {}, this.workspace = this.createWorkspace(), this.workspace_variables = {}, this.has_market_block = !1, this.exception_blocks = ["r_100"]
                    }
                }
                var m = i(69824),
                    y = i(95332);
                let f = {
                        media: "assets/images/",
                        zoom: {
                            wheel: !0,
                            startScale: (0, n.$)().workspaces.previewWorkspaceStartScale
                        },
                        readOnly: !0,
                        scrollbars: !0,
                        renderer: "zelos"
                    },
                    b = e => {
                        if (!window.Blockly) return;
                        let {
                            strategy_id: t,
                            convertedDom: i,
                            file_name: s,
                            from: o
                        } = e;
                        window.Blockly.xmlValues = { ...window.Blockly.xmlValues,
                            strategy_id: t,
                            convertedDom: i,
                            file_name: s,
                            from: o
                        }
                    },
                    k = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.Blockly.derivWorkspace,
                            t = e.getAllBlocks(!0).find(e => "trade_definition_tradetype" === e.type),
                            i = null == t ? void 0 : t.getFieldValue("TRADETYPE_LIST"),
                            s = "trade_definition_tradeoptions";
                        return "multiplier" === i && (s = "trade_definition_multiplier"), "accumulator" === i && (s = "trade_definition_accumulator"), s
                    },
                    v = () => {
                        var e, t, i, s, o, r, a, n, l, d;
                        let h, p, {
                                translate_X: _,
                                translate_Y: g
                            } = ((p = (h = (null == (d = window.Blockly) || null == (l = d.derivWorkspace) || null == (n = l.trashcan) ? void 0 : n.svgGroup.getAttribute("transform")).match(/translate\((-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)\)/)) && h.length > 2 ? {
                                x: parseFloat(h[1]),
                                y: parseFloat(h[2])
                            } : null) || u.P.emit("Error", "Invalid String"), {
                                translate_X: p.x,
                                translate_Y: p.y
                            }),
                            m = null == (e = window.Blockly.getSelected()) ? void 0 : e.getSvgRoot().getBoundingClientRect(),
                            y = (null == m ? void 0 : m.left) || 0,
                            f = (null == m ? void 0 : m.top) || 0,
                            b = [k(), "trade_definition", "purchase", "before_purchase"];
                        (null == b ? void 0 : b.includes(null == (i = window.Blockly) || null == (t = i.getSelected()) ? void 0 : t.type)) && f >= g - 200 && f <= g + 200 && y >= _ - 200 && y <= _ + 200 && u.P.emit("ui.log.error", null === c.c || void 0 === c.c || null == (a = (0, c.c)()) || null == (s = a[null == (r = window.Blockly) || null == (o = r.getSelected()) ? void 0 : o.type]) ? void 0 : s.default)
                    },
                    w = () => {
                        var e, t;
                        if (!(null === m.A || void 0 === m.A ? void 0 : m.A.instance)) return;
                        let {
                            load_modal: i
                        } = m.A.instance, s = (null == i || null == (t = i.dashboard_strategies) || null == (e = t[0]) ? void 0 : e.name) ? ? (0, n.$)().default_file_name;
                        if (document.title.indexOf("-") > -1) {
                            let e = document.title.substr(document.title.indexOf("-")),
                                t = document.title.replace(e, `- ${s}`);
                            document.title = t
                        } else document.title += ` - ${s}`
                    },
                    T = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "@deriv/bot",
                            t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            i = arguments.length > 2 ? arguments[2] : void 0;
                        i.setAttribute("is_dbot", "true"), i.setAttribute("collection", t ? "true" : "false");
                        let s = window.Blockly.Xml.domToPrettyText(i);
                        (0, y.U)({
                            data: s,
                            type: "text/xml;charset=utf-8",
                            filename: `${e}.xml`
                        })
                    },
                    S = async e => {
                        let t, {
                            block_string: i,
                            drop_event: r,
                            file_name: n,
                            strategy_id: c,
                            from: p,
                            workspace: _,
                            showIncompatibleStrategyDialog: y
                        } = e;
                        if (!(null === m.A || void 0 === m.A ? void 0 : m.A.instance) || !_) return;
                        let {
                            setLoading: f,
                            load_modal: k
                        } = m.A.instance, {
                            setOpenButtonDisabled: v,
                            setLoadedLocalFile: w
                        } = k;
                        f(!0), await new Promise(e => setTimeout(e, 100));
                        let T = () => {
                            w(null), (0, s.N)((0, o.UC)().invalid_xml), f(!1);
                            let e = (0, a.kg)("XML file contains unsupported elements. Please check or modify file.");
                            return u.P.emit("ui.log.error", e), {
                                error: e
                            }
                        };
                        try {
                            if (new DOMParser().parseFromString(i, "application/xml").getElementsByTagName("parsererror").length) return T();
                            (0, s.N)((0, o.UC)().BOT_IMPORT)
                        } catch (e) {
                            return T()
                        }
                        try {
                            t = window.Blockly.utils.xml.textToDom(i)
                        } catch (e) {
                            return T()
                        }
                        let S = (t = new g().convertStrategy(t, y)).querySelectorAll("block");
                        if (!S.length || Array.from(S).some(e => {
                                let t = e.getAttribute("type");
                                return !Object.keys(window.Blockly.Blocks).includes(t)
                            })) return T();
                        try {
                            let e = t.hasAttribute("collection") && "true" === t.getAttribute("collection"),
                                i = e ? `load_collection${Date.now()}` : `dbot-load${Date.now()}`;
                            if (window.Blockly.Events.setGroup(i), (0, h.nw)(_, Array.from(S).map(e => e.getAttribute("type"))), b({
                                    strategy_id: c,
                                    convertedDom: t,
                                    file_name: n,
                                    from: p
                                }), e) I(t, r, i, _);
                            else if (await E(t, i, _), _ === window.Blockly.derivWorkspace) {
                                let {
                                    save_modal: e
                                } = m.A.instance;
                                e.updateBotName(n), _.clearUndo(), _.current_strategy_id = c || window.Blockly.utils.idGenerator.genUid(), await (0, d.dh)(t, p)
                            }
                            _.getAllBlocks().forEach(e => {
                                e.disabled && (e.is_user_disabled_state = !0)
                            }), _ === window.Blockly.derivWorkspace && u.P.emit("ui.log.success", {
                                log_type: l.Uk.LOAD_BLOCK
                            })
                        } catch (e) {
                            return console.error(e), T()
                        } finally {
                            f(!1), v(!1)
                        }
                    },
                    I = (e, t, i, s) => {
                        window.Blockly.Events.setGroup(i);
                        let o = window.Blockly.Xml.domToWorkspace(e, s).map(e => s.getBlockById(e));
                        t && 0 !== Object.keys(t).length ? ((e, t, i) => {
                            let {
                                clientX: s = 0,
                                clientY: o = 0
                            } = t || {}, r = i.getMetrics(), a = 1 / i.scale, n = r.absoluteLeft - r.viewLeft, l = document.body.offsetHeight - r.viewHeight - r.viewTop;
                            i.cleanUp(s ? (s - n) * a : 0, o ? (o - l - 76) * a : 0, e)
                        })(o, t, s) : s.cleanUp()
                    },
                    E = async (e, t, i) => {
                        window.Blockly.Events.setGroup(t), await i.asyncClear(), window.Blockly.Xml.clearWorkspaceAndLoadFromXml(e, i), i.cleanUp()
                    },
                    x = e => new Promise((t, i) => {
                        let s = e.getFieldValue("URL"); - 1 === s.indexOf("http") && (s = `http://${s}`);
                        let o = "/" === s.slice(-1)[0];
                        if (!s.match(/[^/]*\.[a-zA-Z]{3}$/) && !o) return i((0, a.kg)("Target must be an XML file"));
                        if (o && (s += "index.xml"), e.isKnownUrl(s)) return e.setDisabled(!0), i((0, a.kg)("This URL is already loaded"));
                        let r = () => i((0, a.kg)("An error occured while trying to load the URL"));
                        fetch(s).then(i => {
                            i.ok ? i.text().then(i => {
                                new Promise((t, s) => {
                                    let o;
                                    try {
                                        o = window.Blockly.utils.xml.textToDom(i)
                                    } catch (e) {
                                        return s((0, a.kg)("Unrecognized file format"))
                                    }
                                    try {
                                        o.hasAttribute("collection") && "true" === o.getAttribute("collection") || s((0, a.kg)("Remote blocks to load must be a collection.")), A(o).then(() => {
                                            Array.from(o.children).forEach(t => C(t, e)), t()
                                        }).catch(() => {
                                            s()
                                        })
                                    } catch (e) {
                                        s((0, a.kg)("Unable to load the block file."))
                                    }
                                }).then(() => t(e)).catch(r)
                            }) : r()
                        }).catch(r)
                    }),
                    A = e => new Promise((t, i) => {
                        let s = [];
                        Array.from(e.children).forEach(e => {
                            if ("loader" === e.getAttribute("type")) {
                                e.remove();
                                let t = window.Blockly.Xml.domToBlock(e, window.Blockly.derivWorkspace);
                                s.push(x(t))
                            }
                        }), s.length ? Promise.all(s).then(t, i) : t([])
                    }),
                    C = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                        if ("variables" === e.tagName.toLowerCase()) return window.Blockly.Xml.domToVariables(e, window.Blockly.derivWorkspace);
                        let i = e.getAttribute("type"),
                            s = new g,
                            o = window.Blockly.Xml.blockToDom(s.convertBlockNode(e));
                        Array.from(o.getElementsByTagName("arg")).forEach(e => {
                            e.hasAttribute("varid") && e.setAttribute("varId", e.getAttribute("varid"))
                        }), (0, h.nw)(window.Blockly.derivWorkspace, i);
                        let r = window.Blockly.Xml.domToBlock(o, window.Blockly.derivWorkspace);
                        return t && t.blocks_added_by_me.push(r), r
                    },
                    R = (e, t) => e.forEach(e => {
                        var i, s, o, r, a, n;
                        if ("misplaced" === t && e) u.P.emit("ui.log.error", null === c.c || void 0 === c.c || null == (s = (0, c.c)()) || null == (i = s[null == e ? void 0 : e.type]) ? void 0 : i[t]);
                        else if ("missing" === t && e) u.P.emit("ui.log.error", null === c.c || void 0 === c.c || null == (r = (0, c.c)()) || null == (o = r[e]) ? void 0 : o[t]);
                        else if ("disabled" === t && e) {
                            let i = !1,
                                s = null === c.c || void 0 === c.c || null == (n = (0, c.c)()) || null == (a = n[e.type]) ? void 0 : a[t];
                            e.disabled && s ? (u.P.emit("ui.log.error", s), i = !0) : !i && e.childBlocks_ && e.childBlocks_.forEach(e => {
                                var i, s;
                                let o = null === c.c || void 0 === c.c || null == (s = (0, c.c)()) || null == (i = s[e.type]) ? void 0 : i[t];
                                o && u.P.emit("ui.log.error", o)
                            })
                        }
                    }),
                    O = e => {
                        let t, i, s;
                        if (!e) return !1;
                        let o = k(e),
                            {
                                mandatoryMainBlocks: r
                            } = (0, n.$)(),
                            a = [o, ...r],
                            l = e.getAllBlocks().filter(e => {
                                if (a.includes(e.type)) return 0 === e.childBlocks_.length && a.includes(e.category_) || null === e.parentBlock_
                            }),
                            c = a.filter(t => !e.getAllBlocks().some(e => e.type === t)),
                            d = (i = [k(t = window.Blockly.derivWorkspace), ...(0, n.$)().mandatoryMainBlocks], s = Object.fromEntries(t.getAllBlocks().filter(e => i.includes(e.type)).map(e => [e.type, e.disabled])), ["before_purchase", "purchase", "trade_definition", "trade_definition_tradeoptions"].some(e => s[e]) ? l.filter(e => {
                                var t;
                                return e.disabled || (null == (t = e.childBlocks_) ? void 0 : t.some(e => e.disabled))
                            }) : []);
                        return c && R(c, "missing"), d && R(d, "disabled"), 0 == [...c, ...d].length
                    },
                    D = (e, t, i, s) => {
                        var o, r, a, n, l, c, d, u, h;
                        let p = e.getMetrics(),
                            _ = p.viewLeft - p.scrollLeft,
                            g = p.viewTop - p.scrollTop,
                            y = g;
                        if (i ? (_ += s ? t : -t, m.A.instance.is_mobile || (y += -20)) : (_ += -20, y += s ? t : -t), e.RTL) {
                            _ = t;
                            let i = null == (a = document.getElementById("gtm-toolbox")) || null == (r = a.getBoundingClientRect()) ? void 0 : r.top;
                            if ((null == (l = e.svgBlockCanvas_) || null == (n = l.getBoundingClientRect()) ? void 0 : n.top) > i && (y = g), window.innerWidth < 768) {
                                null == e || null == (c = e.scrollbar) || c.set(0, y);
                                let t = (null == (d = e.svgBlockCanvas_) ? void 0 : d.getBoundingClientRect().width) - (null == (u = e.svgBlockCanvas_) ? void 0 : u.getBoundingClientRect().left) + 60;
                                null == e || null == (h = e.scrollbar) || h.set(t, y);
                                return
                            }
                        }
                        null == e || null == (o = e.scrollbar) || o.set(_, y)
                    },
                    B = (e, t, i) => {
                        let s = e && window.Blockly.Events.getGroup() || i || !0;
                        window.Blockly.Events.setGroup(s), t(), e || window.Blockly.Events.setGroup(!1)
                    },
                    L = e => {
                        let {
                            recordUndo: t
                        } = window.Blockly.Events;
                        window.Blockly.Events.setRecordUndo(!1), e(), window.Blockly.Events.setRecordUndo(t ? ? !0)
                    },
                    P = e => {
                        window.Blockly.Events.disable(), e(), window.Blockly.Events.enable()
                    },
                    N = (e, t) => {
                        t.type !== window.Blockly.Events.BLOCK_DRAG || t.isStart || e.getAllBlocks().forEach(e => {
                            if (!e.getParent() || e.is_user_disabled_state) return;
                            let i = e.restricted_parents || [];
                            if (0 === i.length) return;
                            let s = !i.some(t => e.isDescendantOf(t));
                            B(!0, () => {
                                e.setDisabled(s)
                            }, t.group), window.Blockly.Events.setGroup(!1)
                        })
                    },
                    j = e => !e || "''" === e,
                    U = () => {
                        var e, t;
                        let i = null == (t = window.Blockly) || null == (e = t.getSelected()) ? void 0 : e.svgGroup_,
                            s = window.Blockly.Xml.domToPrettyText(i);
                        (0, y.U)({
                            data: s,
                            type: "text/xml;charset=utf-8",
                            filename: "block.xml"
                        })
                    },
                    M = (e, t) => {
                        for (let i = 0; i <= e.length - 1; i++) {
                            let s = (0, a.kg)(e[i].text);
                            t.includes(s) ? e.splice(i, 1) : e[i].text = s
                        }
                    },
                    H = () => [(0, a.kg)("Duplicate"), (0, a.kg)("Add Comment"), (0, a.kg)("Remove Comment"), (0, a.kg)("Collapse Block"), (0, a.kg)("Expand Block"), (0, a.kg)("Disable Block"), (0, a.kg)("Enable Block"), (0, a.kg)("Download Block")],
                    F = () => (0, a.kg)("Delete Block"),
                    W = () => (0, a.kg)("Delete All Blocks"),
                    $ = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                        [{
                            text: (0, a.kg)("Download Block"),
                            enabled: !0,
                            callback: U
                        }, ...t].forEach(t => {
                            e.push({
                                text: t.text,
                                enabled: t.enabled,
                                callback: t.callback
                            })
                        });
                        for (let t = 0; t < e.length; t++) {
                            var i, s;
                            let o = null == (s = e[t]) || null == (i = s.text) ? void 0 : i.toLowerCase();
                            if (null == o ? void 0 : o.includes("delete")) o.includes("block") && !o.includes("blocks") ? e[t].text = F() : e[t].text = W();
                            else {
                                let i = (0, a.kg)(e[t].text);
                                H().includes(i) && (e[t].text = i)
                            }
                        }
                    },
                    X = e => {
                        if (!e) return "invalid_input";
                        try {
                            let t = Function(`return ${e.trim()}`)();
                            return isNaN(t) ? "invalid_input" : t
                        } catch (e) {
                            return "invalid_input"
                        }
                    },
                    G = e => {
                        try {
                            var t, i;
                            if (!(null == e ? void 0 : e.collapsed_) || (null == e ? void 0 : e.getField(e.type))) return;
                            let [s, o] = (null == e || null == (i = e.inputList) || null == (t = i[0]) ? void 0 : t.fieldRow.map(e => e.value_)) || [], r = null == e ? void 0 : e.getField(Blockly.constants.COLLAPSED_FIELD_NAME), n = null == e ? void 0 : e.getInput(Blockly.constants.COLLAPSED_INPUT_NAME);
                            if (n && r) {
                                n.appendField(new Blockly.FieldImage(s, 25, 25, "", "")), n.appendField(new Blockly.FieldLabel(o, "blocklyTextRootBlockHeaderCollapsed"));
                                let t = `${null==e?void 0:e.workspace.options.pathToMedia}dropdown-arrow.svg`,
                                    i = new Blockly.FieldImage(t, 16, 16, (0, a.kg)("Collapsed"), () => null == e ? void 0 : e.setCollapsed(!1));
                                n.appendField(i, e.type), n.sourceBlock.width = 300, r.setVisible(!1)
                            }
                        } catch (e) {
                            u.P.emit("ui.log.error", e)
                        }
                    },
                    V = e => {
                        let t = e.getInput("_TEMP_COLLAPSED_INPUT");
                        if (t && e.collapsed_ && !t.icon_added) {
                            var i, s, o;
                            let r;
                            t.icon_added = !0;
                            let n = `${e.workspace.options.pathToMedia}dropdown-arrow.svg`,
                                l = new Blockly.FieldImage(n, 16, 16, (0, a.kg)("Collapsed"), () => e.setCollapsed(!1)),
                                c = e.getFieldValue("NAME"),
                                d = ` (${null==e||null==(i=e.arguments)?void 0:i.join(", ")})`;
                            t.appendField(new Blockly.FieldLabel((0, a.kg)("function"), "")).appendField(new Blockly.FieldLabel(c + d, "header__title")).appendField(l), null == (s = (r = t.fieldRow)[0]) || s.setVisible(!1), null == (o = r[0]) || o.forceRerender()
                        }
                    },
                    q = e => {
                        let t = e.getField("CURRENCY_LIST"),
                            {
                                currency: i
                            } = m.A.instance.client;
                        null == t || t.setValue((0, r.JN5)(i))
                    }
            },
            99326(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => l
                });
                var s = i(50467),
                    o = i(95526),
                    r = i(20332),
                    a = i(59673),
                    n = i(64772);
                class l {
                    async retrieveActiveSymbols() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        return (await this.trading_times.initialise(), !e && this.is_initialised) ? await this.init_promise : (this.is_initialised = !0, n.R.has_active_symbols || await n.R.active_symbols_promise, this.active_symbols = (null === n.R || void 0 === n.R ? void 0 : n.R.active_symbols) ? ? [], this.processed_symbols = this.processActiveSymbols(), this.trading_times.onMarketOpenCloseChanged = e => {
                            Object.keys(e).forEach(t => {
                                let i = this.active_symbols[t];
                                i && (i.exchange_is_open = e[t])
                            }), this.changes = e, this.processActiveSymbols()
                        }, this.init_promise.resolve()), this.active_symbols
                    }
                    processActiveSymbols() {
                        return this.active_symbols.reduce((e, t) => {
                            if ((0, r.$)().DISABLED_SYMBOLS.includes(t.symbol) || (0, r.$)().DISABLED_SUBMARKETS.includes(t.submarket)) return e;
                            let i = (e, i) => -1 !== Object.keys(e).findIndex(e => e === t[i]);
                            i(e, "market") || (e[t.market] = {
                                display_name: t.market_display_name,
                                submarkets: {}
                            });
                            let {
                                submarkets: s
                            } = e[t.market];
                            i(s, "submarket") || (s[t.submarket] = {
                                display_name: t.submarket_display_name,
                                symbols: {}
                            });
                            let {
                                symbols: o
                            } = s[t.submarket];
                            return i(o, "symbol") || (o[t.symbol] = {
                                display_name: t.display_name,
                                pip_size: `${t.pip}`.length - 2,
                                is_active: !t.is_trading_suspended && t.exchange_is_open
                            }), e
                        }, {})
                    }
                    getAllSymbols() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                            t = [];
                        return Object.keys(this.processed_symbols).forEach(i => {
                            if (e && this.isMarketClosed(i)) return;
                            let s = this.processed_symbols[i],
                                {
                                    submarkets: o
                                } = s;
                            Object.keys(o).forEach(e => {
                                let r = o[e],
                                    {
                                        symbols: a
                                    } = r;
                                Object.keys(a).forEach(o => {
                                    let n = a[o];
                                    t.push({
                                        market: i,
                                        market_display: s.display_name,
                                        submarket: e,
                                        submarket_display: r.display_name,
                                        symbol: o,
                                        symbol_display: n.display_name
                                    })
                                })
                            })
                        }), this.getSymbolsForBot(), t
                    }
                    getSymbolsForBot() {
                        let {
                            DISABLED: e
                        } = (0, r.$)().QUICK_STRATEGY, t = [];
                        return Object.keys(this.processed_symbols).forEach(i => {
                            if (this.isMarketClosed(i)) return;
                            let {
                                submarkets: s
                            } = this.processed_symbols[i];
                            Object.keys(s).forEach(i => {
                                if (e.SUBMARKETS.includes(i)) return;
                                let o = s[i],
                                    {
                                        symbols: r
                                    } = o;
                                Object.keys(r).forEach(i => {
                                    if (e.SYMBOLS.includes(i)) return;
                                    let s = r[i];
                                    t.push({
                                        group: o.display_name,
                                        text: s.display_name,
                                        value: i
                                    })
                                })
                            })
                        }), t
                    }
                    getMarketDropdownOptions() {
                        let e = [];
                        if (Object.keys(this.processed_symbols).forEach(t => {
                                let {
                                    display_name: i
                                } = this.processed_symbols[t], s = i + (this.isMarketClosed(t) ? ` ${(0,o.kg)("(Closed)")}` : "");
                                e.push([s, t])
                            }), 0 === e.length) return (0, r.$)().NOT_AVAILABLE_DROPDOWN_OPTIONS;
                        if (e.sort(e => "synthetic_index" === e[1] ? -1 : 1), e.some(e => this.isMarketClosed(e[1]))) {
                            let t = this.sortDropdownOptions(e, this.isMarketClosed);
                            return this.isMarketClosed("forex") ? t.sort(e => "synthetic_index" === e[1] ? -1 : 1) : t
                        }
                        return e
                    }
                    getSubmarketDropdownOptions(e) {
                        let t = [],
                            i = this.processed_symbols[e];
                        if (i) {
                            let {
                                submarkets: e
                            } = i;
                            Object.keys(e).forEach(i => {
                                let {
                                    display_name: s
                                } = e[i], r = s + (this.isSubmarketClosed(i) ? ` ${(0,o.kg)("(Closed)")}` : "");
                                t.push([r, i])
                            })
                        }
                        return 0 === t.length ? (0, r.$)().NOT_AVAILABLE_DROPDOWN_OPTIONS : ("synthetic_index" === e && t.sort(e => "random_index" === e[1] ? -1 : 1), this.sortDropdownOptions(t, this.isSubmarketClosed))
                    }
                    getSymbolDropdownOptions(e) {
                        let t = Object.keys(this.processed_symbols).reduce((t, i) => {
                            let {
                                submarkets: s
                            } = this.processed_symbols[i];
                            return Object.keys(s).forEach(i => {
                                if (i === e) {
                                    let {
                                        symbols: e
                                    } = s[i];
                                    Object.keys(e).forEach(i => {
                                        let {
                                            display_name: s
                                        } = e[i], r = s + (this.isSymbolClosed(i) ? ` ${(0,o.kg)("(Closed)")}` : "");
                                        t.push([r, i])
                                    })
                                }
                            }), t
                        }, []);
                        return 0 === t.length ? (0, r.$)().NOT_AVAILABLE_DROPDOWN_OPTIONS : this.sortDropdownOptions(t, this.isSymbolClosed)
                    }
                    isMarketClosed(e) {
                        let t = this.processed_symbols[e];
                        return !t || Object.keys(t.submarkets).every(e => this.isSubmarketClosed(e))
                    }
                    isSubmarketClosed(e) {
                        let t = Object.keys(this.processed_symbols).find(t => Object.keys(this.processed_symbols[t].submarkets).includes(e));
                        if (!t) return !0;
                        let i = this.processed_symbols[t].submarkets[e];
                        if (!i) return !0;
                        let {
                            symbols: s
                        } = i;
                        return Object.keys(s).every(e => this.isSymbolClosed(e))
                    }
                    isSymbolClosed(e) {
                        return this.active_symbols.some(t => t.symbol === e && (!t.exchange_is_open || t.is_trading_suspended))
                    }
                    constructor(e) {
                        (0, s._)(this, "sortDropdownOptions", (e, t) => {
                            let i = [...e];
                            return i.sort((e, i) => {
                                let s = t.call(this, e[1]),
                                    o = t.call(this, i[1]);
                                return s && !o ? 1 : s === o ? 0 : -1
                            }), i
                        }), this.active_symbols = [], this.disabled_symbols = (0, r.$)().DISABLED_SYMBOLS, this.disabled_submarkets = (0, r.$)().DISABLED_SUBMARKETS, this.init_promise = new a.A, this.is_initialised = !1, this.processed_symbols = {}, this.trading_times = e
                    }
                }
            },
            64772(e, t, i) {
                "use strict";
                i.d(t, {
                    R: () => h
                });
                var s = i(50467),
                    o = i(18987),
                    r = i(26008),
                    a = i(68034),
                    n = i(85389),
                    l = i(32745),
                    c = i(29432),
                    d = i(49043),
                    u = i(14343);
                let h = new class {
                    onsocketopen() {
                        (0, l.VW)("opened")
                    }
                    onsocketclose() {
                        (0, l.VW)("closed"), this.reconnectIfNotConnected()
                    }
                    async init() {
                        var e, t, i, s;
                        let o = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        this.toggleRunButton(!0), this.api && this.unsubscribeAllSubscriptions(), (!this.api || (null == (e = this.api) ? void 0 : e.connection.readyState) !== 1 || o) && ((null == (t = this.api) ? void 0 : t.connection) && (c.A.disposeInstance(), (0, l.VW)("closed"), this.api.disconnect(), this.api.connection.removeEventListener("open", this.onsocketopen.bind(this)), this.api.connection.removeEventListener("close", this.onsocketclose.bind(this))), this.api = (0, d.TN)(), null == (i = this.api) || i.connection.addEventListener("open", this.onsocketopen.bind(this)), null == (s = this.api) || s.connection.addEventListener("close", this.onsocketclose.bind(this))), this.has_active_symbols || (0, d.af)() || (this.active_symbols_promise = this.getActiveSymbols()), this.initEventListeners(), this.time_interval && clearInterval(this.time_interval), this.time_interval = null, (0, d.af)() && ((0, l.pK)(!0), await this.authorizeAndSubscribe()), u.A.init(o)
                    }
                    getConnectionStatus() {
                        var e;
                        if (null == (e = this.api) ? void 0 : e.connection) {
                            let e = this.api.connection.readyState;
                            return n.kM[e] || "Unknown"
                        }
                        return "Socket not initialized"
                    }
                    terminate() {
                        this.api && this.api.disconnect()
                    }
                    initEventListeners() {
                        window && (window.addEventListener("online", this.reconnectIfNotConnected), window.addEventListener("focus", this.reconnectIfNotConnected))
                    }
                    async createNewInstance(e) {
                        this.account_id !== e && await this.init()
                    }
                    async authorizeAndSubscribe() {
                        let e = (0, d.af)();
                        if (e && this.api) {
                            console.log("test Authorizing with token: 1", e), this.token = e, this.account_id = (0, d.HO)() ? ? "", (0, l.pK)(!0);
                            try {
                                let {
                                    authorize: e,
                                    error: t
                                } = await this.api.authorize(this.token);
                                if (console.log("test Authorizing with token: 2", e, t), t) return "InvalidToken" === t.code ? "true" === o.A.get("logged_state") ? a.P.emit("InvalidToken", {
                                    error: t
                                }) : (0, r.m_)() : console.error("Authorization error:", t), t;
                                console.log("test Authorizing with token: 3", e), this.account_info = e, (0, l.et)((null == e ? void 0 : e.account_list) || []), (0, l.vd)(e), (0, l.GL)(!0), this.is_authorized = !0, this.has_active_symbols ? this.toggleRunButton(!1) : this.active_symbols_promise = this.getActiveSymbols(), console.log("test Authorizing with token: 4", this), this.subscribe(), this.getSelfExclusion()
                            } catch (e) {
                                console.log("test Authorizing with token: 5", e), console.error("Authorization failed:", e), this.is_authorized = !1, (0, r.m_)(), (0, l.GL)(!1), a.P.emit("Error", e)
                            } finally {
                                console.log("test Authorizing with token: 6"), (0, l.pK)(!1)
                            }
                        }
                    }
                    async getSelfExclusion() {
                        this.api && this.is_authorized && await this.api.getSelfExclusion()
                    }
                    async subscribe() {
                        let e = e => (0, n.um)(() => {
                            var t;
                            let i = null == (t = this.api) ? void 0 : t.send({
                                [e]: 1,
                                subscribe: 1,
                                ..."balance" === e ? {
                                    account: "all"
                                } : {}
                            });
                            return i && this.current_auth_subscriptions.push(i), i
                        }, [], this);
                        await Promise.all(["balance", "transaction", "proposal_open_contract"].map(e))
                    }
                    setIsRunning() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        this.is_running = e
                    }
                    pushSubscription(e) {
                        this.subscriptions.push(e)
                    }
                    clearSubscriptions() {
                        this.subscriptions.forEach(e => e.unsubscribe()), this.subscriptions = [], (a.P.getState("global_timeouts") ? ? []).forEach((e, t) => {
                            clearTimeout(t)
                        })
                    }
                    constructor() {
                        (0, s._)(this, "api", null), (0, s._)(this, "token", ""), (0, s._)(this, "account_id", ""), (0, s._)(this, "pip_sizes", {}), (0, s._)(this, "account_info", {}), (0, s._)(this, "is_running", !1), (0, s._)(this, "subscriptions", []), (0, s._)(this, "time_interval", null), (0, s._)(this, "has_active_symbols", !1), (0, s._)(this, "is_stopping", !1), (0, s._)(this, "active_symbols", []), (0, s._)(this, "current_auth_subscriptions", []), (0, s._)(this, "is_authorized", !1), (0, s._)(this, "active_symbols_promise", null), (0, s._)(this, "common_store", void 0), (0, s._)(this, "landing_company", null), (0, s._)(this, "unsubscribeAllSubscriptions", () => {
                            var e;
                            null == (e = this.current_auth_subscriptions) || e.forEach(e => {
                                e.then(e => {
                                    let {
                                        subscription: t
                                    } = e;
                                    if (null == t ? void 0 : t.id) {
                                        var i;
                                        null == (i = this.api) || i.send({
                                            forget: t.id
                                        })
                                    }
                                })
                            }), this.current_auth_subscriptions = []
                        }), (0, s._)(this, "reconnectIfNotConnected", () => {
                            var e, t, i, s, o, r;
                            console.log("connection state: ", null == (t = this.api) || null == (e = t.connection) ? void 0 : e.readyState), (null == (s = this.api) || null == (i = s.connection) ? void 0 : i.readyState) && (null == (r = this.api) || null == (o = r.connection) ? void 0 : o.readyState) > 1 && (console.log("Info: Connection to the server was closed, trying to reconnect."), this.init(!0))
                        }), (0, s._)(this, "getActiveSymbols", async () => {
                            await (0, n.um)(() => {
                                var e;
                                return null == (e = this.api) ? void 0 : e.send({
                                    active_symbols: "brief"
                                })
                            }, [], this).then(e => {
                                let {
                                    active_symbols: t = [],
                                    error: i = {}
                                } = e, s = {};
                                return t.length && (this.has_active_symbols = !0), t.forEach(e => {
                                    let {
                                        symbol: t,
                                        pip: i
                                    } = e;
                                    s[t] = +(+i).toExponential().substring(3)
                                }), this.pip_sizes = s, this.toggleRunButton(!1), this.active_symbols = t, t || i
                            })
                        }), (0, s._)(this, "toggleRunButton", e => {
                            let t = document.querySelector("#db-animation__run-button");
                            t && (t.disabled = e)
                        })
                    }
                }
            },
            29432(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => c
                });
                var s = i(50467);
                class o {
                    getStakePayoutLimits() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "AUD",
                            t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "svg",
                            i = arguments.length > 2 ? arguments[2] : void 0;
                        return this.ws.send({
                            landing_company_details: t
                        }).then(t => {
                            var s;
                            let o = null == t || null == (s = t.landing_company_details) ? void 0 : s.currency_config[i];
                            return o ? o[e] : {}
                        })
                    }
                    constructor(e) {
                        this.ws = e.ws
                    }
                }
                var r = i(99326),
                    a = i(96367),
                    n = i(77604);
                class l {
                    static disposeInstance() {
                        this.singleton = null
                    }
                    static setInstance(e) {
                        return this.singleton || (this.singleton = new l(e)), this.instance
                    }
                    static get instance() {
                        return this.singleton
                    }
                    constructor(e) {
                        this.trading_times = new n.A(e), this.contracts_for = new a.A(e), this.active_symbols = new r.A(this.trading_times), this.account_limits = new o(e)
                    }
                }(0, s._)(l, "singleton", null);
                let c = l
            },
            49043(e, t, i) {
                "use strict";
                i.d(t, {
                    af: () => u,
                    TN: () => d,
                    HO: () => h
                });
                var s = i(28176),
                    o = i(86126),
                    r = i.n(o),
                    a = i(95526),
                    n = i(50467);
                let l = ["active_symbols", "authorize", "balance", "buy", "proposal", "proposal_open_contract", "transaction", "ticks_history", "history"],
                    c = class {
                        constructor(e) {
                            (0, n._)(this, "getRequestType", e => {
                                let t;
                                return l.forEach(i => {
                                    i in e && !t && (t = i)
                                }), t
                            }), (0, n._)(this, "defineMeasure", e => {
                                if (e) {
                                    let t;
                                    return "history" === e ? (performance.mark("ticks_history_end"), t = performance.measure("ticks_history", "ticks_history_start", "ticks_history_end")) : (performance.mark(`${e}_end`), t = performance.measure(`${e}`, `${e}_start`, `${e}_end`)), t.startTimeDate = new Date(Date.now() - t.startTime)
                                }
                                return !1
                            }), (0, n._)(this, "sendIsCalled", e => {
                                let {
                                    response_promise: t,
                                    args: [i]
                                } = e, s = this.getRequestType(i);
                                return s && performance.mark(`${s}_start`), t.then(e => {
                                    let t = this.getRequestType(e);
                                    t && this.defineMeasure(t)
                                }).catch(() => {}), t
                            }), this.config = e, this.debounced_calls = {}
                        }
                    },
                    d = () => {
                        var e, t;
                        let i = (0, s.J39)().replace(/[^a-zA-Z0-9.]/g, ""),
                            o = (null == (t = (0, s.R7U)()) || null == (e = t.replace) ? void 0 : e.call(t, /[^a-zA-Z0-9]/g, "")) ? ? (0, s.R7U)(),
                            n = new WebSocket(`wss://${i}/websockets/v3?app_id=${o}&l=${(0,a.dn)()}&brand=deriv`);
                        return new(r())({
                            connection: n,
                            middleware: new c({})
                        })
                    },
                    u = () => {
                        let e = localStorage.getItem("authToken");
                        return e && "null" !== e ? e : null
                    },
                    h = () => {
                        let e = u();
                        if (!e) return null;
                        let t = JSON.parse(localStorage.getItem("accountsList"));
                        return t && "null" !== t ? Object.keys(t).find(i => t[i] === e) : null
                    }
            },
            14343(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => r
                });
                var s = i(50467),
                    o = i(49043);
                let r = new class {
                    onsocketclose() {
                        this.reconnectIfNotConnected()
                    }
                    getTime() {
                        this.time_interval || (this.time_interval = setInterval(() => {
                            this.api.send({
                                time: 1
                            })
                        }, 3e4))
                    }
                    constructor() {
                        var e = this;
                        (0, s._)(this, "api", void 0), (0, s._)(this, "init", async function() {
                            let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                            if (!e.api || t) {
                                var i, s;
                                (null == (i = e.api) ? void 0 : i.connection) && (e.api.disconnect(), e.api.connection.removeEventListener("close", e.onsocketclose.bind(e))), e.api = await (0, o.TN)(), null == (s = e.api) || s.connection.addEventListener("close", e.onsocketclose.bind(e))
                            }
                            e.getTime()
                        }), (0, s._)(this, "reconnectIfNotConnected", () => {
                            var e, t, i, s, o, r;
                            console.log("chart connection state: ", null == (t = this.api) || null == (e = t.connection) ? void 0 : e.readyState), (null == (s = this.api) || null == (i = s.connection) ? void 0 : i.readyState) && (null == (r = this.api) || null == (o = r.connection) ? void 0 : o.readyState) > 1 && (console.log("Info: Chart connection to the server was closed, trying to reconnect."), this.init(!0))
                        })
                    }
                }
            },
            96367(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => n
                });
                var s = i(50467),
                    o = i(20332),
                    r = i(59673),
                    a = i(64772);
                class n {
                    async getBarriers(e, t, i, s) {
                        let r = {
                            values: []
                        };
                        if (!(0, o.$)().BARRIER_TRADE_TYPES.includes(t)) return r;
                        let a = ["high_barrier", "low_barrier"],
                            n = await this.getContractsByTradeType(e, t),
                            l = await this.getDurations(e, t, !1),
                            c = /^[-|+]([0-9]+.[0-9]+)$/,
                            d = e => e && c.test(e.toString()),
                            u = !0;
                        return n.length > 0 && (s.forEach((e, h) => {
                            let p = ["+", "-"].includes(e),
                                _ = this.getContractCategoryByTradeType(t),
                                g = n.find(e => {
                                    let {
                                        BARRIER_CATEGORIES: s
                                    } = (0, o.$)(), r = Object.keys(s).find(e => s[e].includes(t)), n = e.contract_category === _, c = -1 !== l.findIndex(e => e.unit === i), u = e.barrier_category === r, g = p && d(e.barrier || e[a[h]]) || !p && !d(e.barrier || e[a[h]]);
                                    return n && c && u && g
                                });
                            if (!g && (g = n.filter(e => e.barrier || e.high_barrier).sort((e, t) => {
                                    let i = e.barrier || e.high_barrier,
                                        s = t.barrier || t.high_barrier;
                                    return parseFloat(i) - parseFloat(s)
                                }).shift()) && !p && (u = !1), g) {
                                let t = 1 === g.barriers ? "barrier" : a[h];
                                if (g[t]) {
                                    let e = `${g[t]}`.match(c);
                                    r.values[h] = e ? e[1] : g[t]
                                }
                                Object.assign(r, {
                                    allow_both_types: ["intraday", "tick"].includes(g.expiry_type) && d(g[t]),
                                    allow_absolute_type: "absolute" === e && !d(g[t])
                                }), 1 === g.barriers && s.splice(h + 1, 1)
                            }
                        }), u ? 2 === r.values.length && s.every(e => e === s[0]) && r.values.every(e => e === r.values[0]) && (r.values[1] = (.95 * r.values[0]).toFixed(1)) : r.values = r.values.map(() => !1)), r
                    }
                    getContractCategoryByTradeType(e) {
                        let {
                            TRADE_TYPE_TO_CONTRACT_CATEGORY_MAPPING: t
                        } = (0, o.$)();
                        return Object.keys(t).find(i => t[i].includes(e)) || e
                    }
                    getTradeTypeCategoryByTradeType(e) {
                        let {
                            TRADE_TYPE_CATEGORIES: t
                        } = (0, o.$)();
                        return Object.keys(t).find(i => t[i].includes(e)) || e
                    }
                    getTradeTypeCategoryNameByTradeType(e) {
                        let {
                            TRADE_TYPE_CATEGORY_NAMES: t
                        } = (0, o.$)();
                        return t[this.getTradeTypeCategoryByTradeType(e)]
                    }
                    getBarrierCategoryByTradeType(e) {
                        let {
                            BARRIER_CATEGORIES: t
                        } = (0, o.$)();
                        return Object.keys(t).find(i => t[i].includes(e))
                    }
                    async getContractsByTradeType(e, t) {
                        let i = await this.getContractsFor(e),
                            s = this.getContractCategoryByTradeType(t),
                            o = this.getBarrierCategoryByTradeType(t);
                        return i.filter(e => {
                            let t = e.contract_category === s,
                                i = e.barrier_category === o;
                            return t && i
                        })
                    }
                    async getContractsFor(e) {
                        if (!e || "na" === e) return [];
                        let t = async () => {
                            if (this.retrieving_contracts_for[e]) return await this.retrieving_contracts_for[e], this.contracts_for[e].contracts;
                            this.retrieving_contracts_for[e] = new r.A;
                            let t = await a.R.api.send({
                                contracts_for: e
                            });
                            if (t.error) return [];
                            let {
                                contracts_for: {
                                    available: i
                                }
                            } = t, s = i.filter(e => "forward" !== e.start_type);
                            return this.contracts_for[e] = {
                                contracts: s,
                                timestamp: this.server_time.unix()
                            }, this.retrieving_contracts_for[e].resolve(), delete this.retrieving_contracts_for[e], s
                        };
                        if (this.contracts_for[e]) {
                            let {
                                contracts: i,
                                timestamp: s
                            } = this.contracts_for[e];
                            return this.server_time.unix() - s > 60 * this.cache_age_in_min && t(), i
                        }
                        return t()
                    }
                    async getDurations(e, t) {
                        let i = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2];
                        if ("multiplier" === t || "accumulator" === t) return [];
                        let s = await this.getContractsFor(e),
                            {
                                NOT_AVAILABLE_DURATIONS: r,
                                DEFAULT_DURATION_DROPDOWN_OPTIONS: a
                            } = (0, o.$)();
                        if (0 === s.length) return r;
                        let n = await this.getContractsByTradeType(e, t),
                            l = [],
                            c = e => a.findIndex(t => t[1] === e.replace(/\d+/g, ""));
                        if (n.forEach(e => {
                                if (!e.min_contract_duration || !e.max_contract_duration) return;
                                let t = c(e.min_contract_duration),
                                    s = c("1d" === e.max_contract_duration && i ? "24h" : e.max_contract_duration);
                                a.slice(t, s + 1).forEach((t, i) => {
                                    var s, o;
                                    let r, n, d, u; - 1 === l.findIndex(e => e.unit === t[1]) && l.push({
                                        display: t[0],
                                        unit: t[1],
                                        min: 0 === i ? parseInt(e.min_contract_duration.replace(/\D/g, "")) : 1,
                                        max: (s = e.max_contract_duration, o = t[1], r = s.replace(/\D/g, ""), n = c(s), d = a.findIndex(e => e[1] === o), u = parseInt(r), a.slice(d + 1, n + 1).reverse().forEach(e => {
                                            switch (e[1]) {
                                                case "m":
                                                case "h":
                                                    u *= 60;
                                                    break;
                                                case "d":
                                                    u *= 24
                                            }
                                        }), u)
                                    })
                                })
                            }), n.every(e => "intraday" === e.expiry_type)) {
                            let e = l.findIndex(e => "d" === e[1]); - 1 !== e && l.splice(e, 1)
                        }
                        return 0 === l.length ? r : l.sort((e, t) => c(e.unit) - c(t.unit))
                    }
                    async getPredictionRange(e, t) {
                        let i = await this.getContractsByTradeType(e, t),
                            s = this.getContractCategoryByTradeType(t),
                            r = [],
                            {
                                DIGIT_CATEGORIES: a,
                                opposites: n
                            } = (0, o.$)();
                        if (a.includes(s) && "evenodd" !== t) {
                            let e = i.find(e => Object.keys(n).some(t => n[t].map(e => Object.keys(e)[0]).includes(e.contract_type)));
                            e && e.last_digit_range ? r.push(...e.last_digit_range) : r.push(1, 2, 3, 4, 5, 6, 7, 8)
                        }
                        return r
                    }
                    async getMultiplierRange(e, t) {
                        let i = await this.getContractsByTradeType(e, t),
                            s = [],
                            {
                                opposites: r
                            } = (0, o.$)(),
                            a = i.find(e => Object.keys(r).some(t => r[t].map(e => Object.keys(e)[0]).includes(e.contract_type)));
                        return (null == a ? void 0 : a.multiplier_range) && s.push(...a.multiplier_range), s
                    }
                    async getMarketBySymbol(e) {
                        let t = await this.getContractsFor(e);
                        return t.length ? t[0].market : "na"
                    }
                    async getSubmarketBySymbol(e) {
                        let t = await this.getContractsFor(e);
                        return t.length ? t[0].submarket : "na"
                    }
                    async getGroupedTradeTypes(e) {
                        let t = await this.getContractsFor(e),
                            i = {};
                        for (let s = 0; s < t.length; s++) {
                            let o = t[s].market,
                                r = t[s].submarket,
                                a = this.getTradeTypeCategoryByTradeType(t[s].contract_category),
                                n = this.getTradeTypeCategoryNameByTradeType(t[s].contract_category),
                                l = await this.getTradeTypeByTradeCategory(o, r, e, a);
                            n && (this.isDisabledOption({
                                market: o,
                                submarket: r,
                                symbol: e,
                                trade_type_category: a
                            }) || (i[n] = l))
                        }
                        return i
                    }
                    async getTradeTypeByTradeCategory(e, t, i, s) {
                        let {
                            NOT_AVAILABLE_DURATIONS: r,
                            TRADE_TYPE_CATEGORIES: a,
                            opposites: n
                        } = (0, o.$)(), l = a[s], c = [];
                        if (l && l.length)
                            for (let o = 0; o < l.length; o++) {
                                let a = l[o],
                                    d = JSON.stringify(await this.getDurations(i, a)) !== JSON.stringify(r);
                                if (!this.isDisabledOption({
                                        market: e,
                                        submarket: t,
                                        symbol: i,
                                        trade_type_category: s,
                                        trade_type: a
                                    }) && d) {
                                    let e = n[a.toUpperCase()],
                                        t = [],
                                        i = [];
                                    e.forEach(e => {
                                        t.push(Object.keys(e)[0]), i.push(Object.values(e)[0])
                                    }), c.push({
                                        name: i.join("/"),
                                        value: a,
                                        icon: t
                                    })
                                }
                            }
                        return c
                    }
                    async getTradeTypesForQuickStrategy(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                            i = [],
                            s = [];
                        if ("ACCU" === t) return i.push({
                            text: "Buy",
                            value: "ACCU"
                        }), i;
                        let o = await this.getMarketBySymbol(e),
                            r = await this.getSubmarketBySymbol(e),
                            a = await this.getTradeTypeCategories(o, r, e);
                        for (let t = 0; t < a.length; t++) {
                            let i = a[t],
                                n = await this.getTradeTypeByTradeCategory(o, r, e, i[1]);
                            this.getHiddenCategories(n) < n.length && s.push(i)
                        }
                        for (let t = 0; t < s.length; t++) {
                            let a = s[t],
                                n = await this.getTradeTypeByTradeCategory(o, r, e, a[1]);
                            i.push(...this.getTradeTypeOptions(n, a))
                        }
                        return i
                    }
                    async getTradeTypeCategories(e, t, i) {
                        let {
                            TRADE_TYPE_CATEGORY_NAMES: s,
                            NOT_AVAILABLE_DROPDOWN_OPTIONS: r
                        } = (0, o.$)(), a = await this.getContractsFor(i), n = [];
                        if (a.forEach(s => {
                                let o = this.getTradeTypeCategoryByTradeType(s.contract_category),
                                    r = this.getTradeTypeCategoryNameByTradeType(s.contract_category);
                                r && (this.isDisabledOption({
                                    market: e,
                                    submarket: t,
                                    symbol: i,
                                    trade_type_category: o
                                }) || -1 === n.findIndex(e => e[1] === o) && n.push([r, o]))
                            }), n.length > 0) {
                            let e = Object.keys(s);
                            return n.sort((t, i) => e.findIndex(e => e === t[1]) - e.findIndex(e => e === i[1]))
                        }
                        return r
                    }
                    async getTradeTypes(e, t, i, s) {
                        let {
                            NOT_AVAILABLE_DURATIONS: r,
                            TRADE_TYPE_CATEGORIES: a,
                            opposites: n
                        } = (0, o.$)(), l = [], c = a[s];
                        if (c)
                            for (let o = 0; o < c.length; o++) {
                                let a = c[o],
                                    d = JSON.stringify(await this.getDurations(i, a)) !== JSON.stringify(r);
                                if (!this.isDisabledOption({
                                        market: e,
                                        submarket: t,
                                        symbol: i,
                                        trade_type_category: s,
                                        trade_type: a
                                    }) && d) {
                                    let e = n[a.toUpperCase()];
                                    l.push([e.map(e => e[Object.keys(e)[0]]).join("/"), a])
                                }
                            }
                        return l.length > 0 ? l : (0, o.$)().NOT_AVAILABLE_DROPDOWN_OPTIONS
                    }
                    isDisabledOption(e) {
                        return this.disabled_options.some(t => Object.keys(t).every(i => e[i] === t[i]))
                    }
                    disposeCache() {
                        this.contracts_for = {}
                    }
                    constructor({
                        ws: e,
                        server_time: t
                    }) {
                        (0, s._)(this, "getAccumulationRange", async () => [.01, .02, .03, .04, .05]), (0, s._)(this, "getHiddenCategories", e => {
                            let t = 0;
                            for (let i = 0; i < e.length; i++) {
                                let s = e[i],
                                    r = (0, o.$)().QUICK_STRATEGY.DISABLED.BARRIER_TRADE_TYPES.includes(s.value),
                                    a = (0, o.$)().QUICK_STRATEGY.DISABLED.PREDICTION_TRADE_TYPES.includes(s.value);
                                (r || a) && t++
                            }
                            return t
                        }), (0, s._)(this, "getTradeTypeOptions", (e, t) => {
                            let i = [];
                            return e.forEach(e => {
                                let s = (0, o.$)().QUICK_STRATEGY.DISABLED.BARRIER_TRADE_TYPES.includes(e.value),
                                    r = (0, o.$)().QUICK_STRATEGY.DISABLED.PREDICTION_TRADE_TYPES.includes(e.value),
                                    a = ["multiplier"].includes(e.value);
                                s || r || a || i.push({
                                    text: e.name,
                                    value: e.value,
                                    group: t[0],
                                    icon: e.icon
                                })
                            }), i
                        }), (0, s._)(this, "getContractTypes", e => {
                            let {
                                opposites: t
                            } = (0, o.$)(), i = e;
                            return "ACCU" === i && (i = "accumulator"), t[i.toUpperCase()].map(e => ({
                                value: Object.keys(e)[0],
                                text: Object.values(e)[0]
                            }))
                        }), this.cache_age_in_min = 10, this.contracts_for = {}, this.ws = e, this.server_time = t, this.disabled_options = [{
                            submarket: "forex_basket",
                            trade_type: "higherlower"
                        }, {
                            submarket: "minor_pairs",
                            trade_type: "higherlower"
                        }, {
                            submarket: "metals",
                            trade_type: "callputequal"
                        }, {
                            market: "indices",
                            trade_type: "callputequal"
                        }, {
                            symbol: "OTC_AS51",
                            trade_type_category: "inout"
                        }, {
                            trade_type_category: "lookback"
                        }, {
                            trade_type_category: "callputspread"
                        }], this.retrieving_contracts_for = {}
                    }
                }
            },
            67109(e, t, i) {
                "use strict";
                let s, o, r;
                i.d(t, {
                    ew: () => p.A,
                    cJ: () => a.A,
                    Fh: () => h,
                    Rk: () => n.R,
                    aq: () => l.A,
                    Zp: () => c.A,
                    z7: () => d
                });
                var a = i(99326),
                    n = i(64772),
                    l = i(29432),
                    c = i(96367);
                class d {
                    addEvents() {
                        "onLine" in navigator ? (window.addEventListener("online", () => this.setStatus()), window.addEventListener("offline", () => this.setStatus())) : (navigator.onLine = !0, setInterval(() => this.setStatus(), 1e4)), this.setStatus()
                    }
                    setStatus() {
                        navigator.onLine ? (this.parentElement.html("<span class='connecting'></span>"), this.api.send({
                            ping: "1"
                        }).then(() => {
                            this.parentElement.html("<span class='online'></span>")
                        })) : this.parentElement.html("<span class='offline'></span>")
                    }
                    constructor(e, t) {
                        this.api = e, this.parentElement = t, this.addEvents()
                    }
                }
                var u = i(59673);
                let h = (o = !1, r = new u.A, {
                    init: e => {
                        o || (s = e, r.resolve(s.server_time), o = !0)
                    },
                    get: () => o && s.server_time ? s.server_time.clone() : void 0,
                    timePromise: () => o ? Promise.resolve(s.server_time) : r.promise
                });
                var p = i(77604)
            },
            32745(e, t, i) {
                "use strict";
                i.d(t, {
                    GL: () => d,
                    HN: () => l,
                    P4: () => n,
                    VW: () => c,
                    XH: () => r,
                    et: () => h,
                    pK: () => u,
                    uw: () => a,
                    vd: () => p,
                    xi: () => o
                });
                var s = i(11766);
                let o = new s.t("unknown"),
                    r = new s.t(!1),
                    a = new s.t(!1),
                    n = new s.t([]),
                    l = new s.t(null),
                    c = e => {
                        o.next(e)
                    },
                    d = e => {
                        a.next(e)
                    },
                    u = e => {
                        r.next(e)
                    },
                    h = e => {
                        n.next(e)
                    },
                    p = e => {
                        (null == e ? void 0 : e.loginid) && localStorage.setItem("active_loginid", e.loginid), l.next(e)
                    }
            },
            77604(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => o
                });
                var s = i(59673);
                class o {
                    async initialise() {
                        if (this.is_initialised) return this.init_promise;
                        if (this.is_initialised = !0, this.last_update_moment = this.server_time.local(), !Object.keys(this.trading_times).length) {
                            await this.updateTradingTimes(), this.init_promise.resolve();
                            let e = async () => {
                                let t = this.updateMarketOpenClosed();
                                Object.keys(t).length > 0 && this.onMarketOpenCloseChanged && this.onMarketOpenCloseChanged(t);
                                let i = this.nextUpdateDate();
                                if (!i) {
                                    let e = this.server_time.local(),
                                        t = this.last_update_moment.clone().add(1, "days");
                                    e.isAfter(t) ? this.last_update_moment = e.clone() : this.last_update_moment = t.clone();
                                    let s = {};
                                    Object.keys(this.trading_times).forEach(e => {
                                        s[e] = this.trading_times[e].is_opened
                                    }), await this.updateTradingTimes(), Object.keys(this.trading_times).forEach(e => {
                                        this.trading_times[e].is_opened = s[e]
                                    }), t.set({
                                        hour: 0,
                                        minute: 0,
                                        second: 0
                                    }), i = t.toDate()
                                }
                                let s = i - this.server_time.local().toDate();
                                this.update_timer = setTimeout(e, s)
                            };
                            await e()
                        }
                        return this.init_promise
                    }
                    async updateTradingTimes() {
                        let e, t = this.last_update_moment.format("YYYY-MM-DD");
                        try {
                            var i;
                            e = await (null == (i = this.ws) ? void 0 : i.send({
                                trading_times: t
                            }))
                        } catch (e) {
                            console.error("Error fetching trading times:", e);
                            return
                        }
                        if (!e || e.error) return;
                        this.trading_times = {};
                        let s = this.server_time.local().toDate().toISOString().substring(0, 11),
                            o = e => new Date(`${s}${e}Z`),
                            {
                                trading_times: {
                                    markets: r
                                }
                            } = e;
                        r && (null == r || r.forEach(e => {
                            let {
                                submarkets: t
                            } = e;
                            null == t || t.forEach(e => {
                                let {
                                    symbols: t
                                } = e;
                                null == t || t.forEach(e => {
                                    let t, {
                                            times: i,
                                            symbol: s
                                        } = e,
                                        {
                                            open: r,
                                            close: a
                                        } = i,
                                        n = 1 === r.length && "00:00:00" === r[0] && "23:59:59" === a[0],
                                        l = 1 === r.length && "--" === r[0] && "--" === a[0];
                                    n || l || (t = r.map((e, t) => ({
                                        open: o(e),
                                        close: o(a[t])
                                    }))), this.trading_times[s] = {
                                        is_open_all_day: n,
                                        is_closed_all_day: l,
                                        times: t
                                    }
                                })
                            })
                        }))
                    }
                    updateMarketOpenClosed() {
                        let e = {};
                        return Object.keys(this.trading_times).forEach(t => {
                            let i = this.calcIsMarketOpened(t),
                                s = this.trading_times[t];
                            s.is_opened !== i && (s.is_opened = i, e[t] = i)
                        }), e
                    }
                    calcIsMarketOpened(e) {
                        let t = this.server_time.local().unix(),
                            {
                                times: i,
                                is_open_all_day: s,
                                is_closed_all_day: o
                            } = this.trading_times[e];
                        return !o && (!!s || i.some(e => {
                            let {
                                open: i,
                                close: s
                            } = e;
                            return t >= i && t < s
                        }))
                    }
                    nextUpdateDate() {
                        let e, t = this.server_time.local().toDate();
                        return Object.keys(this.trading_times).forEach(i => {
                            let {
                                times: s,
                                is_open_all_day: o,
                                is_closed_all_day: r
                            } = this.trading_times[i];
                            o || r || s.forEach(i => {
                                let {
                                    open: s,
                                    close: o
                                } = i;
                                s > t && (!e || s < e) && (e = s), o > t && (!e || o < e) && (e = o)
                            })
                        }), e
                    }
                    isMarketOpened(e) {
                        let t = Object.keys(this.trading_times);
                        return !!t.length && !!t.includes(e) && this.trading_times[e].is_opened
                    }
                    constructor({
                        ws: e,
                        server_time: t
                    }) {
                        this.init_promise = new s.A, this.is_initialised = !1, this.trading_times = {}, this.ws = e, this.server_time = t.clone()
                    }
                }
            },
            71371(e, t, i) {
                "use strict";
                i.d(t, {
                    Rm: () => c,
                    dz: () => r,
                    fh: () => a,
                    me: () => l,
                    pq: () => n,
                    z3: () => d
                });
                var s = i(20332),
                    o = i(68034);
                let r = e => o.P.emit("bot.contract", e),
                    a = e => o.P.emit("contract.status", e),
                    n = e => o.P.emit("bot.info", e),
                    l = (e, t) => o.P.emit("ui.log.notify", {
                        className: e,
                        message: t,
                        sound: (0, s.$)().lists.NOTIFICATION_SOUND[0][1]
                    }),
                    c = (e, t) => o.P.emit("ui.log.success", {
                        log_type: e,
                        extra: t
                    }),
                    d = e => o.P.emit("ui.log.error", e)
            },
            85389(e, t, i) {
                "use strict";
                i.d(t, {
                    $: () => p,
                    NZ: () => l,
                    bJ: () => u,
                    kM: () => f,
                    n3: () => g,
                    u6: () => d,
                    um: () => _,
                    vm: () => y,
                    x9: () => c,
                    yk: () => m
                });
                var s = i(28176),
                    o = i(28132),
                    r = i(95526),
                    a = i(68034),
                    n = i(71371);
                let l = (e, t) => e.contractTypes.map(i => {
                        let o = {
                            amount: e.amount,
                            basis: e.basis,
                            contract_type: i,
                            currency: e.currency,
                            duration: e.duration,
                            duration_unit: e.duration_unit,
                            multiplier: e.multiplier,
                            passthrough: {
                                contract_type: i,
                                purchase_reference: t
                            },
                            proposal: 1,
                            symbol: e.symbol
                        };
                        return void 0 !== e.prediction && (o.selected_tick = e.prediction), ["TICKLOW", "TICKHIGH"].includes(i) || void 0 === e.prediction ? void 0 !== e.barrierOffset && (o.barrier = e.barrierOffset) : o.barrier = e.prediction, void 0 !== e.secondBarrierOffset && (o.barrier2 = e.secondBarrierOffset), ["MULTUP", "MULTDOWN"].includes(i) && (o.duration = void 0, o.duration_unit = void 0), (0, s.RIy)(e.limit_order) || (o.limit_order = e.limit_order), o
                    }),
                    c = (e, t) => {
                        let i = {
                            buy: "1",
                            price: t.amount,
                            parameters: {
                                amount: t.amount,
                                basis: t.basis,
                                contract_type: e,
                                currency: t.currency,
                                duration: t.duration,
                                duration_unit: t.duration_unit,
                                multiplier: t.multiplier,
                                symbol: t.symbol
                            }
                        };
                        return void 0 !== t.prediction && (i.parameters.selected_tick = t.prediction), ["TICKLOW", "TICKHIGH"].includes(e) || void 0 === t.prediction ? void 0 !== t.barrierOffset && (i.parameters.barrier = t.barrierOffset) : i.parameters.barrier = t.prediction, void 0 !== t.secondBarrierOffset && (i.parameters.barrier2 = t.secondBarrierOffset), (0, s.RIy)(t.app_markup_percentage) || (i.parameters.app_markup_percentage = t.app_markup_percentage), (0, s.RIy)(t.barrier_range) || (i.parameters.barrier_range = t.barrier_range), (0, s.RIy)(t.date_expiry) || (i.parameters.date_expiry = t.date_expiry), (0, s.RIy)(t.date_start) || (i.parameters.date_start = t.date_start), (0, s.RIy)(t.product_type) || (i.parameters.product_type = t.product_type), (0, s.RIy)(t.trading_period_start) || (i.parameters.trading_period_start = t.trading_period_start), (0, s.RIy)(t.limit_order) || (i.parameters.limit_order = t.limit_order), ["MULTUP", "MULTDOWN"].includes(e) && (i.parameters.duration = void 0, i.parameters.duration_unit = void 0, i.parameters.multiplier = t.multiplier), ["ACCU"].includes(e) && (i.parameters.duration = void 0, i.parameters.duration_unit = void 0, i.parameters.growth_rate = t.growth_rate), i
                    },
                    d = e => {
                        let {
                            length: t
                        } = e, [i, s] = e.slice(-2), o = "";
                        return t >= 2 && (o = i.quote < s.quote ? "rise" : o, o = i.quote > s.quote ? "fall" : o), o
                    },
                    u = e => {
                        let t = e;
                        return "number" == typeof t && (t = String(t)), Number(t[t.length - 1])
                    },
                    h = function(e) {
                        var t, i, s, o, n;
                        let l = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                        if (!e.error) return !1;
                        (null == (s = e.error) ? void 0 : s.code) === "InputValidationFailed" && ((null == (o = e.error.details) ? void 0 : o.duration) && (e.error.message = (0, r.kg)("Duration must be a positive integer")), (null == (n = e.error.details) ? void 0 : n.amount) && (e.error.message = (0, r.kg)("Amount must be a positive number.")));
                        let c = l.concat(["CallError", "WrongResponse", "GetProposalFailure", "RateLimit", "DisconnectError", "MarketIsClosed", "OpenPositionLimitExceeded"]).includes((null == e || null == (t = e.error) ? void 0 : t.code) ? ? (null == e ? void 0 : e.name));
                        return (null == (i = e.error) ? void 0 : i.code) === "OpenPositionLimitExceeded" && a.P.emit("bot.recoverOpenPositionLimitExceeded"), !c
                    },
                    p = (e, t, i, l, c) => new Promise((d, u) => {
                        let p = e();
                        p ? p.then(d).catch(e => {
                            var d;
                            h(e, i) || c && !c.is_running ? u(e) : t((null == e || null == (d = e.error) ? void 0 : d.code) ? ? (null == e ? void 0 : e.name), () => new Promise(t => {
                                let i = () => a.P.getState("global_timeouts") ? ? [],
                                    c = setTimeout(() => {
                                        let e = i();
                                        delete e[c], a.P.setState(e), t()
                                    }, ((e, t) => {
                                        let i = Math.min(2.5 * t, 15),
                                            {
                                                error: s = {},
                                                msg_type: a = "",
                                                echo_req: l = {}
                                            } = e,
                                            {
                                                code: c = "",
                                                message: d = ""
                                            } = s,
                                            u = "",
                                            h = Blockly.derivWorkspace.getAllBlocks(!0).find(e => "trade_definition_tradetype" === e.type),
                                            p = (null == h ? void 0 : h.getFieldValue("TRADETYPECAT_LIST")) || "",
                                            {
                                                TRADE_TYPE_CATEGORY_NAMES: _
                                            } = (0, o.$W)();
                                        if (c) switch (c) {
                                            case "RateLimit":
                                                u = (0, r.kg)("You are rate limited for: {{ message_type }}, retrying in {{ delay }}s (ID: {{ request }})", {
                                                    message_type: s.msg_type,
                                                    delay: i,
                                                    request: null == l ? void 0 : l.req_id
                                                });
                                                break;
                                            case "DisconnectError":
                                                u = (0, r.kg)("You are disconnected, retrying in {{ delay }}s", {
                                                    delay: i
                                                });
                                                break;
                                            case "MarketIsClosed":
                                                u = (0, r.kg)("{{ message }}, retrying in {{ delay }}s", {
                                                    message: d || (0, r.kg)("The market is closed"),
                                                    delay: i
                                                });
                                                break;
                                            case "OpenPositionLimitExceeded":
                                                u = (0, r.kg)("You already have an open position for {{ trade_type }} contract type, retrying in {{ delay }}s", {
                                                    delay: i,
                                                    trade_type: (null == _ ? void 0 : _[p]) ? ? ""
                                                });
                                                break;
                                            default:
                                                u = (0, r.kg)("Request failed for: {{ message_type }}, retrying in {{ delay }}s", {
                                                    message_type: a || (0, r.kg)("unknown"),
                                                    delay: i
                                                })
                                        } else u = (0, r.kg)("Request failed for: {{ message_type }}, retrying in {{ delay }}s", {
                                            message_type: a || (0, r.kg)("unknown"),
                                            delay: i
                                        });
                                        return (0, n.z3)(u), 1e3 * i
                                    })(e, l)),
                                    d = i(),
                                    u = (0, s.WeW)(e, "msg_type");
                                d[c] = {
                                    is_cancellable: ["buy"].includes(u),
                                    msg_type: u
                                }, a.P.setState({
                                    global_timeouts: d
                                })
                            }))
                        }) : d()
                    }),
                    _ = (e, t, i) => {
                        let s = 1;
                        return new Promise((o, r) => {
                            let a = (e, t) => {
                                    s++, t().then(n)
                                },
                                n = () => {
                                    p(e, a, t, s, i).then(o).catch(r)
                                };
                            n()
                        })
                    },
                    g = e => {
                        let {
                            sell_price: t,
                            buy_price: i,
                            currency: o
                        } = e, r = (0, s.F0v)(t - i, o);
                        return [e.transaction_ids.buy, +e.buy_price, +e.sell_price, r, e.contract_type, (0, s.fUm)(parseInt(`${e.entry_tick_time}000`), "HH:mm:ss"), +e.entry_tick, (0, s.fUm)(parseInt(`${e.exit_tick_time}000`), "HH:mm:ss"), +e.exit_tick, +(e.barrier ? e.barrier : 0), r < 0 ? "loss" : "win"]
                    },
                    m = () => `${new Date().getTime()*Math.random()}`,
                    y = () => ({
                        has_payout_block: window.Blockly.derivWorkspace.getAllBlocks().some(e => "payout" === e.type && !!e.parentBlock_),
                        is_basis_payout: !1
                    }),
                    f = {
                        [WebSocket.CONNECTING]: "Connecting",
                        [WebSocket.OPEN]: "Connected",
                        [WebSocket.CLOSING]: "Closing",
                        [WebSocket.CLOSED]: "Closed"
                    }
            },
            15647(e, t, i) {
                "use strict";
                i.d(t, {
                    c: () => r
                });
                var s = i(95526);
                let o = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "workspace";
                        return {
                            missing: (0, s.kg)("The {{block_type}} block is mandatory and cannot be deleted/disabled.", {
                                block_type: e
                            }),
                            misplaced: (0, s.kg)("The {{block_type}} block is misplaced from {{missing_space}}.", {
                                block_type: e,
                                missing_space: t
                            }),
                            disabled: (0, s.kg)("The {{block_type}} block is mandatory and cannot be deleted/disabled.", {
                                block_type: e
                            }),
                            default: (0, s.kg)("The {{block_type}} block is mandatory and cannot be deleted/disabled.", {
                                block_type: e
                            })
                        }
                    },
                    r = () => ({
                        trade_definition: o("Trade parameters"),
                        trade_parameters: o("Trade parameters"),
                        before_purchase: o("Purchase conditions"),
                        purchase_conditions: o("Purchase conditions"),
                        purchase: o("Purchase", "purchase conditions"),
                        trade_definition_tradeoptions: o("Trade options", "trade parameters"),
                        trade_definition_multiplier: o("Trade options multipliers", "trade parameters"),
                        trade_definition_accumulator: o("Trade options accumulators", "trade parameters")
                    })
            },
            95388(e, t, i) {
                "use strict";
                i.d(t, {
                    $: () => o,
                    A: () => r
                });
                var s = i(68034);
                let o = (e, t) => {
                        let i = Error(t);
                        return i.name = e, i.code = e, i
                    },
                    r = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        s.P.emit("ui.log.error", e), window.trackJs && trackJs.track(`${e} - Error: ${JSON.stringify(t)}`)
                    }
            },
            31406(e, t, i) {
                "use strict";
                i.d(t, {
                    r7: () => m.r7,
                    _l: () => a,
                    H4: () => _,
                    $5: () => l.$,
                    K3: () => p,
                    Gi: () => h,
                    dh: () => m.dh,
                    hd: () => s.h,
                    _D: () => n,
                    Xz: () => m.Xz,
                    bB: () => f,
                    EB: () => m.EB,
                    hS: () => v,
                    JH: () => g,
                    PA: () => d.P,
                    Yp: () => b,
                    AJ: () => l.A,
                    Fs: () => y,
                    Ry: () => w.Ry
                });
                var s = i(11771),
                    o = i(95526),
                    r = i(20332);
                let a = e => {
                        let {
                            opposites: t
                        } = (0, r.$)(), i = (0, o.kg)("Unknown");
                        return Object.keys(t).forEach(s => {
                            t[s].forEach(t => {
                                let o = Object.entries(t)[0];
                                if (o[0] === e.contract_type) {
                                    if (["CALL", "PUT"].includes(o[0])) {
                                        let t = e.shortcode.split("_").slice(-2)[0];
                                        if (s !== (/^S0P$/.test(t) ? "CALLPUT" : "HIGHERLOWER")) return
                                    }
                                    i = o[1]
                                }
                            })
                        }), i
                    },
                    n = e => {
                        let t = new Date,
                            i = (t.getTime() - e) / 1e3;
                        if (i < 60) return (0, o.kg)("{{secondPast}}s ago", {
                            secondPast: parseInt(i)
                        });
                        if (i < 3600) return (0, o.kg)("{{minutePast}}m ago", {
                            minutePast: parseInt(i / 60)
                        });
                        if (i <= 86400) return (0, o.kg)("{{hourPast}}h ago", {
                            hourPast: parseInt(i / 3600)
                        });
                        let s = new Date(e),
                            r = s.getDate(),
                            a = s.toDateString().match(/ [a-zA-Z]*/)[0].replace(" ", ""),
                            n = `${s.getFullYear()===t.getFullYear()?"":" "}${s.getFullYear()}`;
                        return `${r} ${a}${n}`
                    };
                var l = i(95388),
                    c = i(15647),
                    d = i(68034);
                let u = e => {
                        null !== window.Blockly.getSelected() && null === window.Blockly.getSelected().parentBlock_ && ("Delete" === e.key || "Backspace" === e.key) && _("BLOCK_DELETION", d.P)
                    },
                    h = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "keydown";
                        window.removeEventListener(e, u)
                    },
                    p = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "keydown";
                        window.addEventListener(e, u)
                    },
                    _ = (e, t) => {
                        if ("BLOCK_DELETION" === e) {
                            var i, s, o;
                            (null === c.c || void 0 === c.c || null == (i = (0, c.c)()) ? void 0 : i[window.Blockly.getSelected().type]) && t.emit("ui.log.error", null === c.c || void 0 === c.c || null == (o = (0, c.c)()) || null == (s = o[window.Blockly.getSelected().type]) ? void 0 : s.default)
                        }
                    },
                    g = e => new Promise((t, i) => {
                        let s = document.createElement("script");
                        s.src = e, s.async = !0, s.onload = () => t(window.external_global_component), s.onerror = i, document.body.appendChild(s)
                    });
                var m = i(55477);
                let y = function() {
                        for (var e = arguments.length, t = Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                        return e => t.reduce((e, t) => t(e), e)
                    },
                    f = e => Array.from(new DOMParser().parseFromString(e, "text/xml").getElementsByTagName("block")).map(e => ({
                        type: e.getAttribute("type"),
                        fields: Array.from(e.getElementsByTagName("field")).map(e => ({
                            name: e.getAttribute("name"),
                            value: e.textContent.trim()
                        }))
                    })),
                    b = e => e.sort((e, t) => e.type < t.type ? -1 : e.type > t.type ? 1 : JSON.stringify(e.fields) < JSON.stringify(t.fields) ? -1 : 1),
                    k = (e, t) => {
                        if ((null == e ? void 0 : e.length) !== (null == t ? void 0 : t.length)) return !1;
                        for (let a = 0; a < e.length; a++) {
                            var i, s, o, r;
                            if ((null == (i = e[a]) ? void 0 : i.name) !== (null == (s = t[a]) ? void 0 : s.name) || (null == (o = e[a]) ? void 0 : o.value) !== (null == (r = t[a]) ? void 0 : r.value)) return !1
                        }
                        return !0
                    },
                    v = (e, t) => {
                        let i = y(f, b),
                            s = y(f, b),
                            o = i(e),
                            r = s(t);
                        if ((null == o ? void 0 : o.length) !== (null == r ? void 0 : r.length)) return !1;
                        for (let e = 0; e < o.length; e++) {
                            var a, n, l, c;
                            if ((null == (a = o[e]) ? void 0 : a.type) !== (null == (n = r[e]) ? void 0 : n.type) || !k(null == (l = o[e]) ? void 0 : l.fields, null == (c = r[e]) ? void 0 : c.fields)) return !1
                        }
                        return !0
                    };
                var w = i(39571)
            },
            55477(e, t, i) {
                "use strict";
                i.d(t, {
                    EB: () => u,
                    Xz: () => p,
                    dh: () => d,
                    r7: () => h
                });
                var s = i(73790),
                    o = i.n(s),
                    r = i(32992),
                    a = i.n(r),
                    n = i(28132),
                    l = i(75372),
                    c = i(69824);
                let d = async function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : l.e.UNSAVED,
                            i = p(e);
                        e.setAttribute("is_dbot", !0);
                        let {
                            load_modal: {
                                updateListStrategies: s
                            },
                            save_modal: r
                        } = c.A.instance, d = window.Blockly.derivWorkspace.current_strategy_id || window.Blockly.utils.idGenerator.genUid(), h = await u(), _ = Blockly.Xml.domToText(i), g = Date.now(), m = h.findIndex(e => e.id === d);
                        if (m >= 0) {
                            let e = h[m];
                            e.xml = _, e.name = r.bot_name, e.timestamp = g, e.save_type = t
                        } else h.push({
                            id: d,
                            timestamp: g,
                            name: r.bot_name || (0, n.$W)().default_file_name,
                            xml: _,
                            save_type: t
                        });
                        h.sort((e, t) => new Date(e.timestamp) - new Date(t.timestamp)).reverse(), h.length > 10 && h.pop(), s(h), o().setItem("saved_workspaces", a().compress(JSON.stringify(h)))
                    },
                    u = async () => {
                        try {
                            return JSON.parse(a().decompress(await o().getItem("saved_workspaces"))) || []
                        } catch (e) {
                            return []
                        }
                    },
                    h = async e => {
                        let t = await u(),
                            i = t.findIndex(t => t.id === e);
                        i >= 0 && t.splice(i, 1), await o().setItem("saved_workspaces", a().compress(JSON.stringify(t)))
                    },
                    p = e => {
                        if (e) return e.hasAttribute("collection") && "true" === e.getAttribute("collection") && e.setAttribute("collection", "true"), e.setAttribute("is_dbot", "true"), e
                    }
            },
            68034(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => o,
                    P: () => r
                });
                var s = i(49568);
                class o {
                    register(e, t, i, o, r) {
                        var a = this;
                        r && this.unregisterAll(e);
                        let n = e => {
                            e.type === o.type && (this.unregister("api.error", n), o.unregister.forEach(e => {
                                e instanceof Array ? this.unregister(...e) : this.unregisterAll(e)
                            }))
                        };
                        o && this.register("api.error", n);
                        let l = function() {
                                for (var s = arguments.length, r = Array(s), l = 0; l < s; l++) r[l] = arguments[l];
                                i && a.unregister(e, t), o && a.unregister("api.error", n), t(...r)
                            },
                            c = this.eam.get(e);
                        this.eam = c ? this.eam.set(e, c.push({
                            action: l,
                            searchBy: t
                        })) : this.eam.set(e, new s.B8().push({
                            action: l,
                            searchBy: t
                        }))
                    }
                    unregister(e, t) {
                        this.eam = this.eam.set(e, this.eam.get(e).filter(e => e.searchBy !== t))
                    }
                    isRegistered(e) {
                        return this.eam.has(e)
                    }
                    unregisterAll(e) {
                        this.eam = this.eam.delete(e)
                    }
                    emit(e, t) {
                        this.eam.has(e) && this.eam.get(e).forEach(e => e.action(t))
                    }
                    setState() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        this.state = { ...this.state,
                            ...e
                        }
                    }
                    getState(e) {
                        var t;
                        return null == (t = this.state) ? void 0 : t[e]
                    }
                    constructor() {
                        this.eam = new s.T5
                    }
                }
                let r = new o
            },
            59673(e, t, i) {
                "use strict";

                function s() {
                    let e, t, i = new Promise((i, s) => {
                        e = i, t = s
                    });
                    return i.isPending = !0, i.resolve = t => {
                        i.isPending = !1, e(t)
                    }, i.reject = e => {
                        i.isPending = !1, t(e)
                    }, i
                }
                i.d(t, {
                    A: () => s
                })
            },
            39571(e, t, i) {
                "use strict";
                i.d(t, {
                    Qq: () => a,
                    Ry: () => o,
                    nw: () => r
                });
                var s = i(20332);
                let o = () => {
                        let e = window.Blockly.derivWorkspace;
                        e && document.getElementById("scratch_div") && window.Blockly.svgResize(e)
                    },
                    r = (e, t) => {
                        (Array.isArray(t) ? t : [t]).forEach(t => {
                            (0, s.$)().single_instance_blocks.includes(t) && e.getAllBlocks().forEach(e => {
                                e.type === t && e.dispose()
                            })
                        })
                    },
                    a = () => "rtl" === document.documentElement.getAttribute("dir")
            },
            92424(e, t, i) {
                "use strict";
                i.d(t, {
                    $: () => l
                });
                var s = i(96540),
                    o = i(18987),
                    r = i(26008),
                    a = i(58826),
                    n = i(33172);
                let l = function() {
                    let {
                        handleLogout: e,
                        client: t
                    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, [i, l] = (0, s.useState)(!1), c = window.location.pathname.includes("callback") || window.location.pathname.includes("endpoint");
                    return (0, s.useEffect)(() => {
                        window.addEventListener("unhandledrejection", e => {
                            var t, i;
                            (null == e || null == (i = e.reason) || null == (t = i.error) ? void 0 : t.code) === "InvalidToken" && l(!1)
                        })
                    }, []), (0, s.useEffect)(() => {
                        let e = () => {
                            try {
                                if ("true" === sessionStorage.getItem("is_switching_account")) return;
                                let e = JSON.parse(localStorage.getItem("accountsList") ? ? "{}"),
                                    t = Object.keys(e).length > 0,
                                    i = o.A.get("logged_state");
                                if ("true" !== i && "false" !== i) return;
                                c || ("true" !== i || t) && ("false" !== i || !t) ? l(!1) : l(!0)
                            } catch (e) {
                                console.warn("Error checking login state:", e)
                            }
                        };
                        e();
                        let t = t => {
                                ("accountsList" === t.key || null === t.key) && e()
                            },
                            i = setInterval(e, 3e3);
                        return window.addEventListener("storage", t), () => {
                            clearInterval(i), window.removeEventListener("storage", t)
                        }
                    }, [c]), {
                        oAuthLogout: async () => {
                            null == t || t.setIsLoggingOut(!0);
                            let i = !1;
                            try {
                                await (0, a.m0)({
                                    redirectCallbackUri: `${window.location.origin}/callback`,
                                    WSLogoutAndRedirect: async () => {
                                        try {
                                            await (e ? ? (() => Promise.resolve()))(), i = !0, l(!1)
                                        } catch (e) {
                                            throw console.error("Error in handleLogout:", e), i = !0, null == t || t.setIsLoggingOut(!1), l(!1), e
                                        }
                                    },
                                    postLogoutRedirectUri: window.location.origin
                                }).catch(s => {
                                    console.error("Error in OAuth2Logout:", s), i || (null == t || t.setIsLoggingOut(!1), l(!1), e ? e().catch(() => {}) : ((0, r.Md)(), window.location.reload()))
                                })
                            } catch (s) {
                                console.error("Error in logoutHandler:", s), i || (null == t || t.setIsLoggingOut(!1), l(!1), e ? e().catch(() => {}) : ((0, r.Md)(), window.location.reload()))
                            }
                        },
                        retriggerOAuth2Login: async () => {
                            try {
                                (0, n.C)() && await (0, a.ZF)({
                                    redirectCallbackUri: `${window.location.origin}/callback`,
                                    postLogoutRedirectUri: window.location.origin
                                }).catch(e => {
                                    console.error("Error during OAuth2 login retrigger:", e)
                                })
                            } catch (e) {
                                console.error("Error during OAuth2 login retrigger:", e)
                            }
                        },
                        isSingleLoggingIn: i
                    }
                }
            },
            17605(e, t, i) {
                "use strict";
                i.d(t, {
                    d: () => r
                });
                var s = i(96540),
                    o = i(32745);
                let r = () => {
                    let [e, t] = (0, s.useState)("unknown"), [i, r] = (0, s.useState)(!1), [a, n] = (0, s.useState)(!1), [l, c] = (0, s.useState)([]), [d, u] = (0, s.useState)(null), [h, p] = (0, s.useState)("");
                    return (0, s.useEffect)(() => {
                        let e = o.xi.subscribe(e => {
                                t(e)
                            }),
                            i = o.uw.subscribe(e => {
                                r(e)
                            }),
                            s = o.XH.subscribe(e => {
                                n(e)
                            }),
                            a = o.P4.subscribe(e => {
                                c(e)
                            }),
                            l = o.HN.subscribe(e => {
                                u(e), p((null == e ? void 0 : e.loginid) ? ? "")
                            });
                        return () => {
                            e.unsubscribe(), i.unsubscribe(), s.unsubscribe(), a.unsubscribe(), l.unsubscribe()
                        }
                    }, []), {
                        connectionStatus: e,
                        isAuthorized: i,
                        isAuthorizing: a,
                        accountList: l,
                        authData: d,
                        activeLoginid: h
                    }
                }
            },
            71699(e, t, i) {
                "use strict";
                i.d(t, {
                    W: () => a
                });
                var s = i(96540);
                let o = "undefined" != typeof window ? s.useLayoutEffect : s.useEffect,
                    r = function(e, t, i, r) {
                        let a = (0, s.useRef)(t);
                        o(() => {
                            a.current = t
                        }, [t]), (0, s.useEffect)(() => {
                            let t, s;
                            return t = (null == i ? void 0 : i.current) ? ? window, s = e => a.current(e), (null == t ? void 0 : t.addEventListener) && t.addEventListener(e, s, r), () => {
                                null == t || t.removeEventListener(e, s, r)
                            }
                        }, [e, i, r])
                    };

                function a(e, t, i) {
                    let s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "mousedown";
                    r(s, s => {
                        let o = null == e ? void 0 : e.current;
                        !o || o.contains(s.target) || (!i || i(s)) && t(s)
                    })
                }
            },
            33718(e, t, i) {
                "use strict";
                i.d(t, {
                    tv: () => ty,
                    Pj: () => tf
                });
                var s = {};
                i.r(s), i.d(s, {
                    after_purchase: () => H,
                    balance: () => F,
                    before_purchase: () => W,
                    check_direction: () => $,
                    console: () => X,
                    contract_check_result: () => G,
                    controls_flow_statements: () => V,
                    controls_for: () => q,
                    controls_forEach: () => Y,
                    controls_if: () => z,
                    controls_whileUntil: () => K,
                    during_purchase: () => J,
                    epoch: () => Q,
                    get_ohlc: () => Z,
                    is_candle_black: () => ee,
                    last_digit: () => et,
                    logic_operation: () => ei,
                    math_arithmetic: () => es,
                    math_constrain: () => eo,
                    math_single: () => er,
                    notify_telegram: () => ea,
                    ohlc: () => en,
                    ohlc_values: () => el,
                    ohlc_values_in_list: () => ec,
                    procedures_ifreturn: () => ed,
                    read_details: () => eu,
                    read_ohlc: () => eh,
                    read_ohlc_obj: () => ep,
                    sell_at_market: () => e_,
                    sell_price: () => eg,
                    sma_statement: () => em,
                    text_print: () => ey,
                    text_prompt_ext: () => ef,
                    tick_analysis: () => eb,
                    todatetime: () => ek,
                    totimestamp: () => ev,
                    trade_again: () => ew,
                    trade_definition: () => eT,
                    trade_definition_multiplier: () => eI,
                    trade_definition_tradeoptions: () => eE,
                    variables_set: () => ex
                });
                var o = i(74848),
                    r = i(96540),
                    a = i(50467),
                    n = i(18987),
                    l = i(27813),
                    c = i(22998),
                    d = i(28176),
                    u = i(67774),
                    h = i(78479),
                    p = i(95526);
                class _ {
                    constructor(e, t) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "core", void 0), (0, a._)(this, "dbot_store", void 0), (0, a._)(this, "api_helpers_store", void 0), (0, a._)(this, "timer", void 0), (0, a._)(this, "disposeReloadOnLanguageChangeReaction", void 0), (0, a._)(this, "disposeCurrencyReaction", void 0), (0, a._)(this, "disposeSwitchAccountListener", void 0), (0, a._)(this, "disposeLandingCompanyChangeReaction", void 0), (0, a._)(this, "disposeResidenceChangeReaction", void 0), (0, a._)(this, "getErrorForNonEuClients", () => ({
                            text: (0, p.kg)("Unfortunately, this trading platform is not available for EU Deriv account. Please switch to a non-EU account to continue trading."),
                            title: (0, p.kg)("Defen Traders is unavailable for this account"),
                            link: (0, p.kg)("Switch to another account")
                        })), (0, a._)(this, "getErrorForEuClients", function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
                            return {
                                text: " ",
                                title: e ? (0, p.kg)(`Defen Traders is not available for ${t||"EU"} clients`) : (0, p.kg)(`Defen Traders is unavailable in ${t||"the EU"}`),
                                link: e ? (0, p.kg)("Back to Trader's Hub") : (0, p.kg)("Refresh"),
                                route: d.fv.traders_hub
                            }
                        }), (0, a._)(this, "throwErrorForExceptionCountries", e => {
                            let {
                                client: t,
                                common: i
                            } = this.core, s = { ...(0, c.Kg)()
                            }[e];
                            if (s) return (0, d.Qsi)(i.showError, this.getErrorForEuClients(t.is_logged_in, s))
                        }), (0, a._)(this, "handleErrorForEu", () => {
                            var e;
                            let {
                                client: t,
                                common: i
                            } = this.core;
                            return "/callback" === window.location.pathname || "true" === n.A.get("logged_state") && 0 === Object.keys(JSON.parse(localStorage.getItem("accountsList") || "{}")).length ? (i.setError(!1, {}), !1) : !(null == t ? void 0 : t.is_logged_in) && (null == t ? void 0 : t.is_eu_country) ? (this.throwErrorForExceptionCountries(null == t ? void 0 : t.clients_country), (0, d.Qsi)(i.showError, this.getErrorForEuClients())) : t.is_landing_company_loaded ? (this.throwErrorForExceptionCountries(null == t || null == (e = t.account_settings) ? void 0 : e.clients_country), t.should_show_eu_error) ? (0, d.Qsi)(i.showError, this.getErrorForEuClients(t.is_logged_in)) : t.content_flag === d.CmZ.HIGH_RISK_CR ? (i.setError(!1, {}), !1) : t.content_flag === d.CmZ.LOW_RISK_CR_EU || !t.is_bot_allowed && t.is_eu && t.should_show_eu_error || (0, d.EaA)(t.active_accounts) || t.is_options_blocked ? (0, d.Qsi)(i.showError, this.getErrorForNonEuClients(), () => {
                                var e;
                                null == (e = document.querySelector(".deriv-account-switcher__button")) || e.click()
                            }, !1, !1) : (i.setError(!1, {}), !1) : (i.setError(!1, {}), !1)
                        }), (0, a._)(this, "onMount", async () => {
                            let {
                                blockly_store: e,
                                run_panel: t
                            } = this.root_store, {
                                client: i,
                                ui: s
                            } = this.core;
                            this.showDigitalOptionsMaltainvestError();
                            let o = 1;
                            this.timer = setInterval(() => {
                                window.sendRequestsStatistic && (window.sendRequestsStatistic(!1), performance.clearMeasures(), 6 === o || (null == t ? void 0 : t.is_running) ? this.timer && clearInterval(this.timer) : o++)
                            }, 1e4), this.dbot_store && (e.setLoading(!0), await u.DBot.initWorkspace("/", this.dbot_store, this.api_helpers_store, s.is_mobile, !1), e.setContainerSize(), e.setLoading(!1), this.registerCurrencyReaction.call(this), this.registerOnAccountSwitch.call(this), this.registerLandingCompanyChangeReaction.call(this), this.registerResidenceChangeReaction.call(this), window.addEventListener("click", this.onClickOutsideBlockly), e.getCachedActiveTab(), (0, l.z7)(() => (null == i ? void 0 : i.should_show_eu_error) || (null == i ? void 0 : i.is_landing_company_loaded), () => this.showDigitalOptionsMaltainvestError()), (0, l.mJ)(() => null == i ? void 0 : i.content_flag, () => this.showDigitalOptionsMaltainvestError()))
                        }), (0, a._)(this, "onUnmount", () => {
                            var e, t, i;
                            u.DBot.terminateBot(), u.DBot.terminateConnection(), (null == (e = window.Blockly) ? void 0 : e.derivWorkspace) && (clearInterval(null == (t = window.Blockly) ? void 0 : t.derivWorkspace.save_workspace_interval), null == (i = window.Blockly.derivWorkspace) || i.dispose()), "function" == typeof this.disposeReloadOnLanguageChangeReaction && this.disposeReloadOnLanguageChangeReaction(), "function" == typeof this.disposeCurrencyReaction && this.disposeCurrencyReaction(), "function" == typeof this.disposeSwitchAccountListener && this.disposeSwitchAccountListener(), "function" == typeof this.disposeLandingCompanyChangeReaction && this.disposeLandingCompanyChangeReaction(), "function" == typeof this.disposeResidenceChangeReaction && this.disposeResidenceChangeReaction(), window.removeEventListener("click", this.onClickOutsideBlockly);
                            let {
                                ui: s
                            } = this.core;
                            s.setAccountSwitcherDisabledMessage(), s.setPromptHandler(!1), this.timer && clearInterval(this.timer), performance.clearMeasures()
                        }), (0, a._)(this, "registerCurrencyReaction", () => {
                            this.disposeCurrencyReaction = (0, l.mJ)(() => this.core.client.currency, () => {
                                var e, t;
                                (null == (e = window.Blockly) ? void 0 : e.derivWorkspace) && (null == (t = window.Blockly) ? void 0 : t.derivWorkspace.getAllBlocks().filter(e => "trade_definition_tradeoptions" === e.type || "trade_definition_multiplier" === e.type || "trade_definition_accumulator" === e.type || e.isDescendantOf("trade_definition_multiplier") && "trade_parameters" === e.category_)).forEach(e => (0, h.MN)(e))
                            })
                        }), (0, a._)(this, "registerOnAccountSwitch", () => {
                            this.disposeSwitchAccountListener = (0, l.mJ)(() => {
                                var e;
                                return null == (e = this.root_store.common) ? void 0 : e.is_socket_opened
                            }, e => {
                                var t, i, s;
                                if (!e) return;
                                this.api_helpers_store = {
                                    server_time: this.root_store.common.server_time,
                                    ws: u.api_base.api
                                }, (null === u.ApiHelpers || void 0 === u.ApiHelpers ? void 0 : u.ApiHelpers.instance) || u.ApiHelpers.setInstance(this.api_helpers_store), this.showDigitalOptionsMaltainvestError();
                                let o = null === u.ApiHelpers || void 0 === u.ApiHelpers || null == (t = u.ApiHelpers.instance) ? void 0 : t.active_symbols,
                                    r = null === u.ApiHelpers || void 0 === u.ApiHelpers || null == (i = u.ApiHelpers.instance) ? void 0 : i.contracts_for;
                                (null === u.ApiHelpers || void 0 === u.ApiHelpers ? void 0 : u.ApiHelpers.instance) && o && r && ((null == (s = window.Blockly) ? void 0 : s.derivWorkspace) && (null == o || o.retrieveActiveSymbols(!0).then(() => {
                                    var e;
                                    r.disposeCache(), null == (e = window.Blockly) || e.derivWorkspace.getAllBlocks().filter(e => "trade_definition_market" === e.type).forEach(e => {
                                        (0, u.runIrreversibleEvents)(() => {
                                            let t = new window.Blockly.Events.BlockCreate(e);
                                            window.Blockly.Events.fire(t)
                                        })
                                    })
                                })), u.DBot.initializeInterpreter())
                            })
                        }), (0, a._)(this, "registerLandingCompanyChangeReaction", () => {
                            let {
                                client: e
                            } = this.core;
                            this.disposeLandingCompanyChangeReaction = (0, l.mJ)(() => e.landing_company_shortcode, () => this.handleErrorForEu())
                        }), (0, a._)(this, "registerResidenceChangeReaction", () => {
                            let {
                                client: e
                            } = this.core;
                            this.disposeResidenceChangeReaction = (0, l.mJ)(() => {
                                var t;
                                return null == (t = e.account_settings) ? void 0 : t.country_code
                            }, () => this.handleErrorForEu())
                        }), (0, a._)(this, "setDBotEngineStores", () => {
                            let {
                                flyout: e,
                                toolbar: t,
                                save_modal: i,
                                dashboard: s,
                                load_modal: o,
                                run_panel: r,
                                blockly_store: a,
                                summary_card: n
                            } = this.root_store, {
                                client: l,
                                common: c
                            } = this.core, {
                                handleFileChange: d
                            } = o, {
                                setLoading: h
                            } = a, {
                                setContractUpdateConfig: p
                            } = n, {
                                ui: {
                                    is_mobile: _
                                }
                            } = this.core;
                            this.dbot_store = {
                                client: l,
                                flyout: e,
                                toolbar: t,
                                save_modal: i,
                                dashboard: s,
                                load_modal: o,
                                run_panel: r,
                                setLoading: h,
                                setContractUpdateConfig: p,
                                handleFileChange: d,
                                is_mobile: _,
                                common: c
                            }, this.api_helpers_store = {
                                server_time: this.core.common.server_time,
                                ws: u.api_base.api
                            }
                        }), (0, a._)(this, "onClickOutsideBlockly", e => {
                            if (document.querySelector(".injectionDiv") && !(e.path || e.composedPath && e.composedPath()).some(e => e.classList && e.classList.contains("injectionDiv"))) {
                                var t;
                                null == (t = window.Blockly) || t.hideChaff(!1)
                            }
                        }), (0, a._)(this, "showDigitalOptionsMaltainvestError", () => {
                            this.handleErrorForEu(!0)
                        }), (0, l.Gn)(this, {
                            onMount: l.XI,
                            onUnmount: l.XI,
                            registerCurrencyReaction: l.XI,
                            registerOnAccountSwitch: l.XI,
                            registerLandingCompanyChangeReaction: l.XI,
                            registerResidenceChangeReaction: l.XI,
                            setDBotEngineStores: l.XI,
                            onClickOutsideBlockly: l.XI,
                            showDigitalOptionsMaltainvestError: l.XI
                        }), this.root_store = e, this.core = t, this.dbot_store = null, this.api_helpers_store = null, this.timer = null
                    }
                }
                var g = i(61944),
                    m = i(42643);
                class y {
                    get has_active_bot() {
                        var e;
                        let t = null == (e = window.Blockly) ? void 0 : e.derivWorkspace;
                        if (!t) return !1;
                        let i = t.getTopBlocks();
                        return i && i.length > 0
                    }
                    get has_saved_bots() {
                        return this._has_saved_bots
                    }
                    constructor(e) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "is_loading", !1), (0, a._)(this, "active_tab", g.CU.WORKSPACE), (0, a._)(this, "_has_saved_bots", !1), (0, a._)(this, "checkForSavedBots", async () => {
                            try {
                                let e = await (0, u.getSavedWorkspaces)();
                                this._has_saved_bots = Array.isArray(e) && e.length > 0
                            } catch (e) {
                                console.error("Error checking for saved workspaces:", e), this._has_saved_bots = !1
                            }
                        }), (0, a._)(this, "setActiveTab", e => {
                            this.active_tab = e, (0, m.Gf)("active_tab", this.active_tab)
                        }), (0, a._)(this, "setContainerSize", () => {
                            this.active_tab === g.CU.WORKSPACE && (0, u.onWorkspaceResize)()
                        }), (0, a._)(this, "onMount", () => {
                            window.addEventListener("resize", this.setContainerSize), this.checkForSavedBots()
                        }), (0, a._)(this, "getCachedActiveTab", () => {
                            (0, m.PL)("active_tab") && (this.active_tab = (0, m.PL)("active_tab"))
                        }), (0, a._)(this, "onUnmount", () => {
                            window.removeEventListener("resize", this.setContainerSize)
                        }), (0, a._)(this, "setLoading", e => {
                            this.is_loading = e
                        }), (0, l.Gn)(this, {
                            is_loading: l.sH,
                            active_tab: l.sH,
                            _has_saved_bots: l.sH,
                            has_active_bot: l.EW,
                            has_saved_bots: l.EW,
                            setLoading: l.XI,
                            setActiveTab: l.XI,
                            checkForSavedBots: l.XI
                        }), this.root_store = e
                    }
                }
                class f {
                    get is_contract_ended() {
                        let {
                            transactions: e
                        } = this.root_store;
                        return e.contracts.length > 0 && e.contracts[0].is_ended
                    }
                    constructor(e) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "subscription", {
                            id: null,
                            subscriber: null
                        }), (0, a._)(this, "chart_subscription_id", ""), (0, a._)(this, "symbol", void 0), (0, a._)(this, "is_chart_loading", void 0), (0, a._)(this, "chart_type", void 0), (0, a._)(this, "granularity", void 0), (0, a._)(this, "onStartBot", () => {
                            this.updateSymbol()
                        }), (0, a._)(this, "onStopBot", () => {}), (0, a._)(this, "updateSymbol", () => {
                            var e;
                            let t = window.Blockly.derivWorkspace,
                                i = null == t ? void 0 : t.getAllBlocks().find(e => "trade_definition_market" === e.type),
                                s = (null == i ? void 0 : i.getFieldValue("SYMBOL_LIST")) ? ? (null === u.api_base || void 0 === u.api_base || null == (e = u.api_base.active_symbols["0"]) ? void 0 : e.symbol);
                            this.symbol = s
                        }), (0, a._)(this, "onSymbolChange", e => {
                            this.symbol = e, this.saveToLocalStorage()
                        }), (0, a._)(this, "updateGranularity", e => {
                            this.granularity = e, this.saveToLocalStorage()
                        }), (0, a._)(this, "updateChartType", e => {
                            this.chart_type = e, this.saveToLocalStorage()
                        }), (0, a._)(this, "setChartStatus", e => {
                            this.is_chart_loading = e
                        }), (0, a._)(this, "saveToLocalStorage", () => {
                            d.Vse.set("bot.chart_props", JSON.stringify({
                                symbol: this.symbol,
                                granularity: this.granularity,
                                chart_type: this.chart_type
                            }))
                        }), (0, a._)(this, "restoreFromStorage", () => {
                            try {
                                let e = d.Vse.get("bot.chart_props");
                                if (e) {
                                    let {
                                        symbol: t,
                                        granularity: i,
                                        chart_type: s
                                    } = JSON.parse(e);
                                    this.symbol = t, this.granularity = i, this.chart_type = s
                                } else this.granularity = 0, this.chart_type = "line"
                            } catch {
                                d.Vse.remove("bot.chart_props")
                            }
                        }), (0, a._)(this, "getMarketsOrder", e => {
                            let t = "synthetic_index",
                                i = !!e.find(e => e.market === t);
                            return e.slice().sort((e, t) => e.display_name < t.display_name ? -1 : 1).map(e => e.market).reduce((e, t) => (-1 === e.indexOf(t) && e.push(t), e), i ? [t] : [])
                        }), (0, a._)(this, "setChartSubscriptionId", e => {
                            this.chart_subscription_id = e
                        }), (0, l.Gn)(this, {
                            symbol: l.sH,
                            is_chart_loading: l.sH,
                            chart_type: l.sH,
                            granularity: l.sH,
                            is_contract_ended: l.EW,
                            updateSymbol: l.XI,
                            onSymbolChange: l.XI,
                            updateGranularity: l.XI,
                            updateChartType: l.XI,
                            setChartStatus: l.XI,
                            restoreFromStorage: l.XI,
                            chart_subscription_id: l.sH,
                            setChartSubscriptionId: l.XI
                        }), this.root_store = e;
                        const {
                            run_panel: t
                        } = e;
                        (0, l.mJ)(() => t.is_running, () => t.is_running ? this.onStartBot() : this.onStopBot()), this.restoreFromStorage()
                    }
                }
                var b = i(29123),
                    k = i(32745),
                    v = i(26008);
                let w = /^maltainvest$/,
                    T = /^mt$/;
                class S {
                    get active_accounts() {
                        return this.accounts instanceof Object ? Object.values(this.accounts).filter(e => !e.is_disabled) : []
                    }
                    get clients_country() {
                        var e;
                        return null == (e = this.website_status) ? void 0 : e.clients_country
                    }
                    get is_bot_allowed() {
                        return this.isBotAllowed()
                    }
                    get is_trading_experience_incomplete() {
                        var e, t;
                        return null == (t = this.account_status) || null == (e = t.status) ? void 0 : e.some(e => "trading_experience_not_complete" === e)
                    }
                    get is_eu() {
                        if (!this.landing_companies) return !1;
                        let {
                            gaming_company: e,
                            financial_company: t,
                            mt_gaming_company: i
                        } = this.landing_companies, s = null == t ? void 0 : t.shortcode, o = null == e ? void 0 : e.shortcode, r = (null == i ? void 0 : i.financial.shortcode) || (null == i ? void 0 : i.swap_free.shortcode);
                        return "maltainvest" === this.landing_company_shortcode || (s || o || r ? w.test(s) && "svg" !== o || w.test(o) : T.test(this.residence))
                    }
                    get is_eu_country() {
                        var e;
                        let t = null == (e = this.website_status) ? void 0 : e.clients_country;
                        return !!t && (0, b.Bt)(t)
                    }
                    get is_low_risk() {
                        let {
                            gaming_company: e,
                            financial_company: t
                        } = this.landing_companies ? ? {};
                        return (null == t ? void 0 : t.shortcode) === "maltainvest" && (null == e ? void 0 : e.shortcode) === "svg"
                    }
                    get should_show_eu_error() {
                        return !!this.is_landing_company_loaded && this.is_eu && !this.is_low_risk
                    }
                    get landing_company_shortcode() {
                        if (this.accounts[this.loginid]) return this.accounts[this.loginid].landing_company_name
                    }
                    get residence() {
                        if (this.is_logged_in) {
                            var e;
                            return (null == (e = this.account_settings) ? void 0 : e.country_code) ? ? ""
                        }
                        return ""
                    }
                    get is_options_blocked() {
                        return (0, b.PW)(this.residence)
                    }
                    get is_multipliers_only() {
                        return (0, b.vv)(this.residence)
                    }
                    get is_eu_or_multipliers_only() {
                        return this.is_multipliers_only ? !this.is_multipliers_only : !(0, b.Bt)(this.residence)
                    }
                    get is_virtual() {
                        return !(0, d.RIy)(this.accounts) && this.accounts[this.loginid] && !!this.accounts[this.loginid].is_virtual
                    }
                    get all_loginids() {
                        return (0, d.RIy)(this.accounts) ? [] : Object.keys(this.accounts)
                    }
                    get virtual_account_loginid() {
                        return this.all_loginids.find(e => !!this.accounts[e].is_virtual)
                    }
                    get content_flag() {
                        let {
                            is_logged_in: e,
                            landing_companies: t,
                            residence: i,
                            is_landing_company_loaded: s
                        } = this;
                        if (s) {
                            let {
                                financial_company: s,
                                gaming_company: o
                            } = t ? ? {}, r = (null == s ? void 0 : s.shortcode) === "svg" || (null == o ? void 0 : o.shortcode) === "svg";
                            if (!e) return "";
                            if ((null == o || !o.shortcode) && (null == s ? void 0 : s.shortcode) === "maltainvest") return this.is_virtual ? d.CmZ.EU_DEMO : d.CmZ.EU_REAL;
                            if ((null == s ? void 0 : s.shortcode) === "maltainvest" && (null == o ? void 0 : o.shortcode) === "svg" && !this.is_virtual) return this.is_eu ? d.CmZ.LOW_RISK_CR_EU : d.CmZ.LOW_RISK_CR_NON_EU;
                            else if (((null == s ? void 0 : s.shortcode) === "svg" && (null == o ? void 0 : o.shortcode) === "svg" || r) && !this.is_virtual) return d.CmZ.HIGH_RISK_CR;
                            if ((0, b.Bt)(i)) return this.is_virtual ? d.CmZ.EU_DEMO : d.CmZ.EU_REAL;
                            if (this.is_virtual) return d.CmZ.CR_DEMO
                        }
                        return d.CmZ.LOW_RISK_CR_NON_EU
                    }
                    get is_cr_account() {
                        var e;
                        return null == (e = this.loginid) ? void 0 : e.startsWith("CR")
                    }
                    get account_open_date() {
                        if (!(0, d.RIy)(this.accounts) && this.accounts[this.loginid]) return Object.keys(this.accounts[this.loginid]).includes("created_at") ? this.accounts[this.loginid].created_at : void 0
                    }
                    setAccountStatus(e) {
                        this.account_status = e
                    }
                    setAccountSettings(e) {
                        try {
                            JSON.stringify(e) !== JSON.stringify(this.account_settings) && (this.account_settings = e)
                        } catch (e) {
                            console.error("setAccountSettings error", e)
                        }
                    }
                    updateTncStatus(e, t) {
                        try {
                            if (!this.account_settings) return;
                            let i = { ...this.account_settings,
                                tnc_status: { ...this.account_settings.tnc_status,
                                    [e]: t
                                }
                            };
                            this.setAccountSettings(i)
                        } catch (e) {
                            console.error("updateTncStatus error", e)
                        }
                    }
                    setWebsiteStatus(e) {
                        this.website_status = e
                    }
                    setLandingCompany(e) {
                        this.landing_companies = e, this.is_landing_company_loaded = !0
                    }
                    constructor() {
                        (0, a._)(this, "loginid", ""), (0, a._)(this, "account_list", []), (0, a._)(this, "balance", "0"), (0, a._)(this, "currency", "AUD"), (0, a._)(this, "is_logged_in", !1), (0, a._)(this, "account_status", void 0), (0, a._)(this, "account_settings", void 0), (0, a._)(this, "website_status", void 0), (0, a._)(this, "landing_companies", void 0), (0, a._)(this, "upgradeable_landing_companies", []), (0, a._)(this, "accounts", {}), (0, a._)(this, "is_landing_company_loaded", !1), (0, a._)(this, "all_accounts_balance", null), (0, a._)(this, "is_logging_out", !1), (0, a._)(this, "updateSelfExclusion", () => {}), (0, a._)(this, "authDataSubscription", null), (0, a._)(this, "isBotAllowed", () => {
                            if (!this.is_logged_in && this.is_eu_country) return !1;
                            let e = "maltainvest" === this.landing_company_shortcode;
                            return this.is_virtual ? this.is_eu_or_multipliers_only : !e && !this.is_options_blocked
                        }), (0, a._)(this, "setLoginId", e => {
                            this.loginid = e
                        }), (0, a._)(this, "setAccountList", e => {
                            this.accounts = {}, null == e || e.forEach(e => {
                                this.accounts[e.loginid] = e
                            }), e && (this.account_list = e)
                        }), (0, a._)(this, "setBalance", e => {
                            this.balance = e
                        }), (0, a._)(this, "setCurrency", e => {
                            this.currency = e
                        }), (0, a._)(this, "setIsLoggedIn", e => {
                            this.is_logged_in = e
                        }), (0, a._)(this, "getCurrency", () => {
                            var e;
                            return (null == (e = JSON.parse(localStorage.getItem("clientAccounts") ? ? "{}")[this.loginid]) ? void 0 : e.currency) ? ? ""
                        }), (0, a._)(this, "getToken", () => JSON.parse(localStorage.getItem("accountsList") ? ? "{}")[this.loginid] ? ? ""), (0, a._)(this, "setUpgradeableLandingCompanies", e => {
                            this.upgradeable_landing_companies = e
                        }), (0, a._)(this, "setAllAccountsBalance", e => {
                            this.all_accounts_balance = e ? ? null
                        }), (0, a._)(this, "setIsLoggingOut", e => {
                            this.is_logging_out = e
                        }), (0, a._)(this, "logout", async () => {
                            var e, t, i;
                            this.account_list = [], this.account_status = void 0, this.account_settings = void 0, this.landing_companies = void 0, this.accounts = {}, this.is_logged_in = !1, this.loginid = "", this.balance = "0", this.currency = "USD", this.is_landing_company_loaded = !1, this.all_accounts_balance = null, localStorage.removeItem("active_loginid"), localStorage.removeItem("accountsList"), localStorage.removeItem("authToken"), localStorage.removeItem("clientAccounts"), (0, k.GL)(!1), (0, k.et)([]), (0, k.vd)(null), this.setIsLoggingOut(!1), null == (t = window.LC_API) || null == (e = t.close_chat) || e.call(t), null == (i = window.LiveChatWidget) || i.call("hide"), window.Intercom && (window.Intercom("shutdown"), window.DerivInterCom.initialize({
                                hideLauncher: !0,
                                token: null
                            })), (null === u.api_base || void 0 === u.api_base ? void 0 : u.api_base.api) && u.api_base.api.disconnect(), (0, v.Md)(), window.location.reload()
                        }), this.authDataSubscription = k.HN.subscribe(e => {
                            (null == e ? void 0 : e.upgradeable_landing_companies) && this.setUpgradeableLandingCompanies(e.upgradeable_landing_companies)
                        }), (0, l.Gn)(this, {
                            account_list: l.sH,
                            account_settings: l.sH,
                            account_status: l.sH,
                            all_accounts_balance: l.sH,
                            balance: l.sH,
                            currency: l.sH,
                            is_landing_company_loaded: l.sH,
                            is_logged_in: l.sH,
                            landing_companies: l.sH,
                            loginid: l.sH,
                            upgradeable_landing_companies: l.sH,
                            website_status: l.sH,
                            is_logging_out: l.sH,
                            active_accounts: l.EW,
                            clients_country: l.EW,
                            is_bot_allowed: l.EW,
                            is_eu: l.EW,
                            is_eu_country: l.EW,
                            is_eu_or_multipliers_only: l.EW,
                            is_low_risk: l.EW,
                            is_multipliers_only: l.EW,
                            is_options_blocked: l.EW,
                            is_virtual: l.EW,
                            landing_company_shortcode: l.EW,
                            residence: l.EW,
                            should_show_eu_error: l.EW,
                            logout: l.XI,
                            setAccountList: l.XI,
                            setAccountSettings: l.XI,
                            setAccountStatus: l.XI,
                            setAllAccountsBalance: l.XI,
                            setBalance: l.XI,
                            setCurrency: l.XI,
                            setIsLoggedIn: l.XI,
                            setIsLoggingOut: l.XI,
                            setLandingCompany: l.XI,
                            setLoginId: l.XI,
                            setWebsiteStatus: l.XI,
                            setUpgradeableLandingCompanies: l.XI,
                            updateTncStatus: l.XI,
                            is_trading_experience_incomplete: l.EW,
                            is_cr_account: l.EW,
                            account_open_date: l.EW
                        })
                    }
                }
                var I = i(95093),
                    E = i.n(I),
                    x = i(2351);
                class A {
                    constructor() {
                        (0, a._)(this, "server_time", (0, x.sf)()), (0, a._)(this, "update_time_interval", void 0), (0, a._)(this, "current_language", ""), (0, a._)(this, "is_socket_opened", !1), (0, a._)(this, "error", void 0), (0, a._)(this, "has_error", !1), (0, a._)(this, "setCurrentLanguage", e => {
                            this.current_language = e
                        }), (0, a._)(this, "setServerTime", (e, t) => {
                            t || (this.server_time = e, this.update_time_interval && clearInterval(this.update_time_interval), this.update_time_interval = setInterval(() => this.updateServerTime(), 1e3))
                        }), (0, a._)(this, "updateServerTime", () => {
                            this.server_time = E()(this.server_time).add(1e3, "milliseconds")
                        }), (0, a._)(this, "setSocketOpened", e => {
                            this.is_socket_opened = e
                        }), (0, a._)(this, "setError", (e, t) => {
                            this.has_error = e, this.error = e ? {
                                type: t ? t.type : "info",
                                ...t && {
                                    header: t.header,
                                    message: t.message,
                                    redirect_label: t.redirect_label,
                                    redirectOnClick: t.redirectOnClick,
                                    should_show_refresh: t.should_show_refresh,
                                    redirect_to: t.redirect_to,
                                    should_clear_error_on_click: t.should_clear_error_on_click,
                                    should_redirect: t.should_redirect,
                                    setError: this.setError
                                }
                            } : void 0
                        }), (0, a._)(this, "showError", e => {
                            let {
                                message: t,
                                header: i,
                                redirect_label: s,
                                redirectOnClick: o,
                                should_show_refresh: r,
                                redirect_to: a,
                                should_clear_error_on_click: n,
                                should_redirect: l
                            } = e;
                            this.setError(!0, {
                                header: i,
                                message: t,
                                redirect_label: s,
                                redirectOnClick: o,
                                should_show_refresh: r,
                                redirect_to: a,
                                should_clear_error_on_click: n,
                                type: "error",
                                should_redirect: l
                            })
                        }), (0, l.Gn)(this, {
                            current_language: l.sH,
                            server_time: l.sH,
                            is_socket_opened: l.sH,
                            error: l.sH,
                            has_error: l.sH,
                            setServerTime: l.XI,
                            updateServerTime: l.XI,
                            setCurrentLanguage: l.XI,
                            setSocketOpened: l.XI,
                            setError: l.XI,
                            showError: l.XI
                        })
                    }
                }
                var C = i(99418),
                    R = i(88332),
                    O = i(71036),
                    D = i(3673),
                    B = i(67212),
                    L = i(15292);
                class P {
                    get is_dark_mode() {
                        let {
                            app: {
                                core: {
                                    ui: {
                                        is_dark_mode_on: e
                                    }
                                }
                            }
                        } = this.root_store;
                        return e
                    }
                    initInfoPanel() {
                        localStorage.getItem("dbot_should_show_info") || (this.is_info_panel_visible = !0)
                    }
                    constructor(e, t) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "core", void 0), (0, a._)(this, "tutorials_combined_content", []), (0, a._)(this, "combined_search", []), (0, a._)(this, "bot_builder_symbol", null), (0, a._)(this, "active_tab", 0), (0, a._)(this, "active_tab_tutorials", 0), (0, a._)(this, "active_tour_step_number", 0), (0, a._)(this, "dialog_options", {}), (0, a._)(this, "faq_search_value", ""), (0, a._)(this, "getFileArray", []), (0, a._)(this, "has_file_loaded", !1), (0, a._)(this, "has_mobile_preview_loaded", !1), (0, a._)(this, "active_tour", ""), (0, a._)(this, "is_dialog_open", !1), (0, a._)(this, "is_file_supported", !1), (0, a._)(this, "is_info_panel_visible", !1), (0, a._)(this, "is_preview_on_popup", !1), (0, a._)(this, "is_tour_dialog_visible", !1), (0, a._)(this, "show_toast", !1), (0, a._)(this, "show_mobile_tour_dialog", !1), (0, a._)(this, "strategy_save_type", "unsaved"), (0, a._)(this, "toast_message", ""), (0, a._)(this, "is_web_socket_intialised", !0), (0, a._)(this, "search_param", ""), (0, a._)(this, "guide_tab_content", B.ni), (0, a._)(this, "video_tab_content", B.DD), (0, a._)(this, "faq_tab_content", B.n9), (0, a._)(this, "quick_strategy_tab_content", B.EC), (0, a._)(this, "filtered_tab_list", []), (0, a._)(this, "is_chart_modal_visible", !1), (0, a._)(this, "is_trading_view_modal_visible", !1), (0, a._)(this, "faq_title", ""), (0, a._)(this, "setFaqTitle", e => {
                            this.faq_title = e
                        }), (0, a._)(this, "resetTutorialTabContent", () => {
                            this.guide_tab_content = B.ni, this.video_tab_content = B.DD, this.faq_tab_content = B.n9, this.quick_strategy_tab_content = B.EC
                        }), (0, a._)(this, "filterTuotrialTab", e => {
                            this.search_param = e;
                            let t = this.combined_search.filter(t => t.includes(null == e ? void 0 : e.toLowerCase())),
                                i = [],
                                s = [],
                                o = [],
                                r = [],
                                a = t.map(e => {
                                    let t = e.split("#")[0],
                                        a = t.split("-")[1];
                                    return t.includes(B.d6) ? (i.push((0, B.ni)()[Number(a)]), (0, B.ni)()[Number(a)]) : t.includes(B.BI) ? (s.push((0, B.DD)()[Number(a)]), (0, B.DD)()[Number(a)]) : t.includes("faq") ? (o.push((0, B.n9)()[Number(a)]), (0, B.n9)()[Number(a)]) : (r.push((0, B.EC)()[Number(a)]), (0, B.EC)()[Number(a)])
                                });
                            return this.guide_tab_content = () => i, this.video_tab_content = () => s, this.faq_tab_content = () => o, this.quick_strategy_tab_content = () => r, a
                        }), (0, a._)(this, "setBotBuilderSymbol", e => {
                            this.bot_builder_symbol = e;
                            let {
                                chart_store: t
                            } = this.root_store;
                            t && e && t.onSymbolChange(e)
                        }), (0, a._)(this, "setShowMobileTourDialog", e => {
                            this.show_mobile_tour_dialog = e
                        }), (0, a._)(this, "setWebSocketState", e => {
                            this.is_web_socket_intialised = e
                        }), (0, a._)(this, "setOpenSettings", e => {
                            this.toast_message = e, (0, R.N)((0, O.UC)()[e])
                        }), (0, a._)(this, "setChartModalVisibility", () => {
                            this.is_chart_modal_visible = !this.is_chart_modal_visible
                        }), (0, a._)(this, "setTradingViewModalVisibility", () => {
                            this.is_trading_view_modal_visible = !this.is_trading_view_modal_visible
                        }), (0, a._)(this, "setIsFileSupported", e => {
                            this.is_file_supported = e
                        }), (0, a._)(this, "setTourActiveStep", e => {
                            this.active_tour_step_number = e
                        }), (0, a._)(this, "setPreviewOnDialog", e => {
                            this.has_mobile_preview_loaded = e;
                            let {
                                load_modal: {
                                    onLoadModalClose: t
                                }
                            } = this.root_store;
                            t()
                        }), (0, a._)(this, "setStrategySaveType", e => {
                            this.strategy_save_type = e
                        }), (0, a._)(this, "setPreviewOnPopup", e => {
                            this.is_preview_on_popup = e
                        }), (0, a._)(this, "setTourDialogVisibility", e => {
                            this.is_tour_dialog_visible = e
                        }), (0, a._)(this, "setActiveTour", e => {
                            this.active_tour = e
                        }), (0, a._)(this, "setFileLoaded", e => {
                            this.has_file_loaded = e, document.getElementById("load-strategy__blockly-container") || console.warn("Could not find preview workspace element.")
                        }), (0, a._)(this, "onCloseDialog", () => {
                            this.is_dialog_open = !1
                        }), (0, a._)(this, "setActiveTab", e => {
                            this.active_tab = e, localStorage.setItem("active_tab", e.toString())
                        }), (0, a._)(this, "setActiveTabTutorial", e => {
                            this.active_tab_tutorials = e
                        }), (0, a._)(this, "setFAQSearchValue", e => {
                            this.faq_search_value = e
                        }), (0, a._)(this, "showVideoDialog", e => {
                            let {
                                url: t,
                                type: i = ""
                            } = e;
                            this.faq_search_value = "", this.setActiveTabTutorial(0), this.resetTutorialTabContent(), ["google", "url"].includes(i) ? ("url" === i && (this.dialog_options = {
                                url: t
                            }), this.is_dialog_open = !0) : this.is_dialog_open = !1
                        }), (0, a._)(this, "setInfoPanelVisibility", e => {
                            this.is_info_panel_visible = e
                        }), (0, a._)(this, "onZoomInOutClick", e => {
                            let t = window.Blockly.getMainWorkspace(),
                                i = t.getMetrics();
                            t.zoom(i.viewWidth / 2, i.viewHeight / 2, e ? 1 : -1)
                        }), (0, a._)(this, "onCloseTour", () => {
                            (0, L.U9)(new Date().getTime(), `${L.m0.key}_token`), this.setActiveTour("")
                        }), (0, a._)(this, "setTourEnd", e => {
                            let {
                                key: t
                            } = e;
                            this.core.ui.is_mobile && this.setTourDialogVisibility(!0), (0, L.U9)(new Date().getTime(), `${t}_token`)
                        }), (0, a._)(this, "onTourEnd", (e, t) => {
                            8 === e && (this.onCloseTour(), this.setTourEnd(L.m0), this.setActiveTour("")), t || 3 !== e || (this.onCloseTour(), this.setTourEnd(L.m0), this.setActiveTour(""))
                        }), (0, l.Gn)(this, {
                            active_tab_tutorials: l.sH,
                            active_tab: l.sH,
                            dialog_options: l.sH,
                            faq_search_value: l.sH,
                            getFileArray: l.sH,
                            has_file_loaded: l.sH,
                            has_mobile_preview_loaded: l.sH,
                            initInfoPanel: l.XI.bound,
                            active_tour: l.sH,
                            is_dialog_open: l.sH,
                            is_file_supported: l.sH,
                            is_info_panel_visible: l.sH,
                            is_preview_on_popup: l.sH,
                            is_tour_dialog_visible: l.sH,
                            is_web_socket_intialised: l.sH,
                            tutorials_combined_content: l.sH,
                            onCloseDialog: l.XI.bound,
                            onCloseTour: l.XI.bound,
                            onTourEnd: l.XI.bound,
                            setActiveTab: l.XI.bound,
                            setActiveTabTutorial: l.XI.bound,
                            setWebSocketState: l.XI.bound,
                            setFAQSearchValue: l.XI.bound,
                            faq_title: l.sH,
                            setFaqTitle: l.XI.bound,
                            setFileLoaded: l.XI.bound,
                            setInfoPanelVisibility: l.XI.bound,
                            setIsFileSupported: l.XI.bound,
                            setPreviewOnDialog: l.XI.bound,
                            setPreviewOnPopup: l.XI.bound,
                            setActiveTour: l.XI.bound,
                            setTourDialogVisibility: l.XI.bound,
                            setOpenSettings: l.XI.bound,
                            resetTutorialTabContent: l.XI.bound,
                            filterTuotrialTab: l.XI.bound,
                            show_toast: l.sH,
                            show_mobile_tour_dialog: l.sH,
                            showVideoDialog: l.XI.bound,
                            strategy_save_type: l.sH,
                            toast_message: l.sH,
                            guide_tab_content: l.sH,
                            faq_tab_content: l.sH,
                            quick_strategy_tab_content: l.sH,
                            video_tab_content: l.sH,
                            setStrategySaveType: l.XI.bound,
                            setShowMobileTourDialog: l.XI.bound,
                            is_chart_modal_visible: l.sH,
                            is_trading_view_modal_visible: l.sH,
                            bot_builder_symbol: l.sH
                        }), this.root_store = e, this.core = t;
                        const i = [...(0, B.ni)()].map(e => {
                                var t;
                                return `${e.search_id}# ${null==(t=e.content)?void 0:t.toLowerCase()}`
                            }),
                            s = [...(0, B.DD)()].map(e => {
                                var t;
                                return `${e.search_id}# ${null==(t=e.content)?void 0:t.toLowerCase()}`
                            }),
                            o = (0, B.n9)().map(e => {
                                var t;
                                return `${e.search_id}# ${null==(t=e.title)?void 0:t.toLowerCase()} ${e.description.map(e=>{let t=C.A.sanitize(e.content,{ALLOWED_TAGS:[]});return null==t?void 0:t.toLowerCase()}).join(" ")}`
                            }),
                            r = (0, B.EC)().map(e => {
                                var t, i, s;
                                let o = null == (t = e.content.join(" ")) ? void 0 : t.toLowerCase(),
                                    r = (e => {
                                        if (!e) return [];
                                        let t = [];
                                        return e().forEach(e => {
                                            if ((null == e ? void 0 : e.type) !== "media") {
                                                var i;
                                                null == (i = e.content) || i.forEach(e => t.push(e))
                                            }
                                        }), t
                                    })(null == D ? void 0 : D[e.qs_name]);
                                return r = null == (i = r.join(" ")) ? void 0 : i.toLowerCase(), `${e.search_id}# ${null==(s=e.type)?void 0:s.toLowerCase()} ${r+o}`
                            });
                        this.combined_search = [...i, ...s, ...o, ...r], (0, l.mJ)(() => this.is_preview_on_popup, async e => {
                            e && this.setPreviewOnPopup(!1)
                        }), this.initInfoPanel()
                    }
                }
                var N = i(52566),
                    j = i.n(N);
                class U {
                    async trackRun() {
                        let e = this.cleanXmlDom(window.Blockly.Xml.workspaceToDom(u.DBot.workspace, !0)),
                            t = (0, u.convertStrategyToIsDbot)(e),
                            i = window.Blockly.Xml.domToText(t),
                            s = this.getHash(i);
                        this.getHash(this.strategy_content) !== s && (this.should_post_xml = !0, this.setStrategyContent(i)), this.setRunId(this.getHash(s + this.core.client.loginid + Math.random())), this.setRunStart(this.core.common.server_time.unix())
                    }
                    async trackTransaction(e) {
                        let t = await i.e("862").then(i.bind(i, 3075)),
                            s = e[0];
                        if (!s) return;
                        let {
                            buy: o
                        } = s.data.transaction_ids;
                        if (!Object.keys(this.transaction_ids).includes(o.toString())) {
                            this.transaction_ids[o] = this.IS_PENDING;
                            let e = () => ({
                                body: t.gzip(this.strategy_content),
                                headers: {
                                    "Content-Encoding": "gzip",
                                    "Content-Type": "application/xml",
                                    Referer: window.location.hostname
                                }
                            });
                            fetch(`${this.endpoint}/${this.run_id}/${o}/${this.run_start}/${this.getHash(this.strategy_content)}`, { ...this.should_post_xml ? e() : {},
                                method: "POST",
                                mode: "no-cors"
                            }).then(() => {
                                this.should_post_xml = !1, this.transaction_ids[o] = this.IS_PROCESSED
                            }).catch(() => {
                                delete this.transaction_ids[o]
                            })
                        }
                    }
                    setRunId(e) {
                        this.run_id = e
                    }
                    setRunStart(e) {
                        this.run_start = e
                    }
                    setStrategyContent(e) {
                        this.strategy_content = e
                    }
                    constructor(e, t) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "core", void 0), (0, a._)(this, "IS_PENDING", !1), (0, a._)(this, "IS_PROCESSED", !0), (0, a._)(this, "endpoint", "https://dbot-conf-dot-deriv-bi-reporting.as.r.appspot.com/dbotconf"), (0, a._)(this, "run_id", ""), (0, a._)(this, "run_start", 0), (0, a._)(this, "should_post_xml", !0), (0, a._)(this, "strategy_content", ""), (0, a._)(this, "transaction_ids", {}), (0, a._)(this, "cleanXmlDom", e => {
                            let t = ["x", "y", "id"],
                                i = (0, d.h2C)(e),
                                s = e => {
                                    t.forEach(t => e.removeAttribute(t)), Array.from(e.children).forEach(e => s(e))
                                };
                            return s(i), i
                        }), (0, a._)(this, "getHash", e => btoa(String(j().str(e)))), (0, l.Gn)(this, {
                            IS_PENDING: l.sH,
                            IS_PROCESSED: l.sH,
                            endpoint: l.sH,
                            run_id: l.sH,
                            run_start: l.sH,
                            should_post_xml: l.sH,
                            strategy_content: l.sH,
                            transaction_ids: l.sH,
                            trackRun: l.XI.bound,
                            trackTransaction: l.XI.bound,
                            setRunId: l.XI.bound,
                            setRunStart: l.XI.bound,
                            setStrategyContent: l.XI.bound,
                            cleanXmlDom: l.XI.bound,
                            getHash: l.XI.bound
                        }), this.root_store = e, this.core = t, ((0, d.KVY)() || /(.*?)\.binary.sx$/.test(window.location.hostname)) && (this.root_store = e, (0, l.mJ)(() => this.root_store.run_panel.is_running, () => this.root_store.run_panel.is_running ? this.trackRun() : void 0), (0, l.mJ)(() => this.root_store.transactions.transactions, e => {
                            this.run_id && this.trackTransaction(e)
                        }))
                    }
                }
                var M = i(82215);
                let H = {
                        text: () => [(0, p.kg)("This block is mandatory. Here is where you can decide if your bot should continue trading. Only one copy of this block is allowed."), (0, p.kg)("This block is commonly used to adjust the parameters of your next trade and to implement stop loss/take profit logic.")]
                    },
                    F = {
                        text: () => [(0, p.kg)("This block returns current account balance."), (0, p.kg)('The only input parameter determines how block output is going to be formatted. In case if the input parameter is "string" then the account currency will be added.'), (0, p.kg)("Example output of the below example will be:"), (0, p.kg)('1. for "string": 1325.68 USD'), (0, p.kg)('2. for "number": 1325.68')]
                    },
                    W = {
                        text: () => [(0, p.kg)("This block is mandatory. Only one copy of this block is allowed. It is added to the canvas by default when you open Defen Traders."), (0, p.kg)("After defining trade parameters and trade options, you may want to instruct your bot to purchase contracts when specific conditions are met. To do that you can use conditional blocks and indicators blocks to help your bot to make decisions.")]
                    },
                    $ = {
                        text: () => [(0, p.kg)('This block is used to determine if the market price moves in the selected direction or not. It gives you a value of "True" or "False".'), (0, p.kg)("Examples:"), (0, p.kg)('1. If the selected direction is "Rise", and the previous tick value is less than the current tick value, the output will be "True". Otherwise, the output will be an empty string.'), (0, p.kg)('2. If the selected direction is "Fall", and the previous tick value is more than the current tick value, the output will be "True". Otherwise, the output will be an empty string.')]
                    },
                    X = {
                        text: () => [(0, p.kg)("This block displays messages in the developer’s console with an input that can be either a string of text, a number, boolean, or an array of data."), (0, p.kg)("There are 4 message types:"), (0, p.kg)("1. 'Log' displays a regular message."), (0, p.kg)("2. 'Warn' displays a message in yellow to highlight something that needs attention."), (0, p.kg)("3. 'Error' displays a message in red to highlight something that needs to be resolved immediately."), (0, p.kg)("4. 'Table' takes an array of data, such as a list of candles, and displays it in a table format.")]
                    },
                    G = {
                        text: () => [(0, p.kg)('You can check the result of the last trade with this block. It can only be placed within the "Restart trading conditions" root block.'), (0, p.kg)('If "Win" is selected, it will return "True" if your last trade was successful. Otherwise, it will return an empty string.'), (0, p.kg)('If "Loss" is selected, it will return "True" if your last trade was unsuccessful. Otherwise, it will return an empty string.'), (0, p.kg)("Example:")]
                    },
                    V = {
                        text: () => [(0, p.kg)("This block is used to either terminate or continue a loop, and can be placed anywhere within a loop block."), (0, p.kg)("Examples:"), (0, p.kg)('1. In the below example the loop is terminated in case "x" is "False" even though only one iteration is complete'), (0, p.kg)('2. In the below example the loop jumps to the next iteration without executing below block in case if "x" is "False"')]
                    },
                    q = {
                        text: () => [(0, p.kg)('This block uses the variable "i" to control the iterations. With each iteration, the value of "i" is determined by the items in a given list.'), (0, p.kg)("Example:"), (0, p.kg)('"i" starts with the value of 1, and it will be increased by 2 at every iteration. The loop will repeat until "i" reaches the value of 12, and then the loop is terminated.'), (0, p.kg)('You can use "i" inside the loop, for example to access list items')]
                    },
                    Y = {
                        text: () => [(0, p.kg)('This block uses the variable "i" to control the iterations. With each iteration, the value of "i" is determined by the items in a given list.'), (0, p.kg)("Example:"), (0, p.kg)('In this example, the loop will repeat three times, as that is the number of items in the given list. During each iteration, the variable "i" will be assigned a value from the list. '), (0, p.kg)('Please note that changing the value of "i" won\'t change the value of the original item in the list')]
                    },
                    z = {
                        text: () => [(0, p.kg)("This block evaluates a statement and will perform an action only when the statement is true."), (0, p.kg)("Click the plus icon to extend the functionality of this block."), (0, p.kg)('You can also use "Compare" and "Logic operation" blocks to make test variables.')]
                    },
                    K = {
                        text: () => [(0, p.kg)("This block repeats instructions as long as a given condition is true."), (0, p.kg)("Examples:"), (0, p.kg)("1. In the example below, the instructions are repeated as long as the value of x is less than or equal to 10. Once the value of x exceeds 10, the loop is terminated."), (0, p.kg)("2. In this example, the instructions are repeated as long as the value of x is greater than or equal to 10. Once the value of x drops below 10, the loop is terminated.")]
                    },
                    J = {
                        text: () => [(0, p.kg)("Here is where you can decide to sell your contract before it expires. Only one copy of this block is allowed."), (0, p.kg)("Example:")]
                    },
                    Q = {
                        text: () => [(0, p.kg)('"Seconds Since Epoch" block returns the number of seconds since January 1st, 1970.'), (0, p.kg)("Example:"), (0, p.kg)("1551661986 seconds since Jan 01 1970 (UTC) translates to 03/04/2019 @ 1:13am (UTC)."), (0, p.kg)("You might need it when you want to repeat an actions after certain amount of time."), (0, p.kg)("The example below restarts trading after 30 or more seconds after 1 minute candle was started.")]
                    },
                    Z = {
                        text: () => [(0, p.kg)("This block gives you a specific candle from within the selected time interval."), (0, p.kg)('In this example, the open price of a candle is assigned to the variable "candle_open_price".'), (0, p.kg)("In the above example it is assumed that variable candle_open_price is processed somewhere within other blocks.")]
                    },
                    ee = {
                        text: () => [(0, p.kg)('This block returns "True" if the last candle is black. It can be placed anywhere on the canvas except within the Trade parameters root block.'), (0, p.kg)('The term "candle" refers to each bar on the candlestick chart. Each candle represents four market prices for the selected time interval:'), (0, p.kg)("Each candlestick on the chart represents 4 market prices for the selected time interval:"), (0, p.kg)("- Open price: the opening price"), (0, p.kg)("- High price: the highest price"), (0, p.kg)("- Low price: the lowest price"), (0, p.kg)("- Close price: the closing price"), (0, p.kg)("A black (or red) candle indicates that the open price is higher than the close price. This represents a downward movement of the market price."), (0, p.kg)("A white (or green) candle indicates that the open price is lower than the close price. This represents an upward movement of the market price."), (0, p.kg)("The time interval for each candle can be set from one minute to one day.")]
                    },
                    et = {
                        text: () => [(0, p.kg)("This block gives you the last digit of the latest tick value of the selected market. If the latest tick value is 1410.90, this block will return 0. It’s useful for digit-based contracts such as Even/Odd, Matches/Differs, or Higher/Lower.")]
                    },
                    ei = {
                        text: () => [(0, p.kg)('This block performs the "AND" or the "OR" logic operation with the given values.'), (0, p.kg)('In case if the "AND" operation is selected, the block returns "True" only if both given values are "True"'), (0, p.kg)('In case if the "OR" operation is selected, the block returns "True" in case if one or both given values are "True"')]
                    },
                    es = {
                        text: () => [(0, p.kg)("This block performs arithmetic operations between two numbers."), (0, p.kg)("Available operations:"), (0, p.kg)("- Addition"), (0, p.kg)("- Subtraction"), (0, p.kg)("- Multiplication"), (0, p.kg)("- Division"), (0, p.kg)("- Raise the first number to the power of the second number")]
                    },
                    eo = {
                        text: () => [(0, p.kg)("This block constrains a given number within a set range."), (0, p.kg)("In case if the given number is less than the lower boundary of the range, the block returns the lower boundary value. Similarly, if the given number is greater than the higher boundary, the block will return the higher boundary value. In case if the given value is between boundaries, the block will return the given value unchanged."), (0, p.kg)("In the below example the block returns the value of 10 as the given value (5) is less than the lower boundary (10)")]
                    },
                    er = {
                        text: () => [(0, p.kg)("This block performs the following operations to a given number"), (0, p.kg)("Available operations are:"), (0, p.kg)("- Square root"), (0, p.kg)("- Absolute"), (0, p.kg)("- Negation"), (0, p.kg)("- Natural log"), (0, p.kg)("- Euler’s number (2.71) to the power of a given number"), (0, p.kg)("- 10 to the power of a given number")]
                    },
                    ea = {
                        text: () => [(0, p.kg)("This block sends a message to a Telegram channel. You will need to create your own Telegram bot to use this block."), (0, p.kg)("Here’s how:"), (0, p.kg)("1. Create a Telegram bot and get your Telegram API token. Read more on how to create bots in Telegram here: https://core.telegram.org/bots#6-botfather"), (0, p.kg)("2. Start a chat with your newly created Telegram bot and make sure to send it some messages before proceeding to the next step. (e.g. Hello Bot!)"), (0, p.kg)("3. Get the chat ID using the Telegram REST API (read more: https://core.telegram.org/bots/api#getupdates)"), (0, p.kg)("- Visit the following URL, make sure to replace <access_token> with the Telegram API token you created in Step 1: https://api.telegram.org/bot<access_token>/getUpdates"), (0, p.kg)("- Find the chat ID property in the response, and copy the value of the id property"), (0, p.kg)("4. Come back to Defen Traders and add the Notify Telegram block to the workspace. Paste the Telegram API token and chat ID into the block fields accordingly.")]
                    },
                    en = {
                        text: () => [(0, p.kg)("This block gives you a list of candles within a selected time interval."), (0, p.kg)('In this example, this block is used with another block to get the open prices from a list of candles. The open prices are then assigned to the variable called "cl".')]
                    },
                    el = {
                        text: () => [(0, p.kg)("This block gives you the selected candle value from a list of candles within the selected time interval. You can choose from open price, close price, high price, low price, and open time."), (0, p.kg)('In this example, the open prices from a list of candles are assigned to a variable called "candle_list".')]
                    },
                    ec = {
                        text: () => [(0, p.kg)("This block gives you the selected candle value from a list of candles. You can choose from open price, close price, high price, low price, and open time."), (0, p.kg)("This block requires a list of candles as an input parameter."), (0, p.kg)('In this example, the open prices from a list of candles are assigned to a variable called "cl".')]
                    },
                    ed = {
                        text: () => [(0, p.kg)("Used within a function block, this block returns a value when a specific condition is true."), (0, p.kg)("Example:")]
                    },
                    eu = {
                        text: () => [(0, p.kg)("This block gives you information about your last contract."), (0, p.kg)("You can choose to see one of the following:"), (0, p.kg)("- Deal reference ID: the reference ID of the contract"), (0, p.kg)("- Purchase price: the purchase price (stake) of the contract"), (0, p.kg)("- Payout: the payout of the contract"), (0, p.kg)("- Profit: the profit you’ve earned"), (0, p.kg)("- Contract type: the name of the contract type such as Rise, Fall, Touch, No Touch, etс."), (0, p.kg)("- Entry time: the starting time of the contract"), (0, p.kg)("- Entry value: the value of the first tick of the contract"), (0, p.kg)("- Exit time: the contract expiration time"), (0, p.kg)("- Exit value: the value of the last tick of the contract"), (0, p.kg)("- Barrier: the barrier value of the contract (applicable to barrier-based trade types such as stays in/out, touch/no touch, etc.)"), (0, p.kg)('- Result: the result of the last contract: "win" or "loss"')]
                    },
                    eh = {
                        text: () => [(0, p.kg)("This block gives you the specified candle value for a selected time interval. You can choose which value you want:"), (0, p.kg)("- Open: the opening price"), (0, p.kg)("- High: the highest price"), (0, p.kg)("- Low: the lowest price"), (0, p.kg)("- Close: the closing price"), (0, p.kg)("- Open time: the opening time stamp"), (0, p.kg)('In the example below, the opening price is selected, which is then assigned to a variable called "op".')]
                    },
                    ep = {
                        text: () => [(0, p.kg)("This block gives you the selected candle value such as open price, close price, high price, low price, and open time. It requires a candle as an input parameter."), (0, p.kg)('In the example below, the open price is assigned to the variable "op".')]
                    },
                    e_ = {
                        text: () => [(0, p.kg)("Use this block to sell your contract at the market price. Selling your contract is optional. You may choose to sell if the market trend is unfavourable."), (0, p.kg)("Example:")]
                    },
                    eg = {
                        text: () => [(0, p.kg)('This block gives you the potential profit or loss if you decide to sell your contract. It can only be used within the "Sell conditions" root block.'), (0, p.kg)("In the example below, the contract will only be sold if the potential profit or loss is more than the stake.")]
                    },
                    em = {
                        text: () => [(0, p.kg)("SMA adds the market price in a list of ticks or candles for a number of time periods, and divides the sum by that number of time periods."), (0, p.kg)("The formula for SMA is:"), (0, p.kg)("where n is the number of periods."), "", (0, p.kg)("What SMA tells you"), (0, p.kg)("SMA serves as an indicator of the trend. If the SMA points up then the market price is increasing and vice versa. The larger the period number, the smoother SMA line is."), (0, p.kg)("In this example, each point of the SMA line is an arithmetic average of close prices for the last 10 days."), (0, p.kg)("In this example, each point of the SMA line is an arithmetic average of close prices for the last 50 days."), "", (0, p.kg)("How to use the SMA block"), (0, p.kg)("Input list accepts a list of ticks or candles, while period is the specified time period."), (0, p.kg)("Example:"), (0, p.kg)("This will display the SMA for the specified period, using a candle list."), (0, p.kg)("SMA places equal weight to the entire distribution of values."), (0, p.kg)("This is the same as the above example, using a tick list."), (0, p.kg)("You may compare SMA values calculated on every bot run to identify the market trend direction. Alternatively, you may also use a variation of the SMA block, the Simple Moving Average Array block. "), (0, p.kg)("This block returns the entire SMA line, containing a list of all values for a given period."), (0, p.kg)("If a period of 10 is entered, the Simple Moving Average Array block will return a list of SMA values calculated based on period of 10."), (0, p.kg)("The below image illustrates how Simple Moving Average Array block works:")]
                    },
                    ey = {
                        text: () => [(0, p.kg)('This block displays a dialog box with a customised message. When the dialog box is displayed, your strategy is paused and will only resume after you click "OK".')]
                    },
                    ef = {
                        text: () => [(0, p.kg)('This block displays a dialog box that uses a customised message to prompt for an input. The input can be either a string of text or a number and can be assigned to a variable. When the dialog box is displayed, your strategy is paused and will only resume after you enter a response and click "OK".')]
                    },
                    eb = {
                        text: () => [(0, p.kg)("Any blocks placed within this block will be executed at every tick. If the default candle interval is set to 1 minute in the Trade Parameters root block, the instructions in this block will be executed once every minute. Place this block outside of any root block.")]
                    },
                    ek = {
                        text: () => [(0, p.kg)("This block converts the number of seconds since the Unix Epoch to a date and time format such as 2019-08-01 00:00:00."), (0, p.kg)("Example:"), (0, p.kg)("In this example, the date and time will be displayed in a green notification box.")]
                    },
                    ev = {
                        text: () => [(0, p.kg)("This block converts the date and time to the number of seconds since the Unix Epoch (1970-01-01 00:00:00)."), (0, p.kg)("Example:"), (0, p.kg)("In this example, a Rise contract will be purchased at midnight on 1 August 2019.")]
                    },
                    ew = {
                        text: () => [(0, p.kg)("This block will transfer the control back to the Purchase conditions block, enabling you to purchase another contract without manually stopping and restarting your bot."), (0, p.kg)("Example:")]
                    },
                    eT = {
                        text: () => [(0, p.kg)("This block is mandatory. It's added to your strategy by default when you create new strategy. You can not add more than one copy of this block to the canvas."), (0, p.kg)("1. Market"), (0, p.kg)("Select your desired market and asset type. For example, Forex > Major pairs > AUD/JPY"), (0, p.kg)("2. Trade Type"), (0, p.kg)("Select your desired trade type. For example, Up/Down > Rise/Fall"), (0, p.kg)("3. Contract Type"), (0, p.kg)("Choose what type of contract you want to trade. For example, for the Rise/Fall trade type you can choose one of three options: Rise, Fall, or Both. Selected option will determine available options for the Purchase block."), (0, p.kg)("4. Default Candle Interval"), (0, p.kg)("Sets the default time interval for blocks that read list of candles."), (0, p.kg)("5. Restart buy/sell on error"), (0, p.kg)("Restarts the bot when an error is encountered."), (0, p.kg)("6. Restart last trade on error"), (0, p.kg)("Repeats the previous trade when an error is encountered."), (0, p.kg)("7. Run Once at Start"), (0, p.kg)("Place blocks here to perform tasks once when your bot starts running."), (0, p.kg)("8. Trade Options"), (0, p.kg)("The desired duration, stake, prediction, and/or barrier(s) for the contract is defined here.")]
                    };
                var eS = i(168);
                let eI = {
                        text: () => [(0, p.kg)("Use this block when you want to use multipliers as your trade type."), (0, p.kg)("Click the multiplier drop-down menu and choose the multiplier value you want to trade with."), (0, p.kg)("Your potential profit will be multiplied by the multiplier value you’ve chosen."), (0, o.jsx)(p.we, {
                            i18n_default_text: "To learn more about multipliers, please go to the <0>Multipliers</0> page.",
                            components: [(0, o.jsx)(eS.A, {
                                className: "link",
                                href: "trade-types/multiplier"
                            }, 0)]
                        }, 0)]
                    },
                    eE = {
                        text: () => [(0, p.kg)("This block is used to define trade options within the Trade parameters root block. Some options are only applicable for certain trade types. Parameters such as duration and stake are common among most trade types. Prediction is used for trade types such as Digits, while barrier offsets are for trade types that involve barriers such as Touch/No Touch, Ends In/Out, etc."), (0, p.kg)("Example:")]
                    },
                    ex = {
                        text: () => [(0, p.kg)("This block assigns a given value to a variable, creating the variable if it doesn't already exist."), (0, p.kg)("A variable is among the most important and powerful components in creating a bot. It is a way to store information, either as text or numbers. The information stored as a variable can be used and changed according to the given instructions. Variables can be given any name, but usually they are given useful, symbolic names so that it is easier to call them during the execution of instructions."), (0, p.kg)("Creating a variable"), (0, p.kg)("1. From the block library, enter a name for the new variable and click Create."), (0, p.kg)("2. The new variable will appear as a block under Set variable.")]
                    };
                class eA {
                    setActiveHelper(e) {
                        this.active_helper = e
                    }
                    onBackClick() {
                        let {
                            toolbox: e,
                            flyout: t
                        } = this.root_store;
                        if (t.is_search_flyout) {
                            let t = document.getElementsByName("search")[0].value;
                            e.onSearch({
                                search: t
                            })
                        } else t.refreshCategory()
                    }
                    async onSequenceClick(e) {
                        let t, s = Array.from(this.xml_list).find(e => e.getAttribute("type") === this.block_type);
                        Object.keys(this.xml_list_group).forEach((e, i) => {
                            s.getAttribute("type") === e && (t = i)
                        });
                        let o = async (e, t, s) => {
                                let r = t + (s ? 1 : -1),
                                    a = Object.keys(e).filter((e, t) => s ? r <= t : r >= t),
                                    n = await this.getFilledBlocksIndex(a),
                                    l = a[s ? n[0] : n[n.length - 1]];
                                if (!l) return !1;
                                try {
                                    return await Promise.resolve().then(i.bind(i, 67774)), l
                                } catch (t) {
                                    return o(e, r, s)
                                }
                            },
                            r = await o(this.xml_list_group, t, e);
                        if (r) {
                            let e = this.xml_list_group[r];
                            this.setHelpContent(e[0])
                        }
                    }
                    initFlyoutHelp(e) {
                        let {
                            flyout: t,
                            toolbox: i
                        } = this.root_store;
                        this.xml_list = i.getCategoryContents(t.selected_category), this.xml_list_group = this.groupBy(this.xml_list, !0), this.setHelpContent(e)
                    }
                    async updateSequenceButtons() {
                        let e = Array.from(this.xml_list).find(e => e.getAttribute("type") === this.block_type),
                            t = Object.keys(this.xml_list_group).findIndex(t => e.getAttribute("type") === t),
                            i = await this.getNextHelpContentIndex(!0),
                            s = await this.getNextHelpContentIndex(!1);
                        (0, l.h5)(() => {
                            this.should_previous_disable = 0 === t || t === s, this.should_next_disable = t === Object.keys(this.xml_list_group).length - 1 || t === i
                        })
                    }
                    groupBy(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        return Array.from(e).reduce((e, i) => {
                            let s = i.getAttribute("type");
                            return t && null === s || (e[s] || (e[s] = []), (!t || t && null !== s) && e[s].push(i)), e
                        }, {})
                    }
                    setExamples(e) {
                        let {
                            toolbox: t
                        } = this.root_store, i = [...t.toolbox_examples.childNodes], s = (0, M.Z)(window.__webpack_public_path__)[e].filter(e => "example" === e.type).map(e => e.example_id).map(e => i.find(t => t.id === e));
                        this.examples = s
                    }
                    constructor(e) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "block_node", null), (0, a._)(this, "block_type", ""), (0, a._)(this, "examples", []), (0, a._)(this, "help_string", {}), (0, a._)(this, "title", ""), (0, a._)(this, "should_next_disable", !1), (0, a._)(this, "should_previous_disable", !1), (0, a._)(this, "active_helper", ""), (0, a._)(this, "setHelpContent", async e => {
                            let t = e.getAttribute("type"),
                                i = window.Blockly.Blocks[t].meta().display_name;
                            "" !== t && (this.active_helper = t);
                            let {
                                flyout: o
                            } = this.root_store;
                            this.setExamples(t);
                            let r = this.examples.map(e => e.childNodes[0]);
                            setTimeout(() => o.setFlyoutWidth([e, ...r]), 50), (0, l.h5)(() => {
                                if (o.is_help_content = !0, this.block_node = e, this.block_type = t, this.title = i, "" !== t)
                                    for (let [e, i] of Object.entries(s[t])) this.help_string[e] = i()
                            }), o.is_search_flyout || this.updateSequenceButtons()
                        }), (0, a._)(this, "getHelpContent", async e => {
                            let t;
                            return e && (t = s[this.xml_list_group[e][0].getAttribute("type")]), t
                        }), (0, a._)(this, "getFilledBlocksIndex", async e => (await Promise.all(e.map(e => this.getHelpContent(e)))).map((e, t) => e ? t : null).filter(e => null !== e)), (0, a._)(this, "getNextHelpContentIndex", async e => {
                            let t = await this.getFilledBlocksIndex(Object.keys(this.xml_list_group));
                            return e ? t[t.length - 1] : t[0]
                        }), (0, l.Gn)(this, {
                            block_node: l.sH,
                            block_type: l.sH,
                            examples: l.sH,
                            help_string: l.sH,
                            title: l.sH,
                            should_next_disable: l.sH,
                            should_previous_disable: l.sH,
                            active_helper: l.sH,
                            setHelpContent: l.XI.bound,
                            setActiveHelper: l.XI.bound,
                            onBackClick: l.XI.bound,
                            onSequenceClick: l.XI.bound,
                            initFlyoutHelp: l.XI.bound,
                            updateSequenceButtons: l.XI.bound,
                            setExamples: l.XI.bound,
                            getHelpContent: l.XI.bound,
                            getFilledBlocksIndex: l.XI.bound,
                            getNextHelpContentIndex: l.XI.bound
                        }), this.root_store = e
                    }
                }
                var eC = i(28362);
                class eR {
                    onMount() {
                        this.initFlyout(), window.addEventListener("click", this.onClickOutsideFlyout)
                    }
                    onUnmount() {
                        window.removeEventListener("click", this.onClickOutsideFlyout)
                    }
                    initFlyout() {
                        var e, t, i;
                        let s = window.Blockly.derivWorkspace,
                            o = new window.Blockly.Options({
                                parentWorkspace: s,
                                rtl: s.RTL,
                                horizontalLayout: !0,
                                theme: null == (i = window) || null == (t = i.Blockly) || null == (e = t.Themes) ? void 0 : e.zelos_renderer
                            });
                        s.horizontalLayout ? this.flyout = new window.Blockly.HorizontalFlyout(o) : this.flyout = new window.Blockly.VerticalFlyout(o), this.flyout.targetWorkspace = s, this.flyout.workspace_.targetWorkspace = s, this.flyout.workspace_.getGesture = this.flyout.targetWorkspace.getGesture.bind(this.flyout.targetWorkspace_), s.VariableMap = this.flyout.targetWorkspace.getVariableMap(), this.flyout.workspace_.createPotentialVariableMap()
                    }
                    initBlockWorkspace(e, t) {
                        var i, s, o, r, a, n, l, c, d;
                        let u = window.Blockly.inject(e, this.options);
                        u.targetWorkspace = window.Blockly.derivWorkspace;
                        let h = window.Blockly.Xml.domToBlock(t, u),
                            p = h.getHeightWidth();
                        h.isInFlyout = !0, e.style.height = `${Math.ceil(p.height*this.options.zoom.startScale)+1}px`, e.style.width = `${Math.ceil(p.width*this.options.zoom.startScale)+1}px`, h.moveBy(1, 1);
                        let _ = h.getSvgRoot();
                        this.block_listeners.push(null == (o = window) || null == (s = o.Blockly) || null == (i = s.browserEvents) ? void 0 : i.conditionalBind(_, "mousedown", null, e => {
                            var t;
                            null === eC.default || void 0 === eC.default || null == (t = eC.default.pushDataLayer) || t.call(eC.default, {
                                event: "dbot_drag_block",
                                block_type: h.type
                            }), this.flyout.blockMouseDown(h)(e)
                        }), null == (n = window) || null == (a = n.Blockly) || null == (r = a.browserEvents) ? void 0 : r.bind(_, "mouseout", h, h.removeSelect), null == (d = window) || null == (c = d.Blockly) || null == (l = c.browserEvents) ? void 0 : l.bind(_, "mouseover", h, h.addSelect)), this.block_workspaces.push(u), window.Blockly.svgResize(u)
                    }
                    getFlyout() {
                        return this.flyout
                    }
                    setContents(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                        this.block_listeners.forEach(e => window.Blockly.browserEvents.unbind(e)), this.block_workspaces.forEach(e => e.dispose()), this.block_listeners = [], this.block_workspaces = [], this.is_help_content = !1, this.search_term = t.length > 20 ? `${t.substring(0,20)}...` : t, this.flyout_content = e, this.setFlyoutWidth(e), this.setVisibility(!0), setTimeout(() => this.setFlyoutWidth(e), 50)
                    }
                    setFlyoutWidth(e) {
                        let t = 0;
                        e.forEach(e => {
                            if (e.tagName.toUpperCase() === window.Blockly.Xml.NODE_BLOCK) {
                                let i = window.Blockly.Block.getDimensions(e);
                                e.setAttribute("width", String(Math.ceil(i.width * this.options.zoom.startScale))), e.setAttribute("height", String(Math.ceil(i.height * this.options.zoom.startScale))), t = Math.max(t, Math.ceil(i.width * this.options.zoom.startScale))
                            }
                        }), this.flyout_width = Math.max(this.flyout_min_width, t + 65)
                    }
                    setVisibility(e) {
                        this.is_visible = e, e || (this.setSelectedCategory(null), this.flyout_content = []), window.Blockly.derivWorkspace.isFlyoutVisible = e
                    }
                    setIsSearchFlyout(e) {
                        this.is_search_flyout = e
                    }
                    setSelectedCategory(e) {
                        this.selected_category = e
                    }
                    getSelectedCategory() {
                        return this.selected_category
                    }
                    onClickOutsideFlyout(e) {
                        if (!this.is_visible || !window.Blockly.derivWorkspace) return;
                        let t = document.getElementById("gtm-toolbox"),
                            i = ((null == e ? void 0 : e.composedPath()) || []).some(e => e.classList && e.classList.contains("flyout")),
                            s = this.root_store.toolbox.is_search_focus;
                        i || (null == t ? void 0 : t.contains(e.target)) || s || (this.setVisibility(!1), this.setSelectedCategory(null))
                    }
                    refreshCategory() {
                        let e = this.getSelectedCategory(),
                            {
                                toolbox: t
                            } = this.root_store,
                            i = t.getCategoryContents(e);
                        this.setContents(i)
                    }
                    get variables_blocks_count() {
                        return this.flyout_content.filter(e => "variables_get" === e.getAttribute("type")).length
                    }
                    get first_get_variable_block_index() {
                        return this.flyout_content.length - this.variables_blocks_count
                    }
                    constructor(e) {
                        var t, i, s;
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "flyout", null), (0, a._)(this, "block_listeners", []), (0, a._)(this, "block_workspaces", []), (0, a._)(this, "flyout_min_width", 440), (0, a._)(this, "options", {
                            renderer: "zelos",
                            media: "assets/media/",
                            move: {
                                scrollbars: !1,
                                drag: !0,
                                wheel: !1
                            },
                            zoom: {
                                startScale: (0, u.config)().workspaces.flyoutWorkspacesStartScale
                            },
                            sounds: !1,
                            theme: null == (s = window) || null == (i = s.Blockly) || null == (t = i.Themes) ? void 0 : t.zelos_renderer
                        }), (0, a._)(this, "is_help_content", !1), (0, a._)(this, "flyout_content", []), (0, a._)(this, "flyout_width", this.flyout_min_width), (0, a._)(this, "is_visible", !1), (0, a._)(this, "is_search_flyout", !1), (0, a._)(this, "is_loading", !1), (0, a._)(this, "search_term", ""), (0, a._)(this, "selected_category", null), (0, l.Gn)(this, {
                            is_help_content: l.sH,
                            flyout_content: l.sH,
                            flyout_width: l.sH,
                            is_visible: l.sH,
                            is_search_flyout: l.sH,
                            is_loading: l.sH,
                            search_term: l.sH,
                            selected_category: l.sH,
                            onMount: l.XI.bound,
                            onUnmount: l.XI.bound,
                            initFlyout: l.XI.bound,
                            initBlockWorkspace: l.XI.bound,
                            getFlyout: l.XI.bound,
                            setContents: l.XI.bound,
                            setFlyoutWidth: l.XI.bound,
                            setVisibility: l.XI.bound,
                            setIsSearchFlyout: l.XI.bound,
                            setSelectedCategory: l.XI.bound,
                            getSelectedCategory: l.XI.bound,
                            onClickOutsideFlyout: l.XI.bound,
                            refreshCategory: l.XI.bound,
                            variables_blocks_count: l.EW,
                            first_get_variable_block_index: l.EW
                        }), this.root_store = e
                    }
                }
                let eO = Object.freeze({
                    NORMAL: 0,
                    LOADING: 1,
                    COMPLETED: 2
                });
                var eD = i(34399),
                    eB = i(40708);
                class eL {
                    setIsAuthorized(e) {
                        this.is_authorised = e
                    }
                    async signIn() {
                        this.is_authorised || await this.client.requestAccessToken()
                    }
                    async signOut() {
                        if (this.access_token) {
                            var e, t, i, s, o, r, a, n;
                            await (null == (i = window) || null == (t = i.gapi) || null == (e = t.client) ? void 0 : e.setToken({
                                access_token: ""
                            })), localStorage.getItem("google_access_token") && (await (null == (a = window) || null == (r = a.google) || null == (o = r.accounts) || null == (s = o.oauth2) ? void 0 : s.revoke(this.access_token)), null == (n = localStorage) || n.removeItem("google_access_token")), this.access_token = ""
                        }
                        this.setIsAuthorized(!1)
                    }
                    getPickerLanguage() {
                        let e = (0, p.dn)();
                        return "zhTw" === e ? "zh-TW" : "zhCn" === e ? "zh-CN" : e
                    }
                    async saveFile(e) {
                        try {
                            await this.signIn(), this.access_token && gapi.client.setToken({
                                access_token: this.access_token
                            }), await this.checkFolderExists(), await this.createSaveFilePicker("application/vnd.google-apps.folder", (0, p.kg)("Select a folder"), e)
                        } catch (e) {
                            401 === e.status && this.signOut()
                        }
                    }
                    async loadFile() {
                        if (this.is_google_drive_token_valid) {
                            await this.signIn(), this.access_token && gapi.client.setToken({
                                access_token: this.access_token
                            });
                            try {
                                await gapi.client.drive.files.list({
                                    pageSize: 10,
                                    fields: "files(id, name)"
                                })
                            } catch (o) {
                                var e, t, i, s;
                                if ((null == o ? void 0 : o.status) === 401) {
                                    await this.signOut();
                                    let e = document.getElementsByClassName("picker-dialog-content")[0],
                                        t = null == e ? void 0 : e.parentNode;
                                    e && t && (null == t ? void 0 : t.contains(e)) && (null == t || t.removeChild(e)), null == e || null == (s = e.parentNode) || s.removeChild(e);
                                    let i = document.getElementsByClassName("picker-dialog-bg");
                                    if (i.length)
                                        for (let e = 0; e < i.length; e++) i[e].style.display = "none"
                                }(0, eD.uv)({
                                    upload_provider: "google_drive",
                                    upload_id: this.upload_id,
                                    upload_type: "not_found",
                                    error_message: null == o || null == (t = o.result) || null == (e = t.error) ? void 0 : e.message,
                                    error_code: null == o || null == (i = o.status) ? void 0 : i.toString()
                                })
                            }
                            return await this.createLoadFilePicker("text/xml,application/xml", (0, p.kg)("Select a Defen Traders Strategy"))
                        }
                    }
                    async checkFolderExists() {
                        var e;
                        let {
                            files: t
                        } = gapi.client.drive, i = await t.list({
                            q: "trashed=false"
                        }), s = "application/vnd.google-apps.folder";
                        (null == (e = i.result.files) ? void 0 : e.find(e => e.mimeType === s)) || await t.create({
                            resource: {
                                name: this.bot_folder_name,
                                mimeType: s
                            },
                            fields: "id"
                        })
                    }
                    createSaveFilePicker(e, t, i) {
                        let {
                            setButtonStatus: s
                        } = this.root_store.save_modal;
                        return new Promise(o => {
                            let r = e => {
                                if (e.action === google.picker.Action.PICKED) {
                                    let t = e.docs[0].id,
                                        r = new Blob([i.content], {
                                            type: i.mimeType
                                        }),
                                        a = JSON.stringify({
                                            name: i.name,
                                            mimeType: i.mimeType,
                                            parents: [t]
                                        }),
                                        n = new FormData;
                                    n.append("metadata", new Blob([a], {
                                        type: "application/json"
                                    })), n.append("file", r);
                                    let l = new XMLHttpRequest;
                                    l.responseType = "json", l.open("POST", "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart"), l.setRequestHeader("Authorization", `Bearer ${this.access_token}`), l.onload = () => {
                                        401 === l.status && this.signOut(), s(eO.NORMAL), o()
                                    }, l.send(n)
                                } else e.action === google.picker.Action.CANCEL && s(eO.NORMAL)
                            };
                            this.showGoogleDriveFilePicker(!0, e, t, r)
                        })
                    }
                    createLoadFilePicker(e, t) {
                        return new Promise(i => {
                            let s = async e => {
                                if (e.action === google.picker.Action.PICKED) {
                                    let t = e.docs[0];
                                    (null == t ? void 0 : t.driveError) === "NETWORK" && (0, eD.uv)({
                                        upload_provider: "google_drive",
                                        upload_id: this.upload_id,
                                        upload_type: "not_found",
                                        error_message: "File not found",
                                        error_code: "404"
                                    });
                                    let s = t.name,
                                        o = t.id,
                                        {
                                            files: r
                                        } = gapi.client.drive,
                                        a = await r.get({
                                            alt: "media",
                                            fileId: o
                                        });
                                    i({
                                        xml_doc: a.body,
                                        file_name: s
                                    });
                                    let n = (0, eB.Oj)(a.body);
                                    (0, eD.ot)({
                                        upload_provider: "google_drive",
                                        upload_type: n,
                                        upload_id: this.upload_id
                                    })
                                }
                            };
                            this.showGoogleDriveFilePicker(!1, e, t, s)
                        })
                    }
                    showGoogleDriveFilePicker(e, t, i, s) {
                        let o = new google.picker.DocsView;
                        o.setIncludeFolders(!0), o.setMimeTypes(t), e && o.setSelectFolderEnabled(!0), new google.picker.PickerBuilder().setOrigin(`${window.location.protocol}//${window.location.host}`).setTitle((0, p.kg)(i)).setLocale(this.getPickerLanguage()).setAppId(this.app_id).setOAuthToken(this.access_token).addView(o).setDeveloperKey(this.api_key).setSize(1051, 650).setCallback(s).build().setVisible(!0)
                    }
                    constructor(e) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "bot_folder_name", void 0), (0, a._)(this, "client_id", void 0), (0, a._)(this, "app_id", void 0), (0, a._)(this, "api_key", void 0), (0, a._)(this, "scope", void 0), (0, a._)(this, "discovery_docs", ""), (0, a._)(this, "client", void 0), (0, a._)(this, "access_token", void 0), (0, a._)(this, "upload_id", void 0), (0, a._)(this, "is_google_drive_token_valid", !0), (0, a._)(this, "is_authorised", !!localStorage.getItem("google_access_token")), (0, a._)(this, "setGoogleDriveTokenValid", e => {
                            this.is_google_drive_token_valid = e
                        }), (0, a._)(this, "setKey", () => {
                            let {
                                SCOPE: e,
                                DISCOVERY_DOCS: t
                            } = (0, u.config)().GOOGLE_DRIVE;
                            this.client_id = void 0, this.app_id = void 0, this.api_key = void 0, this.scope = e, this.discovery_docs = t
                        }), (0, a._)(this, "initialise", () => {
                            gapi.load("client:picker", () => gapi.client.load(this.discovery_docs))
                        }), (0, a._)(this, "setGoogleDriveTokenExpiry", e => {
                            let t = Math.floor(Date.now() / 1e3);
                            localStorage.setItem("google_access_token_expiry", (t + e).toString())
                        }), (0, a._)(this, "initialiseClient", () => {
                            this.client = google.accounts.oauth2.initTokenClient({
                                client_id: this.client_id,
                                scope: this.scope,
                                callback: e => {
                                    (null == e ? void 0 : e.access_token) && !(null == e ? void 0 : e.error) && (this.access_token = e.access_token, this.setIsAuthorized(!0), localStorage.setItem("google_access_token", e.access_token), this.setGoogleDriveTokenExpiry(null == e ? void 0 : e.expires_in), this.setGoogleDriveTokenValid(!0))
                                }
                            })
                        }), (0, a._)(this, "verifyGoogleDriveAccessToken", async () => {
                            var e;
                            let t = null == (e = localStorage) ? void 0 : e.getItem("google_access_token_expiry");
                            return t ? Math.floor(Date.now() / 1e3) > Number(t) ? (this.signOut(), this.setGoogleDriveTokenValid(!1), localStorage.removeItem("google_access_token_expiry"), localStorage.removeItem("google_access_token"), (0, R.N)((0, O.UC)().google_drive_error, void 0, {
                                closeButton: !1
                            }), "not_verified") : "verified" : "not_verified"
                        }), (0, a._)(this, "onDriveConnect", async () => {
                            this.is_authorised ? this.signOut() : this.signIn()
                        }), (0, l.Gn)(this, {
                            is_authorised: l.sH,
                            upload_id: l.sH,
                            is_google_drive_token_valid: l.sH,
                            setIsAuthorized: l.XI.bound,
                            saveFile: l.XI.bound,
                            loadFile: l.XI.bound,
                            setKey: l.XI.bound,
                            initialise: l.XI.bound,
                            signIn: l.XI.bound,
                            signOut: l.XI.bound,
                            getPickerLanguage: l.XI.bound,
                            checkFolderExists: l.XI.bound,
                            createSaveFilePicker: l.XI.bound,
                            createLoadFilePicker: l.XI.bound,
                            showGoogleDriveFilePicker: l.XI.bound,
                            setGoogleDriveTokenValid: l.XI.bound,
                            verifyGoogleDriveAccessToken: l.XI.bound,
                            onDriveConnect: l.XI
                        }), this.root_store = e, this.bot_folder_name = `Binary Bot - ${(0,p.kg)("Strategies")}`, this.setKey(), this.client = null, this.access_token = localStorage.getItem("google_access_token") ? ? "", setTimeout(() => {
                            (0, u.importExternal)("https://accounts.google.com/gsi/client").then(() => this.initialiseClient()), (0, u.importExternal)("https://apis.google.com/js/api.js").then(() => this.initialise())
                        }, 3e3)
                    }
                }
                var eP = i(78414),
                    eN = i(20332),
                    ej = i(39706),
                    eU = i(92202),
                    eM = i(46942),
                    eH = i.n(eM),
                    eF = i(73777);
                let eW = e => {
                        let {
                            array: t,
                            open_ids: i,
                            setOpenIds: s
                        } = e;
                        return (0, o.jsx)(r.Fragment, {
                            children: t.map((e, t) => {
                                var r;
                                return Array.isArray(null == e ? void 0 : e.value) ? (0, o.jsxs)("div", {
                                    className: "dc-expansion-panel__content-array",
                                    children: [(0, o.jsxs)("div", {
                                        className: eH()("dc-expansion-panel__content-array", {
                                            "dc-expansion-panel__content-active": i.includes(e.id)
                                        }),
                                        children: [(0, o.jsx)("span", {
                                            className: "dc-expansion-panel__content-array-item-index",
                                            children: `${t+1}: `
                                        }), "(", `${e.value.length}`, ")", (0, o.jsx)(ej.I, {
                                            className: "dc-expansion-panel__content-chevron-icon",
                                            icon: "IcChevronRight",
                                            onClick: () => {
                                                var t;
                                                return t = e.id, void(i.includes(t) ? s(i.filter(e => e !== t)) : s([...i, t]))
                                            }
                                        })]
                                    }), i.includes(e.id) ? (0, o.jsx)(eW, {
                                        array: e.value,
                                        open_ids: i,
                                        setOpenIds: s
                                    }) : null]
                                }, t) : (0, o.jsxs)("div", {
                                    className: "dc-expansion-panel__content-array",
                                    children: [(0, o.jsx)("span", {
                                        className: "dc-expansion-panel__content-array-item-index",
                                        children: `${t+1}: `
                                    }), null == e || null == (r = e.value) ? void 0 : r.toString()]
                                }, t)
                            })
                        })
                    },
                    e$ = e => {
                        let {
                            message: t,
                            onResize: i
                        } = e, [s, a] = r.useState([]), [n, l] = r.useState(!1);
                        return r.useEffect(() => {
                            "function" == typeof i && i()
                        }, [n, i]), (0, o.jsxs)(r.Fragment, {
                            children: [(0, o.jsxs)("div", {
                                className: eH()("dc-expansion-panel__header-container", {
                                    "dc-expansion-panel__header-active": n
                                }),
                                children: [t.header, (0, o.jsx)(eF.A, {
                                    className: "dc-expansion-panel__header-chevron-icon",
                                    onClick: () => {
                                        l(!n)
                                    },
                                    height: "24px",
                                    width: "24px"
                                })]
                            }), n && (Array.isArray(t.content) ? (0, o.jsx)(eW, {
                                array: t.content,
                                open_ids: s,
                                setOpenIds: a
                            }) : t.content)]
                        })
                    },
                    eX = (e, t, i, s) => {
                        i((e => {
                            let {
                                unique_id: t,
                                type: i,
                                message: s,
                                btn_text: r,
                                onClick: a
                            } = e;
                            return (0, o.jsxs)(o.Fragment, {
                                children: [(0, o.jsxs)("div", {
                                    className: "notify__item-container",
                                    children: [(0, o.jsx)(ej.I, {
                                        icon: (e => {
                                            switch (e) {
                                                case "error":
                                                    return "IcAlertDanger";
                                                case "warn":
                                                default:
                                                    return "IcAlertWarning";
                                                case "info":
                                                    return "IcAlertInfo"
                                            }
                                        })(i),
                                        size: "22"
                                    }, `${t}_icon`), (0, o.jsx)("div", {
                                        className: "notify__item-message",
                                        children: s
                                    }, `${t}_text`)]
                                }, `${t}_message`), (0, o.jsx)(eU.A, {
                                    className: "notify__item-button",
                                    text: r,
                                    onClick: a,
                                    has_effect: !0,
                                    secondary: !0
                                }, `${t}_btn`)]
                            })
                        })({
                            unique_id: t,
                            type: "error",
                            message: e,
                            btn_text: (0, p.kg)("Go to block"),
                            onClick: () => {
                                s()
                            }
                        }))
                    },
                    eG = e => e.map((e, t) => ({
                        id: `${Date.now()}-${t}`,
                        value: e && Array.isArray(e) ? eG(e) : e
                    }));
                var eV = i(32992),
                    eq = i.n(eV);
                let eY = (e, t, i) => t && ez(e, i)[t] || i,
                    ez = (e, t) => {
                        try {
                            let t = sessionStorage.getItem(e),
                                i = eq().decompress(t),
                                s = JSON.parse(i);
                            if (s) return s
                        } catch (e) {}
                        return t
                    },
                    eK = (e, t) => {
                        try {
                            let i = eq().compress(JSON.stringify(t));
                            sessionStorage.setItem(e, i)
                        } catch (e) {
                            console.warn("Could not write to storage.")
                        }
                    };
                class eJ {
                    restoreStoredJournals() {
                        let {
                            loginid: e
                        } = this.core.client;
                        this.journal_filters = (0, m.PL)("journal_filter") ? ? this.filters.map(e => e.id), this.unfiltered_messages = eY(this.JOURNAL_CACHE, e, [])
                    }
                    getServerTime() {
                        var e;
                        return null == (e = this.core) ? void 0 : e.common.server_time.get()
                    }
                    toggleFilterDialog() {
                        this.is_filter_dialog_visible = !this.is_filter_dialog_visible
                    }
                    onLogSuccess(e) {
                        let {
                            log_type: t,
                            extra: i
                        } = e;
                        this.pushMessage(t, u.MessageTypes.SUCCESS, "", i)
                    }
                    onError(e) {
                        this.pushMessage(e, u.MessageTypes.ERROR)
                    }
                    onNotify(e) {
                        let {
                            run_panel: t,
                            dbot: i
                        } = this.root_store, {
                            message: s,
                            className: r,
                            message_type: a,
                            sound: n,
                            block_id: l,
                            variable_name: c
                        } = e;
                        ((e, t, i, s) => {
                            let {
                                message: r,
                                block_id: a,
                                variable_name: n
                            } = e;
                            if (void 0 === r && null != n) return eX((0, p.kg)("Variable '{{variable_name}}' has no value. Please set a value for variable '{{variable_name}}' to notify.", {
                                variable_name: n
                            }), a, t, i), !0;
                            if (null === r) return s("NULL"), !0;
                            if (Object.is(r, NaN)) return eX((0, p.kg)("Tried to perform an invalid operation."), a, t, i), !0;
                            if (Array.isArray(r)) {
                                let e, t = r.length;
                                return s((e = {
                                    header: "null" !== n ? `${n}: (${t})` : (0, p.kg)("List: ({{message_length}})", {
                                        message_length: t
                                    }),
                                    content: eG(r)
                                }, t => (0, o.jsx)(e$, {
                                    message: e,
                                    onResize: t
                                }))), !0
                            }
                            return "boolean" == typeof r && (s(r.toString()), !0)
                        })({
                            message: s,
                            block_id: l,
                            variable_name: c
                        }, t.showErrorMessage, () => i.centerAndHighlightBlock(l, !0), e => this.pushMessage(e, a || u.MessageTypes.NOTIFY, r)) || this.pushMessage(s, a || u.MessageTypes.NOTIFY, r), this.playAudio(n)
                    }
                    pushMessage(e, t, i) {
                        let s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                            {
                                client: o
                            } = this.core,
                            {
                                loginid: r,
                                account_list: a
                            } = o;
                        if (r) {
                            let e = null == a ? void 0 : a.find(e => (null == e ? void 0 : e.loginid) === r);
                            s.current_currency = (null == e ? void 0 : e.is_virtual) ? "Demo" : null == e ? void 0 : e.currency
                        } else if (e === u.LogTypes.WELCOME) return;
                        let n = (0, d.Yq5)(this.getServerTime()),
                            l = (0, d.Yq5)(this.getServerTime(), "HH:mm:ss [GMT]"),
                            c = (0, eP.A)();
                        this.unfiltered_messages.unshift({
                            date: n,
                            time: l,
                            message: e,
                            message_type: t,
                            className: i,
                            unique_id: c,
                            extra: s
                        }), this.unfiltered_messages = this.unfiltered_messages.slice()
                    }
                    get filtered_messages() {
                        return this.unfiltered_messages.filter(e => this.journal_filters.length && this.journal_filters.some(t => e.message_type === t))
                    }
                    get checked_filters() {
                        return this.journal_filters.filter(e => null != e)
                    }
                    filterMessage(e, t) {
                        e ? this.journal_filters.push(t) : this.journal_filters.splice(this.journal_filters.indexOf(t), 1), (0, m.Gf)("journal_filter", this.journal_filters)
                    }
                    clear() {
                        this.unfiltered_messages = this.unfiltered_messages.slice(0, 0)
                    }
                    registerReactions() {
                        let e = this.core.client,
                            t = (0, l.mJ)(() => this.unfiltered_messages, t => {
                                let i = ez(this.JOURNAL_CACHE, {});
                                i[e.loginid] = null == t ? void 0 : t.slice(0, 5e3), eK(this.JOURNAL_CACHE, i)
                            }),
                            i = (0, l.mJ)(() => null == e ? void 0 : e.loginid, async t => {
                                await (0, l.z7)(() => {
                                    var i;
                                    return !!(null == (i = e.account_list) ? void 0 : i.find(e => e.loginid === t))
                                }), this.unfiltered_messages = eY(this.JOURNAL_CACHE, t, []), 0 === this.unfiltered_messages.length ? this.pushMessage(u.LogTypes.WELCOME, u.MessageTypes.SUCCESS, "journal__text") : this.unfiltered_messages.length > 0 && this.pushMessage(u.LogTypes.WELCOME_BACK, u.MessageTypes.SUCCESS, "journal__text")
                            }, {
                                fireImmediately: !0
                            });
                        return () => {
                            t(), i()
                        }
                    }
                    constructor(e, t) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "core", void 0), (0, a._)(this, "disposeReactionsFn", void 0), (0, a._)(this, "JOURNAL_CACHE", "journal_cache"), (0, a._)(this, "is_filter_dialog_visible", !1), (0, a._)(this, "filters", [{
                            id: u.MessageTypes.ERROR,
                            label: (0, p.kg)("Errors")
                        }, {
                            id: u.MessageTypes.NOTIFY,
                            label: (0, p.kg)("Notifications")
                        }, {
                            id: u.MessageTypes.SUCCESS,
                            label: (0, p.kg)("System")
                        }]), (0, a._)(this, "journal_filters", []), (0, a._)(this, "unfiltered_messages", []), (0, a._)(this, "playAudio", e => {
                            e !== (0, eN.$)().lists.NOTIFICATION_SOUND[0][1] && document.getElementById(e).play()
                        }), (0, l.Gn)(this, {
                            is_filter_dialog_visible: l.sH,
                            journal_filters: l.sH.shallow,
                            filters: l.sH.shallow,
                            unfiltered_messages: l.sH.shallow,
                            toggleFilterDialog: l.XI.bound,
                            onLogSuccess: l.XI.bound,
                            onError: l.XI.bound,
                            onNotify: l.XI.bound,
                            pushMessage: l.XI.bound,
                            filtered_messages: l.EW,
                            getServerTime: l.XI.bound,
                            playAudio: l.XI.bound,
                            checked_filters: l.EW,
                            filterMessage: l.XI.bound,
                            clear: l.XI.bound,
                            registerReactions: l.XI.bound,
                            restoreStoredJournals: l.XI.bound
                        }), this.root_store = e, this.core = t, this.disposeReactionsFn = this.registerReactions(), this.restoreStoredJournals()
                    }
                }
                var eQ = i(39571),
                    eZ = i(73842),
                    e0 = i(55875);
                class e1 {
                    get preview_workspace() {
                        return this.tab_name === eZ.C.TAB_LOCAL ? this.local_workspace : this.tab_name === eZ.C.TAB_RECENT ? this.recent_workspace : null
                    }
                    get selected_strategy() {
                        return this.dashboard_strategies.find(e => e.id === this.selected_strategy_id) ? ? this.dashboard_strategies[0]
                    }
                    get tab_name() {
                        if (this.core.ui.is_mobile) {
                            if (0 === this.active_index) return eZ.C.TAB_LOCAL;
                            if (1 === this.active_index) return eZ.C.TAB_GOOGLE
                        }
                        return 0 === this.active_index ? eZ.C.TAB_RECENT : 1 === this.active_index ? eZ.C.TAB_LOCAL : 2 === this.active_index ? eZ.C.TAB_GOOGLE : ""
                    }
                    constructor(e, t) {
                        var i = this;
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "core", void 0), (0, a._)(this, "imported_strategy_type", "pending"), (0, a._)(this, "recent_workspace", null), (0, a._)(this, "local_workspace", null), (0, a._)(this, "drop_zone", void 0), (0, a._)(this, "active_index", 0), (0, a._)(this, "is_load_modal_open", !1), (0, a._)(this, "is_explanation_expand", !1), (0, a._)(this, "is_open_button_loading", !1), (0, a._)(this, "is_open_button_disabled", !1), (0, a._)(this, "loaded_local_file", null), (0, a._)(this, "recent_strategies", []), (0, a._)(this, "dashboard_strategies", []), (0, a._)(this, "selected_strategy_id", ""), (0, a._)(this, "is_strategy_loaded", !1), (0, a._)(this, "is_delete_modal_open", !1), (0, a._)(this, "is_strategy_removed", !1), (0, a._)(this, "current_workspace_id", ""), (0, a._)(this, "upload_id", ""), (0, a._)(this, "setOpenButtonDisabled", e => {
                            this.is_open_button_disabled = e
                        }), (0, a._)(this, "getSelectedStrategyID", e => {
                            this.current_workspace_id = e
                        }), (0, a._)(this, "setDashboardStrategies", e => {
                            this.dashboard_strategies = e, e.length || (this.selected_strategy_id = "")
                        }), (0, a._)(this, "getDashboardStrategies", async () => {
                            let e = await (0, u.getSavedWorkspaces)();
                            this.dashboard_strategies = e
                        }), (0, a._)(this, "onDriveOpen", async () => {
                            let {
                                google_drive: e
                            } = this.root_store, {
                                verifyGoogleDriveAccessToken: t
                            } = e;
                            if ("not_verified" === await t()) return;
                            e && (e.upload_id = (0, eP.A)()), (0, eD.xH)({
                                upload_provider: "google_drive",
                                upload_id: e.upload_id
                            });
                            let {
                                loadFile: i
                            } = this.root_store.google_drive, s = await i();
                            if (!s) return;
                            let o = null == s ? void 0 : s.xml_doc,
                                r = null == s ? void 0 : s.file_name;
                            await (0, u.load)({
                                block_string: o,
                                file_name: r,
                                workspace: window.Blockly.derivWorkspace,
                                from: u.save_types.GOOGLE_DRIVE,
                                drop_event: null,
                                strategy_id: null,
                                showIncompatibleStrategyDialog: null
                            });
                            let {
                                active_tab: a
                            } = this.root_store.dashboard;
                            1 === a && this.toggleLoadModal(), this.root_store.dashboard.is_dialog_open = !1
                        }), (0, a._)(this, "onEntered", () => {
                            if (0 === this.recent_strategies.length || this.tab_name !== eZ.C.TAB_RECENT) return;
                            this.setOpenButtonDisabled(!0);
                            let {
                                blockly_store: e
                            } = this.root_store, {
                                setLoading: t
                            } = e;
                            t(!0), this.loadStrategyOnModalRecentPreview(this.selected_strategy_id), this.updateXmlValuesOnStrategySelection(), this.setOpenButtonDisabled(!1)
                        }), (0, a._)(this, "onLoadModalClose", () => {
                            this.local_workspace && (this.local_workspace = null), this.setActiveTabIndex(0), this.setLoadedLocalFile(null)
                        }), (0, a._)(this, "onZoomInOutClick", e => {
                            this.preview_workspace && this.preview_workspace.zoomCenter(e ? 1 : -1)
                        }), (0, a._)(this, "setActiveTabIndex", e => {
                            this.active_index = e
                        }), (0, a._)(this, "setLoadedLocalFile", e => {
                            this.loaded_local_file = e
                        }), (0, a._)(this, "setRecentStrategies", e => {
                            this.recent_strategies = e
                        }), (0, a._)(this, "refreshStrategies", () => {
                            this.setRecentStrategies(this.recent_strategies)
                        }), (0, a._)(this, "setSelectedStrategyId", e => {
                            this.selected_strategy_id = e
                        }), (0, a._)(this, "toggleExplanationExpand", () => {
                            this.is_explanation_expand = !this.is_explanation_expand
                        }), (0, a._)(this, "toggleLoadModal", () => {
                            var e;
                            this.is_load_modal_open = !this.is_load_modal_open, null == (e = this.recent_workspace) || e.dispose(), this.recent_workspace = null, this.setLoadedLocalFile(null)
                        }), (0, a._)(this, "toggleTourLoadModal", function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : !i.is_load_modal_open;
                            i.is_load_modal_open = e
                        }), (0, a._)(this, "updateListStrategies", e => {
                            e && (this.dashboard_strategies = e)
                        }), (0, a._)(this, "getSaveType", e => {
                            switch (e) {
                                case u.save_types.UNSAVED:
                                    return (0, p.kg)("Unsaved");
                                case u.save_types.LOCAL:
                                    return (0, p.kg)("Local");
                                case u.save_types.GOOGLE_DRIVE:
                                    return (0, p.kg)("Google Drive");
                                default:
                                    return (0, p.kg)("Unsaved")
                            }
                        }), (0, a._)(this, "onToggleDeleteDialog", e => {
                            this.is_delete_modal_open = e
                        }), (0, a._)(this, "resetBotBuilderStrategy", () => {
                            let e = window.Blockly.derivWorkspace;
                            e && (window.Blockly.derivWorkspace.asyncClear(), window.Blockly.Xml.domToWorkspace(window.Blockly.utils.xml.textToDom(e.cached_xml.main), e), window.Blockly.derivWorkspace.strategy_to_load = e.cached_xml.main)
                        }), (0, a._)(this, "loadStrategyToBuilder", async e => {
                            if (null == e ? void 0 : e.id) {
                                var t;
                                await (0, u.load)({
                                    block_string: e.xml,
                                    strategy_id: e.id,
                                    file_name: e.name,
                                    workspace: null == (t = window.Blockly) ? void 0 : t.derivWorkspace,
                                    from: e.save_type,
                                    drop_event: {},
                                    showIncompatibleStrategyDialog: !1
                                }), window.Blockly.derivWorkspace.strategy_to_load = e.xml
                            }
                        }), (0, a._)(this, "refreshStrategiesTheme", async () => {
                            var e, t, i, s;
                            this.recent_workspace && (this.recent_workspace.RTL = (0, eQ.Qq)()), await (0, u.load)({
                                block_string: null == (e = this.selected_strategy) ? void 0 : e.xml,
                                drop_event: {},
                                workspace: this.recent_workspace,
                                file_name: null == (t = this.selected_strategy) ? void 0 : t.name,
                                strategy_id: null == (i = this.selected_strategy) ? void 0 : i.id,
                                from: null == (s = this.selected_strategy) ? void 0 : s.save_type,
                                showIncompatibleStrategyDialog: !1
                            })
                        }), (0, a._)(this, "loadFileFromRecent", async () => {
                            var e;
                            if (this.is_open_button_loading = !0, !this.selected_strategy) {
                                window.Blockly.derivWorkspace.asyncClear(), window.Blockly.Xml.domToWorkspace(window.Blockly.utils.xml.textToDom(window.Blockly.derivWorkspace.strategy_to_load), window.Blockly.derivWorkspace), this.is_open_button_loading = !1;
                                return
                            }(0, u.removeExistingWorkspace)(this.selected_strategy.id), await (0, u.load)({
                                block_string: null == (e = this.selected_strategy) ? void 0 : e.xml,
                                strategy_id: this.selected_strategy.id,
                                file_name: this.selected_strategy.name,
                                workspace: window.Blockly.derivWorkspace,
                                from: this.selected_strategy.save_type,
                                drop_event: {},
                                showIncompatibleStrategyDialog: !1
                            }), (await (0, u.getSavedWorkspaces)()).map(e => {
                                let {
                                    xml: t,
                                    id: i
                                } = e;
                                this.selected_strategy.id === i && (window.Blockly.derivWorkspace.strategy_to_load = t)
                            }), this.is_open_button_loading = !1
                        }), (0, a._)(this, "loadFileFromLocal", () => {
                            this.is_open_button_loading = !0, this.loaded_local_file && this.readFile(!1, {}, this.loaded_local_file)
                        }), (0, a._)(this, "onActiveIndexChange", () => {
                            this.setOpenButtonDisabled(!0), this.tab_name === eZ.C.TAB_RECENT ? (this.loadStrategyOnModalRecentPreview(this.selected_strategy_id), this.updateXmlValuesOnStrategySelection()) : this.recent_workspace && setTimeout(() => {
                                var e;
                                null == (e = this.recent_workspace) || e.dispose(), this.recent_workspace = null
                            }), this.tab_name === eZ.C.TAB_LOCAL ? !this.drop_zone && (this.drop_zone = document.querySelector("load-strategy__local-dropzone-area"), this.drop_zone && this.drop_zone.addEventListener("drop", e => this.handleFileChange(e, !1))) : this.local_workspace && setTimeout(() => {
                                var e;
                                null == (e = this.local_workspace) || e.dispose(), this.local_workspace = null, this.setLoadedLocalFile(null)
                            }, 0), this.tab_name !== eZ.C.TAB_LOCAL && this.drop_zone && this.drop_zone.removeEventListener("drop", e => this.handleFileChange(e, !1)), this.setOpenButtonDisabled(!1)
                        }), (0, a._)(this, "handleFileChange", function(e) {
                            let t, s = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
                            i.imported_strategy_type = "pending", i.upload_id = (0, eP.A)(), "drop" === e.type ? (e.stopPropagation(), e.preventDefault(), {
                                files: t
                            } = e.dataTransfer) : {
                                files: t
                            } = e.target;
                            let [o] = t;
                            if (!s)
                                if (!o.name.includes("xml")) return !1;
                                else i.setLoadedLocalFile(o), i.getDashboardStrategies();
                            return i.readFile(!s, e, o), e.target.value = "", !0
                        }), (0, a._)(this, "readFile", (e, t, i) => {
                            let s = new FileReader,
                                o = (null == i ? void 0 : i.name.replace(/\.[^/.]+$/, "")) || "";
                            s.onload = (0, l.XI)(async e => {
                                var i;
                                let s = {
                                    block_string: null == e || null == (i = e.target) ? void 0 : i.result,
                                    drop_event: t,
                                    from: u.save_types.LOCAL,
                                    workspace: null,
                                    file_name: o,
                                    strategy_id: "",
                                    showIncompatibleStrategyDialog: !1
                                };
                                this.local_workspace && (this.local_workspace.dispose(), this.local_workspace = null), this.loadStrategyOnModalLocalPreview(s), this.setOpenButtonDisabled(!1)
                            }), s.readAsText(i)
                        }), (0, a._)(this, "saveStrategyToLocalStorage", async () => {
                            var e;
                            let {
                                save_modal: t
                            } = this.root_store, {
                                updateBotName: i
                            } = t, {
                                convertedDom: s,
                                from: o,
                                file_name: r
                            } = window.Blockly.xmlValues;
                            i(r), await (0, u.saveWorkspaceToRecent)(s, o);
                            let a = await (0, u.getSavedWorkspaces)();
                            (null == a ? void 0 : a.length) > 0 && this.setSelectedStrategyId(null == (e = a[0]) ? void 0 : e.id)
                        }), (0, a._)(this, "loadStrategyOnBotBuilder", async () => {
                            let {
                                strategy_id: e = window.Blockly.utils.idGenerator.genUid(),
                                convertedDom: t,
                                block_string: i
                            } = window.Blockly.xmlValues, s = window.Blockly.derivWorkspace;
                            window.Blockly.Xml.clearWorkspaceAndLoadFromXml(t, s), s.cleanUp(), s.clearUndo(), s.current_strategy_id = e;
                            let o = (0, eB.Oj)(i ? ? "");
                            (0, eD.ot)({
                                upload_provider: "my_computer",
                                upload_type: o,
                                upload_id: this.upload_id
                            })
                        }), (0, a._)(this, "updateXmlValuesOnStrategySelection", () => {
                            var e, t, i, s, o, r, a;
                            0 !== this.recent_strategies.length && (0, h.T2)({
                                strategy_id: this.selected_strategy_id,
                                convertedDom: null == (o = window) || null == (s = o.Blockly) || null == (i = s.utils) || null == (t = i.xml) ? void 0 : t.textToDom(null == (e = this.selected_strategy) ? void 0 : e.xml),
                                file_name: null == (r = this.selected_strategy) ? void 0 : r.name,
                                from: (null == (a = this.selected_strategy) ? void 0 : a.save_type) || u.save_types.UNSAVED
                            })
                        }), (0, a._)(this, "loadStrategyOnModalRecentPreview", async e => {
                            var t, i, s, o, r, a, n, l, c, d;
                            if (this.setOpenButtonDisabled(!0), 0 === this.recent_strategies.length || this.tab_name !== eZ.C.TAB_RECENT) return;
                            let {
                                blockly_store: u
                            } = this.root_store, {
                                setLoading: p
                            } = u, _ = { ...h.NZ,
                                theme: null == (s = window) || null == (i = s.Blockly) || null == (t = i.Themes) ? void 0 : t.zelos_renderer
                            };
                            this.setLoadedLocalFile(null), this.setSelectedStrategyId(e), await (0, e0.t)("#load-strategy__blockly-container");
                            let g = document.getElementById("load-strategy__blockly-container");
                            if (g) {
                                this.recent_workspace || (this.recent_workspace = window.Blockly.inject(g, _)), this.recent_workspace.RTL = (0, eQ.Qq)();
                                let e = null == (n = window.Blockly) || null == (a = n.utils) || null == (r = a.xml) ? void 0 : r.textToDom(null == (o = this.selected_strategy) ? void 0 : o.xml),
                                    t = null == (l = window.Blockly) ? void 0 : l.getMainWorkspace();
                                null == (d = window.Blockly) || null == (c = d.Xml) || c.clearWorkspaceAndLoadFromXml(e, t)
                            }
                            p(!1), this.setOpenButtonDisabled(!1)
                        }), (0, a._)(this, "loadStrategyOnModalLocalPreview", async e => {
                            var t, i, s;
                            this.setOpenButtonDisabled(!0);
                            let o = { ...h.NZ,
                                theme: null == (s = window) || null == (i = s.Blockly) || null == (t = i.Themes) ? void 0 : t.zelos_renderer
                            };
                            await (0, e0.t)("#load-strategy__blockly-container");
                            let r = document.getElementById("load-strategy__blockly-container");
                            this.local_workspace || (this.local_workspace = await window.Blockly.inject(r, o)), e.workspace = this.local_workspace, e.workspace && (e.workspace.RTL = (0, eQ.Qq)());
                            let a = (0, eB.Oj)((null == e ? void 0 : e.block_string) ? ? ""),
                                n = await (0, u.load)(e);
                            (null == n ? void 0 : n.error) ? (null == n ? void 0 : n.error) && (0, eD.uv)({
                                upload_provider: "my_computer",
                                upload_id: this.upload_id,
                                upload_type: a,
                                error_message: n.error
                            }) : (0, eD.xH)({
                                upload_provider: "my_computer",
                                upload_id: this.upload_id
                            })
                        }), (0, l.Gn)(this, {
                            active_index: l.sH,
                            is_load_modal_open: l.sH,
                            is_explanation_expand: l.sH,
                            is_strategy_loaded: l.sH,
                            is_delete_modal_open: l.sH,
                            is_strategy_removed: l.sH,
                            loaded_local_file: l.sH,
                            recent_strategies: l.sH,
                            dashboard_strategies: l.sH,
                            selected_strategy_id: l.sH,
                            current_workspace_id: l.sH,
                            upload_id: l.sH,
                            preview_workspace: l.EW,
                            selected_strategy: l.EW,
                            tab_name: l.EW,
                            is_open_button_disabled: l.sH,
                            setOpenButtonDisabled: l.XI.bound,
                            getSelectedStrategyID: l.XI.bound,
                            refreshStrategies: l.XI.bound,
                            loadStrategyToBuilder: l.XI.bound,
                            refreshStrategiesTheme: l.XI.bound,
                            handleFileChange: l.XI.bound,
                            loadFileFromRecent: l.XI.bound,
                            loadFileFromLocal: l.XI.bound,
                            imported_strategy_type: l.sH,
                            onActiveIndexChange: l.XI.bound,
                            onDriveOpen: l.XI.bound,
                            onEntered: l.XI.bound,
                            onLoadModalClose: l.XI.bound,
                            onZoomInOutClick: l.XI.bound,
                            setActiveTabIndex: l.XI.bound,
                            setLoadedLocalFile: l.XI.bound,
                            setRecentStrategies: l.XI.bound,
                            setSelectedStrategyId: l.XI.bound,
                            toggleExplanationExpand: l.XI.bound,
                            toggleLoadModal: l.XI.bound,
                            toggleTourLoadModal: l.XI.bound,
                            readFile: l.XI.bound,
                            resetBotBuilderStrategy: l.XI.bound,
                            setDashboardStrategies: l.XI.bound,
                            updateListStrategies: l.XI.bound,
                            onToggleDeleteDialog: l.XI,
                            loadStrategyOnModalRecentPreview: l.XI,
                            loadStrategyOnBotBuilder: l.XI,
                            saveStrategyToLocalStorage: l.XI,
                            updateXmlValuesOnStrategySelection: l.XI
                        }), this.root_store = e, this.core = t, (0, l.mJ)(() => this.active_index, () => this.onActiveIndexChange()), (0, l.mJ)(() => this.is_load_modal_open, async e => {
                            if (e) {
                                let e = await (0, u.getSavedWorkspaces)();
                                e && (this.setRecentStrategies(e), e.length > 0 && !this.selected_strategy_id && this.setSelectedStrategyId(e[0].id))
                            } else this.onLoadModalClose()
                        })
                    }
                }
                var e2 = i(75372),
                    e3 = i(24020);
                class e7 {
                    constructor(e) {
                        var t = this;
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "is_open", !1), (0, a._)(this, "selected_strategy", "MARTINGALE"), (0, a._)(this, "form_data", {
                            symbol: (0, u.config)().QUICK_STRATEGY.DEFAULT.symbol,
                            tradetype: (0, u.config)().QUICK_STRATEGY.DEFAULT.tradetype,
                            durationtype: (0, u.config)().QUICK_STRATEGY.DEFAULT.durationtype,
                            action: "RUN"
                        }), (0, a._)(this, "is_contract_dialog_open", !1), (0, a._)(this, "is_stop_bot_dialog_open", !1), (0, a._)(this, "current_duration_min_max", {
                            min: 0,
                            max: 10
                        }), (0, a._)(this, "loss_threshold_warning_data", {
                            show: !1
                        }), (0, a._)(this, "additional_data", {}), (0, a._)(this, "setAdditionalData", e => {
                            this.additional_data = { ...this.additional_data,
                                ...e
                            }
                        }), (0, a._)(this, "setLossThresholdWarningData", e => {
                            this.loss_threshold_warning_data = { ...this.loss_threshold_warning_data,
                                ...e
                            }
                        }), (0, a._)(this, "initializeLossThresholdWarningData", () => {
                            this.loss_threshold_warning_data = {
                                show: !1,
                                highlight_field: [],
                                already_shown: !1
                            }
                        }), (0, a._)(this, "setFormVisibility", e => {
                            this.is_open = e
                        }), (0, a._)(this, "setSelectedStrategy", e => {
                            this.selected_strategy = e
                        }), (0, a._)(this, "setValue", (e, t) => {
                            this.form_data[e] = t
                        }), (0, a._)(this, "setCurrentDurationMinMax", function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10;
                            t.current_duration_min_max = {
                                min: e,
                                max: i
                            }
                        }), (0, a._)(this, "onSubmit", async e => {
                            let {
                                contracts_for: t
                            } = (null === u.ApiHelpers || void 0 === u.ApiHelpers ? void 0 : u.ApiHelpers.instance) ? ? {};
                            if (!t) return;
                            let s = await t.getMarketBySymbol(e.symbol),
                                o = await t.getSubmarketBySymbol(e.symbol),
                                r = await t.getTradeTypeCategoryByTradeType(e.tradetype),
                                a = (0, e3.Y)()[this.selected_strategy],
                                n = await i(73397)(`./${a.name}.xml`),
                                l = window.Blockly.utils.xml.textToDom(n.default);
                            ((e, t, i, s) => {
                                if ("digits" === i || "highlowticks" === i) {
                                    let i = document.createElement("value");
                                    i.setAttribute("name", e), i.setAttribute("strategy_value", t);
                                    let o = document.createElement("shadow");
                                    o.setAttribute("type", "math_number_positive"), o.setAttribute("id", "p0O]7-M{ZORlORxGuIEb");
                                    let r = document.createElement("field");
                                    r.setAttribute("name", "NUM"), r.textContent = "0", o.appendChild(r), i.appendChild(o);
                                    let a = s.querySelector('value[name="AMOUNT"]');
                                    if (a) {
                                        let e = a.parentNode;
                                        e && e.insertBefore(i, a.nextSibling)
                                    }
                                }
                                if ("PREDICTION" === e && s) {
                                    let e = s.querySelector('block[type="trade_definition_tradeoptions"] > mutation');
                                    e && e.setAttribute("has_prediction", "true")
                                }
                            })("PREDICTION", "last_digit_prediction", r, l);
                            let {
                                unit: c,
                                action: d,
                                type: h,
                                growth_rate: p,
                                ..._
                            } = e, g = {
                                market: s,
                                submarket: o,
                                tradetypecat: r,
                                dalembert_unit: c,
                                oscar_unit: c,
                                type: "both",
                                ..._,
                                purchase: h,
                                growthrate: p ? p.toString() : void 0
                            };
                            Object.keys(g).forEach(e => {
                                let t = g[e];
                                if (isNaN(t) || "growthrate" === e) {
                                    let i, s;
                                    "string" == typeof t && (i = `${e.toUpperCase()}_LIST`, null == (s = null == l ? void 0 : l.querySelectorAll(`field[name="${i}"]`)) || s.forEach(e => {
                                        e.innerHTML = t
                                    }))
                                } else {
                                    let i;
                                    null == (i = null == l ? void 0 : l.querySelectorAll(`value[strategy_value="${e}"]`)) || i.forEach(i => {
                                        e.includes("boolean") ? t ? i.innerHTML = '<block type="logic_boolean"><field name="BOOL">TRUE</field></block>' : i.innerHTML = '<block type="logic_boolean"><field name="BOOL">FALSE</field></block>' : i.innerHTML = `<shadow type="math_number"><field name="NUM">${t}</field></shadow>`
                                    })
                                }
                            });
                            let {
                                derivWorkspace: m
                            } = Blockly;
                            "RUN" === d && (null == m || m.waitForBlockEvent({
                                block_type: "trade_definition",
                                event_type: window.Blockly.Events.BLOCK_CREATE,
                                timeout: 5e3
                            }).then(() => {
                                this.root_store.run_panel.onRunButtonClick()
                            })), this.setFormVisibility(!1), await (0, u.load)({
                                block_string: window.Blockly.Xml.domToText(l),
                                file_name: a.label,
                                workspace: m,
                                from: e2.e.UNSAVED,
                                drop_event: null,
                                strategy_id: null,
                                showIncompatibleStrategyDialog: null
                            })
                        }), (0, a._)(this, "toggleStopBotDialog", () => {
                            this.is_contract_dialog_open = !this.is_contract_dialog_open, this.is_stop_bot_dialog_open = !this.is_stop_bot_dialog_open, this.setFormVisibility(!1)
                        }), (0, l.Gn)(this, {
                            additional_data: l.sH,
                            current_duration_min_max: l.sH,
                            form_data: l.sH,
                            is_contract_dialog_open: l.sH,
                            is_open: l.sH,
                            is_stop_bot_dialog_open: l.sH,
                            initializeLossThresholdWarningData: l.XI,
                            selected_strategy: l.sH,
                            loss_threshold_warning_data: l.sH,
                            onSubmit: l.XI,
                            setAdditionalData: l.XI,
                            setCurrentDurationMinMax: l.XI,
                            setFormVisibility: l.XI,
                            setSelectedStrategy: l.XI,
                            setLossThresholdWarningData: l.XI,
                            setValue: l.XI,
                            toggleStopBotDialog: l.XI
                        }), this.root_store = e, (0, l.mJ)(() => this.is_open, () => {
                            this.is_open || (this.selected_strategy = "MARTINGALE")
                        })
                    }
                }
                var e5 = i(47967);
                let e4 = Object.freeze({
                        TRANSACTIONS: 0,
                        SUMMARY: 1,
                        JOURNAL: 2
                    }),
                    e8 = {
                        keep_current_contract: (0, o.jsx)(p.we, {
                            i18n_default_text: "Would you like to keep your current contract or close it? If you decide to keep it running, you can check and close it later on the <0>Reports</0> page.",
                            components: [(0, o.jsx)("a", {
                                className: "link",
                                rel: "noopener noreferrer",
                                target: "_blank",
                                href: "/reports/positions"
                            }, 0)]
                        })
                    };
                class e6 {
                    get is_stop_button_visible() {
                        return this.is_running || this.has_open_contract
                    }
                    get is_stop_button_disabled() {
                        return !this.is_contracy_buying_in_progress && [e5.H.PURCHASE_SENT, e5.H.IS_STOPPING].includes(this.contract_stage)
                    }
                    get is_clear_stat_disabled() {
                        var e;
                        let {
                            journal: t,
                            transactions: i
                        } = this.root_store;
                        return this.is_running || this.has_open_contract || 0 === t.unfiltered_messages.length && (null == i || null == (e = i.transactions) ? void 0 : e.length) === 0
                    }
                    constructor(e, t) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "dbot", void 0), (0, a._)(this, "core", void 0), (0, a._)(this, "disposeReactionsFn", void 0), (0, a._)(this, "timer", void 0), (0, a._)(this, "active_index", 0), (0, a._)(this, "contract_stage", e5.H.NOT_RUNNING), (0, a._)(this, "dialog_options", {}), (0, a._)(this, "has_open_contract", !1), (0, a._)(this, "is_running", !1), (0, a._)(this, "is_statistics_info_modal_open", !1), (0, a._)(this, "is_drawer_open", !0), (0, a._)(this, "is_dialog_open", !1), (0, a._)(this, "is_sell_requested", !1), (0, a._)(this, "show_bot_stop_message", !1), (0, a._)(this, "is_contracy_buying_in_progress", !1), (0, a._)(this, "run_id", ""), (0, a._)(this, "onOkButtonClick", null), (0, a._)(this, "onCancelButtonClick", null), (0, a._)(this, "error_type", void 0), (0, a._)(this, "setShowBotStopMessage", e => {
                            this.show_bot_stop_message = e, e && (0, R.N)((0, O.UC)().bot_stop, {
                                label: (0, p.kg)("Reports"),
                                onClick: () => {
                                    let e = (0, h.kh)(),
                                        t = new URL(d.fv.positions);
                                    t.searchParams.set("contract_type_bots", e);
                                    let i = new URLSearchParams(window.location.search).get("account") || sessionStorage.getItem("query_param_currency") || "";
                                    i && t.searchParams.set("account", i), window.location.assign(t.toString())
                                }
                            })
                        }), (0, a._)(this, "performSelfExclusionCheck", async () => {
                            let {
                                self_exclusion: e
                            } = this.root_store;
                            await e.checkRestriction()
                        }), (0, a._)(this, "onRunButtonClick", async () => {
                            let e = 1;
                            window.sendRequestsStatistic && (performance.clearMeasures(), this.timer = setInterval(() => {
                                window.sendRequestsStatistic(!0), performance.clearMeasures(), 12 === e ? clearInterval(this.timer) : e++
                            }, 1e4));
                            let {
                                summary_card: t,
                                self_exclusion: i
                            } = this.root_store, {
                                client: s,
                                ui: o
                            } = this.core, r = "iOS" === (0, d.oEK)();
                            (this.dbot.saveRecentWorkspace(), this.dbot.unHighlightAllBlocks(), s.is_logged_in) ? ((r || (0, d.nrF)()) && this.preloadAudio(), i.should_bot_run) ? (i.setIsRestricted(!1), this.registerBotListeners(), this.dbot.shouldRunBot()) ? (null == o || o.setAccountSwitcherDisabledMessage((0, p.kg)("Account switching is disabled while your bot is running. Please stop your bot before switching accounts.")), (0, l.h5)(() => {
                                this.setIsRunning(!0), o.setPromptHandler(!0), this.toggleDrawer(!0), this.run_id = `run-${Date.now()}`, t.clear(), this.setContractStage(e5.H.STARTING), this.dbot.runBot()
                            }), this.setShowBotStopMessage(!1)) : this.unregisterBotListeners(): i.setIsRestricted(!0): this.showLoginDialog()
                        }), (0, a._)(this, "onStopButtonClick", () => {
                            this.is_contracy_buying_in_progress = !1;
                            let {
                                is_multiplier: e
                            } = this.root_store.summary_card;
                            e ? this.showStopMultiplierContractDialog() : this.stopBot()
                        }), (0, a._)(this, "onStopBotClick", () => {
                            let {
                                is_multiplier: e
                            } = this.root_store.summary_card, {
                                summary_card: t
                            } = this.root_store;
                            e ? this.showStopMultiplierContractDialog() : (this.stopBot(), t.clear(), this.setShowBotStopMessage(!0))
                        }), (0, a._)(this, "stopBot", () => {
                            let {
                                ui: e
                            } = this.core;
                            this.dbot.stopBot(), e.setPromptHandler(!1), this.error_type ? (this.setContractStage(e5.H.NOT_RUNNING), e.setAccountSwitcherDisabledMessage(), this.setIsRunning(!1)) : this.has_open_contract ? this.setContractStage(e5.H.IS_STOPPING) : (this.setContractStage(e5.H.NOT_RUNNING), this.unregisterBotListeners(), e.setAccountSwitcherDisabledMessage(), this.setIsRunning(!1)), this.error_type && (this.error_type = void 0), this.timer && clearInterval(this.timer), window.sendRequestsStatistic && (window.sendRequestsStatistic(!0), performance.clearMeasures())
                        }), (0, a._)(this, "onClearStatClick", () => {
                            this.showClearStatDialog()
                        }), (0, a._)(this, "clearStat", () => {
                            let {
                                summary_card: e,
                                journal: t,
                                transactions: i
                            } = this.root_store;
                            this.setIsRunning(!1), this.setHasOpenContract(!1), this.clear(), t.clear(), e.clear(), i.clear(), this.setContractStage(e5.H.NOT_RUNNING)
                        }), (0, a._)(this, "toggleStatisticsInfoModal", () => {
                            this.is_statistics_info_modal_open = !this.is_statistics_info_modal_open
                        }), (0, a._)(this, "toggleDrawer", e => {
                            this.is_drawer_open = e
                        }), (0, a._)(this, "setActiveTabIndex", e => {
                            this.active_index = e
                        }), (0, a._)(this, "onCloseDialog", () => {
                            this.is_dialog_open = !1
                        }), (0, a._)(this, "stopMyBot", () => {
                            let {
                                summary_card: e,
                                quick_strategy: t
                            } = this.root_store, {
                                ui: i
                            } = this.core, {
                                toggleStopBotDialog: s
                            } = t;
                            i.setPromptHandler(!1), this.dbot.terminateBot(), this.onCloseDialog(), e.clear(), s(), this.timer && clearInterval(this.timer), window.sendRequestsStatistic && (window.sendRequestsStatistic(!0), performance.clearMeasures())
                        }), (0, a._)(this, "closeMultiplierContract", () => {
                            let {
                                quick_strategy: e
                            } = this.root_store, {
                                toggleStopBotDialog: t
                            } = e;
                            this.onClickSell(), this.stopBot(), this.onCloseDialog(), t()
                        }), (0, a._)(this, "showStopMultiplierContractDialog", () => {
                            let {
                                summary_card: e
                            } = this.root_store, {
                                ui: t
                            } = this.core;
                            this.onOkButtonClick = () => {
                                t.setPromptHandler(!1), this.dbot.terminateBot(), this.timer && clearInterval(this.timer), window.sendRequestsStatistic && (window.sendRequestsStatistic(!0), performance.clearMeasures()), this.onCloseDialog(), e.clear()
                            }, this.onCancelButtonClick = () => {
                                this.onClickSell(), this.stopBot(), this.onCloseDialog()
                            }, this.dialog_options = {
                                title: (0, p.kg)("Keep your current contract?"),
                                message: e8.keep_current_contract,
                                ok_button_text: (0, p.kg)("Keep my contract"),
                                cancel_button_text: (0, p.kg)("Close my contract")
                            }, this.is_dialog_open = !0
                        }), (0, a._)(this, "showLoginDialog", () => {
                            this.onOkButtonClick = this.onCloseDialog, this.onCancelButtonClick = null, this.dialog_options = {
                                title: (0, p.kg)("Please log in"),
                                message: (0, p.kg)("You need to log in to run the bot.")
                            }, this.is_dialog_open = !0
                        }), (0, a._)(this, "showRiskDisclaimerDialog", () => {
                            this.onOkButtonClick = this.onCloseDialog, this.onCancelButtonClick = null, this.dialog_options = {
                                title: (0, p.kg)("Risk Disclaimer"),
                                message: (0, p.kg)("Deriv offers complex derivatives, such as options and contracts for difference (“CFDs”). These products may not be suitable for all clients, and trading them puts you at risk. Please make sure that you understand the following risks before trading Deriv products:\nYou may lose some or all of the money you invest in the trade.\nIf your trade involves currency conversion, exchange rates will affect your profit and loss.\nYou should never trade with borrowed money or with money that you cannot afford to lose.")
                            }, this.is_dialog_open = !0
                        }), (0, a._)(this, "showRealAccountDialog", () => {
                            this.onOkButtonClick = this.onCloseDialog, this.onCancelButtonClick = null, this.dialog_options = {
                                title: (0, p.kg)("Defen Traders isn't quite ready for real accounts"),
                                message: (0, p.kg)("Please switch to your demo account to run your Defen Traders.")
                            }, this.is_dialog_open = !0
                        }), (0, a._)(this, "showClearStatDialog", () => {
                            this.onOkButtonClick = () => {
                                this.clearStat(), this.onCloseDialog()
                            }, this.onCancelButtonClick = this.onCloseDialog, this.dialog_options = {
                                title: (0, p.kg)("Are you sure?"),
                                message: (0, p.kg)("This will clear all data in the summary, transactions, and journal panels. All counters will be reset to zero.")
                            }, this.is_dialog_open = !0
                        }), (0, a._)(this, "showIncompatibleStrategyDialog", () => {
                            this.onOkButtonClick = this.onCloseDialog, this.onCancelButtonClick = null, this.dialog_options = {
                                title: (0, p.kg)("Import error"),
                                message: (0, p.kg)("This strategy is currently not compatible with Defen Traders.")
                            }, this.is_dialog_open = !0
                        }), (0, a._)(this, "showContractUpdateErrorDialog", e => {
                            this.onOkButtonClick = this.onCloseDialog, this.onCancelButtonClick = null, this.dialog_options = {
                                title: (0, p.kg)("Contract Update Error"),
                                message: e
                            }, this.is_dialog_open = !0
                        }), (0, a._)(this, "registerBotListeners", () => {
                            let {
                                summary_card: e,
                                transactions: t
                            } = this.root_store;
                            u.observer.register("bot.running", this.onBotRunningEvent), u.observer.register("bot.sell", this.onBotSellEvent), u.observer.register("bot.stop", this.onBotStopEvent), u.observer.register("bot.bot_ready", this.onBotReadyEvent), u.observer.register("bot.click_stop", this.onStopButtonClick), u.observer.register("bot.trade_again", this.onBotTradeAgain), u.observer.register("contract.status", this.onContractStatusEvent), u.observer.register("bot.contract", this.onBotContractEvent), u.observer.register("bot.contract", e.onBotContractEvent), u.observer.register("bot.contract", t.onBotContractEvent), u.observer.register("Error", this.onError), u.observer.register("bot.recoverOpenPositionLimitExceeded", this.OpenPositionLimitExceededEvent)
                        }), (0, a._)(this, "OpenPositionLimitExceededEvent", () => this.is_contracy_buying_in_progress = !0), (0, a._)(this, "registerReactions", () => {
                            let e, t, {
                                    client: i,
                                    common: s
                                } = this.core,
                                o = () => {
                                    s.is_socket_opened ? e = (0, l.mJ)(() => i.loginid, e => {
                                        e && this.is_running, this.dbot.terminateBot(), this.unregisterBotListeners()
                                    }) : "function" == typeof t && t()
                                };
                            o(), t = (0, l.mJ)(() => s.is_socket_opened, () => o());
                            let r = (0, l.mJ)(() => !this.is_running, () => {
                                this.is_running || this.setContractStage(e5.H.NOT_RUNNING)
                            });
                            return () => {
                                "function" == typeof e && e(), "function" == typeof t && t(), "function" == typeof r && r()
                            }
                        }), (0, a._)(this, "onBotRunningEvent", () => {
                            this.setHasOpenContract(!0);
                            let e = new Event("IgnorePWAUpdate");
                            document.dispatchEvent(e);
                            let {
                                self_exclusion: t
                            } = this.root_store;
                            t.should_bot_run && -1 !== t.run_limit && (t.run_limit -= 1, t.run_limit < 0 && this.onStopButtonClick())
                        }), (0, a._)(this, "onBotSellEvent", () => {
                            this.is_sell_requested = !0
                        }), (0, a._)(this, "onBotStopEvent", () => {
                            let {
                                self_exclusion: e,
                                summary_card: t
                            } = this.root_store, {
                                ui: i
                            } = this.core, s = () => {
                                this.error_type = void 0, this.setContractStage(e5.H.NOT_RUNNING), i.setAccountSwitcherDisabledMessage(), this.unregisterBotListeners(), e.resetSelfExclusion()
                            };
                            if (this.error_type === u.ErrorTypes.RECOVERABLE_ERRORS) {
                                var o, r, a, n;
                                let {
                                    shouldRestartOnError: e = !1,
                                    timeMachineEnabled: t = !1
                                } = (null == (n = this.dbot) || null == (a = n.interpreter) || null == (r = a.bot) || null == (o = r.tradeEngine) ? void 0 : o.options) ? ? {};
                                e || t ? (this.error_type = void 0, this.setContractStage(e5.H.PURCHASE_SENT)) : (this.setIsRunning(!1), s())
                            } else this.error_type === u.ErrorTypes.UNRECOVERABLE_ERRORS ? (this.setIsRunning(!1), s()) : this.has_open_contract && (this.error_type = void 0, this.is_sell_requested = !1, this.setContractStage(e5.H.CONTRACT_CLOSED), i.setAccountSwitcherDisabledMessage(), this.unregisterBotListeners(), e.resetSelfExclusion());
                            this.setHasOpenContract(!1), t.clearContractUpdateConfigValues();
                            let l = new Event("ListenPWAUpdate");
                            document.dispatchEvent(l)
                        }), (0, a._)(this, "onBotReadyEvent", () => {
                            this.setIsRunning(!1), u.observer.unregisterAll("bot.bot_ready")
                        }), (0, a._)(this, "onBotTradeAgain", e => {
                            e || this.stopBot()
                        }), (0, a._)(this, "onContractStatusEvent", e => {
                            switch (e.id) {
                                case "contract.purchase_sent":
                                    this.setContractStage(e5.H.PURCHASE_SENT);
                                    break;
                                case "contract.purchase_received":
                                    {
                                        this.is_contracy_buying_in_progress = !1,
                                        this.setContractStage(e5.H.PURCHASE_RECEIVED);
                                        let {
                                            buy: i
                                        } = e,
                                        {
                                            is_virtual: s
                                        } = this.core.client;
                                        if (!s && i) {
                                            var t;
                                            null === eC.default || void 0 === eC.default || null == (t = eC.default.pushDataLayer) || t.call(eC.default, {
                                                event: "dbot_purchase",
                                                buy_price: i.buy_price
                                            })
                                        }
                                        break
                                    }
                                case "contract.sold":
                                    this.is_sell_requested = !1, this.setContractStage(e5.H.CONTRACT_CLOSED), e.contract && eC.default.onTransactionClosed(e.contract)
                            }
                        }), (0, a._)(this, "onClickSell", () => {
                            let {
                                is_multiplier: e
                            } = this.root_store.summary_card;
                            e && this.setContractStage(e5.H.IS_STOPPING), this.dbot.interpreter.bot.getInterface().sellAtMarket()
                        }), (0, a._)(this, "clear", () => {
                            u.observer.emit("statistics.clear")
                        }), (0, a._)(this, "onBotContractEvent", e => {
                            (null == e ? void 0 : e.is_sold) && (this.is_sell_requested = !1, this.setContractStage(e5.H.CONTRACT_CLOSED))
                        }), (0, a._)(this, "onError", e => {
                            let t = e.error || e;
                            u.unrecoverable_errors.includes(t.code) ? (this.root_store.summary_card.clear(), this.error_type = u.ErrorTypes.UNRECOVERABLE_ERRORS) : this.error_type = u.ErrorTypes.RECOVERABLE_ERRORS;
                            let i = null == t ? void 0 : t.message;
                            this.showErrorMessage(i)
                        }), (0, a._)(this, "showErrorMessage", e => {
                            let {
                                journal: t
                            } = this.root_store, {
                                ui: i
                            } = this.core;
                            t.onError(e), t.journal_filters.some(e => e === u.MessageTypes.ERROR) && (this.toggleDrawer(!0), this.setActiveTabIndex(e4.JOURNAL), i.setPromptHandler(!1))
                        }), (0, a._)(this, "switchToJournal", () => {
                            let {
                                journal: e
                            } = this.root_store;
                            e.journal_filters.push(u.MessageTypes.ERROR), this.setActiveTabIndex(e4.JOURNAL), this.toggleDrawer(!0)
                        }), (0, a._)(this, "unregisterBotListeners", () => {
                            u.observer.unregisterAll("bot.running"), u.observer.unregisterAll("bot.stop"), u.observer.unregisterAll("bot.click_stop"), u.observer.unregisterAll("bot.trade_again"), u.observer.unregisterAll("contract.status"), u.observer.unregisterAll("bot.contract"), u.observer.unregisterAll("Error")
                        }), (0, a._)(this, "setContractStage", e => {
                            this.contract_stage = e
                        }), (0, a._)(this, "setHasOpenContract", e => {
                            this.has_open_contract = e
                        }), (0, a._)(this, "setIsRunning", e => {
                            this.is_running = e
                        }), (0, a._)(this, "onMount", () => {
                            let {
                                journal: e
                            } = this.root_store;
                            u.observer.register("ui.log.error", this.showErrorMessage), u.observer.register("ui.log.notify", e.onNotify), u.observer.register("ui.log.success", e.onLogSuccess), u.observer.register("client.invalid_token", this.handleInvalidToken)
                        }), (0, a._)(this, "onUnmount", () => {
                            let {
                                journal: e,
                                summary_card: t,
                                transactions: i
                            } = this.root_store;
                            this.is_running || (this.unregisterBotListeners(), this.disposeReactionsFn(), e.disposeReactionsFn(), t.disposeReactionsFn(), i.disposeReactionsFn()), u.observer.unregisterAll("ui.log.error"), u.observer.unregisterAll("ui.log.notify"), u.observer.unregisterAll("ui.log.success"), u.observer.unregisterAll("client.invalid_token")
                        }), (0, a._)(this, "handleInvalidToken", async () => {
                            this.setActiveTabIndex(e4.SUMMARY)
                        }), (0, a._)(this, "preloadAudio", () => {
                            this.dbot.getStrategySounds().forEach(e => {
                                let t = document.getElementById(e);
                                t && (t.muted = !0, t.play().catch(() => {}), t.pause(), t.muted = !1)
                            })
                        }), (0, l.Gn)(this, {
                            active_index: l.sH,
                            contract_stage: l.sH,
                            dialog_options: l.sH,
                            has_open_contract: l.sH,
                            is_running: l.sH,
                            is_statistics_info_modal_open: l.sH,
                            is_drawer_open: l.sH,
                            is_dialog_open: l.sH,
                            is_sell_requested: l.sH,
                            run_id: l.sH,
                            error_type: l.sH,
                            show_bot_stop_message: l.sH,
                            is_stop_button_visible: l.EW,
                            is_stop_button_disabled: l.EW,
                            is_clear_stat_disabled: l.EW,
                            toggleDrawer: l.XI,
                            onBotSellEvent: l.XI,
                            setContractStage: l.XI,
                            setHasOpenContract: l.XI,
                            setIsRunning: l.XI,
                            onRunButtonClick: l.XI,
                            is_contracy_buying_in_progress: l.sH,
                            OpenPositionLimitExceededEvent: l.XI,
                            onStopButtonClick: l.XI,
                            onClearStatClick: l.XI,
                            clearStat: l.XI,
                            toggleStatisticsInfoModal: l.XI,
                            setActiveTabIndex: l.XI,
                            onCloseDialog: l.XI,
                            stopMyBot: l.XI,
                            closeMultiplierContract: l.XI,
                            showStopMultiplierContractDialog: l.XI,
                            showLoginDialog: l.XI,
                            showRealAccountDialog: l.XI,
                            showClearStatDialog: l.XI,
                            showIncompatibleStrategyDialog: l.XI,
                            showContractUpdateErrorDialog: l.XI,
                            registerBotListeners: l.XI,
                            registerReactions: l.XI,
                            onBotRunningEvent: l.XI,
                            onBotStopEvent: l.XI,
                            onBotReadyEvent: l.XI,
                            onBotTradeAgain: l.XI,
                            onContractStatusEvent: l.XI,
                            onClickSell: l.XI,
                            clear: l.XI,
                            onBotContractEvent: l.XI,
                            onError: l.XI,
                            showErrorMessage: l.XI,
                            switchToJournal: l.XI,
                            unregisterBotListeners: l.XI,
                            handleInvalidToken: l.XI,
                            preloadAudio: l.XI,
                            onMount: l.XI,
                            onUnmount: l.XI
                        }), this.root_store = e, this.dbot = this.root_store.dbot, this.core = t, this.disposeReactionsFn = this.registerReactions(), this.timer = null
                    }
                }
                var e9 = i(73790),
                    te = i.n(e9);
                let tt = window.Blockly;
                class ti {
                    constructor(e) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "is_save_modal_open", !1), (0, a._)(this, "button_status", eO.NORMAL), (0, a._)(this, "bot_name", ""), (0, a._)(this, "toggleSaveModal", () => {
                            this.is_save_modal_open || this.setButtonStatus(eO.NORMAL), this.is_save_modal_open = !this.is_save_modal_open
                        }), (0, a._)(this, "validateBotName", e => {
                            let t = {};
                            return "" === e.bot_name.trim() && (t.bot_name = (0, p.kg)("Strategy name cannot be empty")), t
                        }), (0, a._)(this, "addStrategyToWorkspace", async (e, t, i, s, o) => {
                            try {
                                var r;
                                let a = await (0, u.getSavedWorkspaces)(),
                                    n = a.findIndex(t => t.id === e),
                                    {
                                        load_modal: {
                                            getSaveType: l
                                        }
                                    } = this.root_store,
                                    c = t ? u.save_types.LOCAL : u.save_types.GOOGLE_DRIVE,
                                    d = i ? u.save_types.UNSAVED : c,
                                    h = null == (r = l(d)) ? void 0 : r.toLowerCase(),
                                    p = {
                                        id: e,
                                        xml: window.Blockly.Xml.domToText(o),
                                        name: s,
                                        timestamp: Date.now(),
                                        save_type: h
                                    };
                                n >= 0 ? a[n] = p : a.push(p), a.sort((e, t) => new Date(e.timestamp) - new Date(t.timestamp)).reverse(), a.length > 10 && a.pop();
                                let {
                                    load_modal: _
                                } = this.root_store, {
                                    setRecentStrategies: g
                                } = _;
                                te().setItem("saved_workspaces", eq().compress(JSON.stringify(a)));
                                let m = await (0, u.getSavedWorkspaces)();
                                g(m);
                                let {
                                    dashboard: {
                                        setStrategySaveType: y
                                    }
                                } = this.root_store;
                                y(h)
                            } catch (e) {
                                u.observer.emit("Error", e)
                            }
                        }), (0, a._)(this, "onConfirmSave", async e => {
                            var t, i, s, o, r, a;
                            let n, {
                                    is_local: l,
                                    save_as_collection: c,
                                    bot_name: d
                                } = e,
                                {
                                    load_modal: h,
                                    dashboard: p,
                                    google_drive: _
                                } = this.root_store,
                                {
                                    loadStrategyToBuilder: g,
                                    selected_strategy: m
                                } = h,
                                {
                                    active_tab: y
                                } = p;
                            this.setButtonStatus(eO.LOADING);
                            let {
                                saveFile: f
                            } = _, b = null;
                            if (1 === y ? n = null == (s = window.Blockly) || null == (i = s.Xml) ? void 0 : i.workspaceToDom(null == (t = window.Blockly) ? void 0 : t.derivWorkspace) : ((b = null == (o = (await (0, u.getSavedWorkspaces)()).filter(e => e.id === m.id)) ? void 0 : o[0]).name = d, b.save_type = l ? u.save_types.LOCAL : u.save_types.GOOGLE_DRIVE, n = window.Blockly.utils.xml.textToDom(b.xml)), n.setAttribute("is_dbot", "true"), n.setAttribute("collection", c ? "true" : "false"), l ? (0, u.save)(d, c, n) : (await f({
                                    name: d,
                                    content: null == tt || null == (r = tt.Xml) ? void 0 : r.domToPrettyText(n),
                                    mimeType: "application/xml"
                                }), this.setButtonStatus(eO.COMPLETED)), this.updateBotName(d), 0 === y) {
                                let e = m.id ? ? (null == tt || null == (a = tt.utils) ? void 0 : a.genUid());
                                await this.addStrategyToWorkspace(e, l, c, d, n), b && await g(b)
                            } else await (0, u.saveWorkspaceToRecent)(n, l ? u.save_types.LOCAL : u.save_types.GOOGLE_DRIVE);
                            this.toggleSaveModal()
                        }), (0, a._)(this, "updateBotName", e => {
                            this.bot_name = e
                        }), (0, a._)(this, "onDriveConnect", async () => {
                            let {
                                google_drive: e
                            } = this.root_store;
                            e.is_authorised ? e.signOut() : e.signIn()
                        }), (0, a._)(this, "setButtonStatus", e => {
                            this.button_status = e
                        }), (0, l.Gn)(this, {
                            is_save_modal_open: l.sH,
                            button_status: l.sH,
                            bot_name: l.sH,
                            toggleSaveModal: l.XI.bound,
                            validateBotName: l.XI.bound,
                            onConfirmSave: l.XI.bound,
                            updateBotName: l.XI.bound,
                            onDriveConnect: l.XI.bound,
                            setButtonStatus: l.XI.bound
                        }), this.root_store = e
                    }
                }
                var ts = i(49043);
                class to {
                    get initial_values() {
                        return {
                            form_max_losses: this.api_max_losses || "",
                            run_limit: -1 !== this.run_limit ? this.run_limit : ""
                        }
                    }
                    get should_bot_run() {
                        let {
                            client: e
                        } = this.core;
                        return !e.is_eu || !!e.is_virtual || 0 !== this.api_max_losses && -1 !== this.run_limit
                    }
                    setIsRestricted(e) {
                        this.is_restricted = e
                    }
                    setApiMaxLosses(e) {
                        this.api_max_losses = e
                    }
                    setRunLimit(e) {
                        this.run_limit = e
                    }
                    resetSelfExclusion() {
                        this.is_restricted = !1, this.api_max_losses = 0, this.form_max_losses = 0, this.run_limit = -1
                    }
                    async checkRestriction() {
                        u.api_base.api && u.api_base.is_authorized && (0, ts.HO)() && u.api_base.api.getSelfExclusion().then(e => {
                            let {
                                get_self_exclusion: t
                            } = e, {
                                max_losses: i
                            } = t;
                            i && this.setApiMaxLosses(i)
                        })
                    }
                    constructor(e, t) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "core", void 0), (0, a._)(this, "api_max_losses", 0), (0, a._)(this, "run_limit", -1), (0, a._)(this, "is_restricted", !1), (0, a._)(this, "form_max_losses", void 0), (0, l.Gn)(this, {
                            api_max_losses: l.sH,
                            run_limit: l.sH,
                            is_restricted: l.sH,
                            initial_values: l.EW,
                            should_bot_run: l.EW,
                            setIsRestricted: l.XI.bound,
                            setApiMaxLosses: l.XI.bound,
                            setRunLimit: l.XI.bound,
                            resetSelfExclusion: l.XI.bound,
                            checkRestriction: l.XI.bound
                        }), this.root_store = e, this.core = t
                    }
                }
                var tr = i(85372);
                let ta = e => {
                    let {
                        stop_loss: t,
                        take_profit: i
                    } = (0, d.Amx)(e);
                    return {
                        contract_update_stop_loss: t ? Math.abs(t).toString() : "",
                        contract_update_take_profit: i ? i.toString() : "",
                        has_contract_update_stop_loss: !!t,
                        has_contract_update_take_profit: !!i
                    }
                };
                class tn {
                    get is_contract_completed() {
                        var e;
                        return !!(null == (e = this.contract_info) ? void 0 : e.is_sold) && this.root_store.run_panel.contract_stage !== e5.H.PURCHASE_RECEIVED
                    }
                    get is_contract_loading() {
                        return this.root_store.run_panel.is_running && null === this.contract_info || this.root_store.run_panel.contract_stage === e5.H.PURCHASE_SENT || this.root_store.run_panel.contract_stage === e5.H.STARTING
                    }
                    get is_contract_inactive() {
                        return !this.contract_info && !this.is_loading
                    }
                    get is_multiplier() {
                        var e;
                        return (0, d.M5x)(null == (e = this.contract_info) ? void 0 : e.contract_type)
                    }
                    get is_accumulator() {
                        var e;
                        return (0, d.PIz)(null == (e = this.contract_info) ? void 0 : e.contract_type)
                    }
                    clear() {
                        let e = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
                        e && (this.contract_info = null), this.profit = 0, this.profit_loss = 0, this.indicative = 0, this.indicative_movement = "", this.profit_movement = ""
                    }
                    clearContractUpdateConfigValues() {
                        if (this.contract_info) {
                            let {
                                contract_update_stop_loss: e,
                                contract_update_take_profit: t,
                                has_contract_update_stop_loss: i,
                                has_contract_update_take_profit: s
                            } = ta(this.contract_info.limit_order);
                            this.contract_update_stop_loss = e, this.contract_update_take_profit = t, this.has_contract_update_stop_loss = i, this.has_contract_update_take_profit = s
                        }
                    }
                    getLimitOrder() {
                        let e = {};
                        return e.take_profit = this.has_contract_update_take_profit ? +(this.contract_update_take_profit ? ? 0) : 0, e.stop_loss = this.has_contract_update_stop_loss ? +(this.contract_update_stop_loss ? ? 0) : 0, e
                    }
                    onBotContractEvent(e) {
                        let {
                            profit: t
                        } = e, i = (0, d.W3I)(e);
                        this.profit = t, this.contract_id !== e.id && (this.clear(!1), this.contract_id = e.id, this.indicative = i);
                        let s = {
                            profit: t,
                            indicative: i
                        };
                        Object.keys(s).forEach(e => {
                            let t = s[e],
                                i = this[e];
                            e in this && t && t !== i ? this[`${e}_movement`] = t && t > (this[e] || 0) ? "profit" : "loss" : "" !== this[`${e}_movement`] && (this.indicative_movement = ""), "profit" === e && (this.profit_loss = t), "indicative" === e && (this.indicative = t)
                        }), this.contract_info = e
                    }
                    onChange(e) {
                        let {
                            name: t,
                            value: i
                        } = e;
                        this[t] = i, this.validateProperty(t, i)
                    }
                    populateContractUpdateConfig(e) {
                        let t = ta(null == e ? void 0 : e.contract_update);
                        if (!(0, d.ob7)(this.contract_update_config, t)) {
                            Object.assign(this, t), this.contract_update_config = t;
                            let {
                                contract_update: s,
                                error: o
                            } = e;
                            if (this.contract_info && s && !o) {
                                var i;
                                this.contract_info.limit_order = Object.assign((null == (i = this.contract_info) ? void 0 : i.limit_order) || {}, s)
                            }
                        }
                    }
                    setContractUpdateConfig(e, t) {
                        e && t && (this.has_contract_update_take_profit = !!e, this.has_contract_update_stop_loss = !!t, this.contract_update_take_profit = this.has_contract_update_take_profit ? +e : null, this.contract_update_stop_loss = this.has_contract_update_stop_loss ? +t : null)
                    }
                    setIsBotRunning() {
                        if (!this.is_contract_loading) {
                            this.is_bot_running = !1;
                            return
                        }
                        let e = setTimeout(() => {
                            this.is_contract_loading && (this.is_bot_running = !0, this.root_store.run_panel.setContractStage(e5.H.RUNNING))
                        }, 5e3);
                        return () => clearTimeout(e)
                    }
                    updateLimitOrder() {
                        var e, t, i, s;
                        let o = this.getLimitOrder();
                        (null == (e = this.contract_info) ? void 0 : e.contract_id) && (null == (t = this.contract_info) ? void 0 : t.contract_id) && (null == (s = u.api_base.api) || s.send({
                            contract_update: 1,
                            contract_id: null == (i = this.contract_info) ? void 0 : i.contract_id,
                            limit_order: o
                        }).then(e => {
                            this.populateContractUpdateConfig(e)
                        }).catch(e => {
                            var t;
                            this.root_store.run_panel.showContractUpdateErrorDialog(null == e || null == (t = e.error) ? void 0 : t.message)
                        }))
                    }
                    setValidationErrorMessages(e, t) {
                        let i = () => !!this.validation_errors[e].filter(e => !t.includes(e)).concat(t.filter(t => !this.validation_errors[e].includes(t))).length;
                        (!this.validation_errors[e] || i()) && (this.validation_errors[e] = t)
                    }
                    validateProperty(e, t) {
                        let i = this.validation_rules[e].trigger,
                            s = {
                                [e]: void 0 !== t ? t : this[e]
                            },
                            o = {
                                [e]: this.validation_rules[e].rules || []
                            };
                        i && Object.hasOwnProperty.call(this, i) && (s[i] = this[i], o[i] = this.validation_rules[i].rules || []);
                        let r = new d.Drx(s, o, this);
                        r.isPassed(), Object.keys(s).forEach(e => {
                            this.setValidationErrorMessages(e, r.errors.get(e))
                        })
                    }
                    registerReactions() {
                        let {
                            client: e
                        } = this.core;
                        return this.disposeSwitchAcountListener = (0, l.mJ)(() => e.loginid, () => this.clear()), () => {
                            "function" == typeof this.disposeSwitchAcountListener && this.disposeSwitchAcountListener()
                        }
                    }
                    constructor(e, t) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "core", void 0), (0, a._)(this, "disposeReactionsFn", void 0), (0, a._)(this, "disposeSwitchAcountListener", void 0), (0, a._)(this, "contract_info", null), (0, a._)(this, "is_loading", !1), (0, a._)(this, "indicative_movement", ""), (0, a._)(this, "profit_movement", ""), (0, a._)(this, "validation_errors", {}), (0, a._)(this, "validation_rules", (0, tr.Fn)()), (0, a._)(this, "contract_update_take_profit", null), (0, a._)(this, "contract_update_stop_loss", null), (0, a._)(this, "has_contract_update_take_profit", !1), (0, a._)(this, "has_contract_update_stop_loss", !1), (0, a._)(this, "contract_update_config", {}), (0, a._)(this, "profit_loss", 0), (0, a._)(this, "contract_id", null), (0, a._)(this, "profit", 0), (0, a._)(this, "indicative", 0), (0, a._)(this, "is_bot_running", !1), (0, l.Gn)(this, {
                            contract_info: l.sH,
                            indicative_movement: l.sH,
                            profit_movement: l.sH,
                            validation_errors: l.sH,
                            validation_rules: l.sH,
                            contract_update_take_profit: l.sH,
                            contract_update_stop_loss: l.sH,
                            has_contract_update_take_profit: l.sH,
                            has_contract_update_stop_loss: l.sH,
                            is_bot_running: l.sH,
                            contract_update_config: l.sH,
                            contract_id: l.sH,
                            profit: l.sH,
                            indicative: l.sH,
                            is_contract_completed: l.EW,
                            is_contract_loading: l.EW,
                            is_contract_inactive: l.EW,
                            is_multiplier: l.EW,
                            clear: l.XI.bound,
                            clearContractUpdateConfigValues: l.XI.bound,
                            getLimitOrder: l.XI.bound,
                            onBotContractEvent: l.XI.bound,
                            onChange: l.XI.bound,
                            populateContractUpdateConfig: l.XI.bound,
                            setContractUpdateConfig: l.XI.bound,
                            setIsBotRunning: l.XI.bound,
                            updateLimitOrder: l.XI.bound,
                            setValidationErrorMessages: l.XI,
                            validateProperty: l.XI,
                            registerReactions: l.XI.bound
                        }), this.root_store = e, this.core = t, this.disposeReactionsFn = this.registerReactions()
                    }
                }
                class tl {
                    constructor(e) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "is_animation_info_modal_open", !1), (0, a._)(this, "is_dialog_open", !1), (0, a._)(this, "file_name", (0, u.config)().default_file_name), (0, a._)(this, "has_undo_stack", !1), (0, a._)(this, "has_redo_stack", !1), (0, a._)(this, "is_reset_button_clicked", !1), (0, a._)(this, "setResetButtonState", e => {
                            this.is_reset_button_clicked = e
                        }), (0, a._)(this, "onResetClick", () => {
                            this.is_dialog_open = !0
                        }), (0, a._)(this, "closeResetDialog", () => {
                            this.is_dialog_open = !1
                        }), (0, a._)(this, "onResetOkButtonClick", () => {
                            this.setResetButtonState(!0), (0, u.runGroupedEvents)(!1, () => {
                                this.resetDefaultStrategy()
                            }, "reset"), this.is_dialog_open = !1
                        }), (0, a._)(this, "resetDefaultStrategy", async () => {
                            var e, t, i, s;
                            let o = window.Blockly.derivWorkspace;
                            o.current_strategy_id = null == (s = window) || null == (i = s.Blockly) || null == (t = i.utils) || null == (e = t.idGenerator) ? void 0 : e.genUid(), await (0, u.load)({
                                block_string: o.cached_xml.main,
                                file_name: (0, u.config)().default_file_name,
                                workspace: o,
                                drop_event: null,
                                strategy_id: null,
                                from: null,
                                showIncompatibleStrategyDialog: null
                            }), o.strategy_to_load = o.cached_xml.main, this.setResetButtonState(!1)
                        }), (0, a._)(this, "onSortClick", () => {
                            let {
                                workspaces: {
                                    indentWorkspace: {
                                        x: e,
                                        y: t
                                    }
                                }
                            } = (0, u.config)();
                            window.Blockly.derivWorkspace.cleanUp(e, t)
                        }), (0, a._)(this, "onUndoClick", e => {
                            window.Blockly.Events.setGroup("undo_clicked"), window.Blockly.derivWorkspace.undo(e), window.Blockly.svgResize(window.Blockly.derivWorkspace), this.setHasRedoStack(), this.setHasUndoStack(), window.Blockly.Events.setGroup(!1)
                        }), (0, a._)(this, "onZoomInOutClick", e => {
                            let t = window.Blockly.derivWorkspace,
                                i = t.getMetrics();
                            t.zoom(i.viewWidth / 2, i.viewHeight / 2, e ? 1 : -1)
                        }), (0, a._)(this, "setHasUndoStack", () => {
                            var e, t;
                            this.has_undo_stack = (null == (t = window.Blockly.derivWorkspace) || null == (e = t.undoStack_) ? void 0 : e.length) > 0
                        }), (0, a._)(this, "setHasRedoStack", () => {
                            var e, t;
                            this.has_redo_stack = (null == (t = window.Blockly.derivWorkspace) || null == (e = t.redoStack_) ? void 0 : e.length) > 0
                        }), (0, l.Gn)(this, {
                            is_animation_info_modal_open: l.sH,
                            is_dialog_open: l.sH,
                            file_name: l.sH,
                            has_undo_stack: l.sH,
                            has_redo_stack: l.sH,
                            is_reset_button_clicked: l.sH,
                            onResetClick: l.XI.bound,
                            closeResetDialog: l.XI.bound,
                            onResetOkButtonClick: l.XI.bound,
                            onUndoClick: l.XI.bound,
                            resetDefaultStrategy: l.XI.bound,
                            setHasUndoStack: l.XI.bound,
                            setHasRedoStack: l.XI.bound
                        }), this.root_store = e
                    }
                }
                class tc {
                    onUnmount() {
                        "function" == typeof this.disposeToolboxToggleReaction && this.disposeToolboxToggleReaction()
                    }
                    setWorkspaceOptions() {
                        let e, t, i, s, o, r = window.Blockly.derivWorkspace;
                        r.options.readOnly ? (e = null, t = !1, i = !1, s = !1, o = !1) : (i = t = !!((e = this.toolbox_dom) && e.getElementsByTagName("category").length), s = t, o = t), r.options.collapse = i, r.options.comments = s, r.options.disable = o, r.options.hasCategories = t, r.options.languageTree = e
                    }
                    adjustWorkspace() {
                        this.is_workspace_scroll_adjusted || this.root_store.load_modal.is_load_modal_open || (this.is_workspace_scroll_adjusted = !0, setTimeout(() => {
                            var e, t;
                            let i = window.Blockly.derivWorkspace,
                                s = (null == (e = document.getElementById("gtm-toolbox")) ? void 0 : e.getBoundingClientRect().width) || 0,
                                o = null == (t = i.svgBlockCanvas_) ? void 0 : t.getBoundingClientRect();
                            if (i.RTL && o) {
                                let e = this.core.ui.is_mobile,
                                    t = e ? o.right : o.left,
                                    r = this.core.ui.is_mobile ? s - t + 20 : s - t + 36;
                                (Math.round(t) <= s || e) && (0, u.scrollWorkspace)(i, r, !0, !1)
                            } else if (Math.round(null == o ? void 0 : o.left) <= s) {
                                let e = this.core.ui.is_mobile ? s - o.left + 50 : s - o.left + 36;
                                (0, u.scrollWorkspace)(i, e, !0, !1)
                            }
                            this.is_workspace_scroll_adjusted = !1
                        }, 300))
                    }
                    toggleDrawer() {
                        this.is_toolbox_open = !this.is_toolbox_open
                    }
                    onToolboxItemClick(e) {
                        var t;
                        let {
                            flyout: i
                        } = this.root_store, s = e.getAttribute("id"), o = this.getCategoryContents(e);
                        i.setIsSearchFlyout(!1), (null == (t = i.selected_category) ? void 0 : t.getAttribute("id")) === s ? i.setVisibility(!1) : (i.setSelectedCategory(e), i.setContents(o))
                    }
                    onToolboxItemExpand(e) {
                        if (this.sub_category_index.includes(e)) {
                            let t = this.sub_category_index.filter(t => t !== e);
                            this.sub_category_index = t
                        } else this.sub_category_index = [...this.sub_category_index, e]
                    }
                    onSearchBlur() {
                        this.is_search_focus = !1
                    }
                    onSearchClear(e) {
                        e("search", ""), this.showSearch("")
                    }
                    onSearchKeyUp(e) {
                        this.is_search_loading = !0, clearTimeout(this.typing_timer), this.typing_timer = setTimeout((0, l.XI)(() => {
                            e(), this.is_search_loading = !1
                        }), 1e3)
                    }
                    constructor(e, t) {
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "core", void 0), (0, a._)(this, "disposeToolboxToggleReaction", void 0), (0, a._)(this, "typing_timer", void 0), (0, a._)(this, "is_toolbox_open", !0), (0, a._)(this, "is_search_loading", !1), (0, a._)(this, "is_search_focus", !1), (0, a._)(this, "sub_category_index", []), (0, a._)(this, "toolbox_dom", void 0), (0, a._)(this, "toolbox_examples", void 0), (0, a._)(this, "is_workspace_scroll_adjusted", !1), (0, a._)(this, "onMount", e => {
                            var t;
                            this.adjustWorkspace(), this.toolbox_dom = window.Blockly.utils.xml.textToDom(null == e ? void 0 : e.current);
                            let i = [...(null == (t = this.toolbox_dom) ? void 0 : t.childNodes) ? ? []].find(e => e instanceof HTMLElement && "examples" === e.tagName);
                            i && (this.toolbox_examples = i), this.setWorkspaceOptions(), this.disposeToolboxToggleReaction = (0, l.mJ)(() => this.is_toolbox_open, e => {
                                if (e) {
                                    var t;
                                    null === eC.default || void 0 === eC.default || null == (t = eC.default.pushDataLayer) || t.call(eC.default, {
                                        event: "dbot_toolbox_visible",
                                        value: !0
                                    })
                                }
                            })
                        }), (0, a._)(this, "getCategoryContents", e => {
                            let t = window.Blockly.derivWorkspace,
                                i = e.getAttribute("dynamic"),
                                s = Array.from(e.childNodes);
                            if ("string" == typeof i) {
                                let e = t.getToolboxCategoryCallback(i);
                                "VARIABLE" === i && (e = window.Blockly.DataCategory), s = e(t)
                            }
                            return s
                        }), (0, a._)(this, "getAllCategories", () => {
                            let e = [];
                            return Array.from(this.toolbox_dom.childNodes).forEach(t => {
                                e.push(t), this.hasSubCategory(t.children) && Array.from(t.children).forEach(t => {
                                    e.push(t)
                                })
                            }), e
                        }), (0, a._)(this, "hasSubCategory", e => !!Object.keys(e).filter(t => {
                            if ("CATEGORY" === e[Number(t)].tagName.toUpperCase()) return e[Number(t)]
                        }).length), (0, a._)(this, "onSearch", e => {
                            let {
                                search: t = ""
                            } = e;
                            this.is_search_focus = !0, this.showSearch(t)
                        }), (0, a._)(this, "showSearch", e => {
                            let t = window.Blockly.derivWorkspace,
                                i = [],
                                s = e.replace(/\s+/g, " ").trim().toUpperCase(),
                                o = s.split(" "),
                                r = t.getVariablesOfType(""),
                                a = window.Blockly.Procedures.allProcedures(t),
                                {
                                    flyout: n
                                } = this.root_store;
                            n.setVisibility(!1);
                            let l = [(0, p.kg)("THE"), (0, p.kg)("OF"), (0, p.kg)("YOU"), (0, p.kg)("IS"), (0, p.kg)("THIS"), (0, p.kg)("THEN"), (0, p.kg)("A"), (0, p.kg)("AN")];
                            if (0 === s.length) return;
                            if (s.length <= 1 || o.every(e => l.includes(e))) {
                                n.setIsSearchFlyout(!0), n.setContents(i, e);
                                return
                            }
                            let c = this.getAllCategories().filter(e => !this.hasSubCategory(e.children)).map(e => Array.from(this.getCategoryContents(e)).filter(e => "BLOCK" === e.tagName.toUpperCase())).flat(),
                                d = function() {
                                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                    e.some(e => e === t) || e.push(t)
                                };
                            ["exact_block_name", "match_words", "block_term", "block_definitions", "block_meta"].forEach(e => {
                                c.forEach(t => {
                                    let r = t.getAttribute("type"),
                                        a = window.Blockly.Blocks[r],
                                        n = a.meta instanceof Function && a.meta(),
                                        l = a.definition instanceof Function && a.definition(),
                                        c = n.display_name,
                                        u = r.toUpperCase().split("_"),
                                        h = c.toUpperCase().split(" "),
                                        p = /^((message)|(tooltip)|(category))/;
                                    switch (e) {
                                        case "exact_block_name":
                                            (s === c.toUpperCase() || s === r.toUpperCase()) && d(i, t);
                                            break;
                                        case "match_words":
                                            (o.every(e => h.some(t => t.includes(e))) || o.every(e => u.some(t => t.includes(e)))) && d(i, t);
                                            break;
                                        case "block_term":
                                            (u.some(e => o.some(t => e.includes(t))) || h.some(e => o.some(t => e.includes(t)))) && d(i, t);
                                            break;
                                        case "block_definitions":
                                            Object.keys(l).forEach(e => {
                                                let r = l[e];
                                                p.test(e) && o.some(e => r.includes(e)) && d(i, t), r instanceof Array && r.forEach(e => {
                                                    let r = JSON.stringify(e).toUpperCase();
                                                    "field_dropdown" === e.type && s.length > 2 && o.some(e => r.includes(e)) && d(i, t)
                                                })
                                            });
                                            break;
                                        case "block_meta":
                                            {
                                                let e = Object.keys(n).filter(e => "display_name" !== e).find(e => {
                                                    let t = n[e].toUpperCase().replace(/[^\w\s]/gi, "").split(" ");
                                                    return o.some(e => t.some(t => t.includes(e)))
                                                });e && e.length && d(i, t)
                                            }
                                    }
                                })
                            });
                            let u = r.filter(e => e.name.toUpperCase().includes(s)),
                                h = window.Blockly.DataCategory.search(u).filter(e => -1 === i.indexOf(e));
                            h && h.length && i.unshift(...h);
                            let _ = {
                                    0: [],
                                    1: []
                                },
                                g = a[0],
                                m = a[1];
                            Object.keys(g).forEach(e => {
                                let t = g[e];
                                t[0].toUpperCase().includes(s) && _["0"].unshift(t)
                            }), Object.keys(m).forEach(e => {
                                let t = m[e];
                                t[0].toUpperCase().includes(s) && _["1"].unshift(t)
                            });
                            let y = window.Blockly.Procedures.populateDynamicProcedures(_).filter(e => -1 === i.indexOf(e));
                            y.length && i.unshift(...y), n.setIsSearchFlyout(!0), n.setContents(i, e)
                        }), (0, l.Gn)(this, {
                            is_toolbox_open: l.sH,
                            is_search_loading: l.sH,
                            is_search_focus: l.sH,
                            sub_category_index: l.sH,
                            toolbox_dom: l.sH,
                            toolbox_examples: l.sH,
                            onMount: l.XI.bound,
                            onUnmount: l.XI.bound,
                            setWorkspaceOptions: l.XI.bound,
                            adjustWorkspace: l.XI.bound,
                            toggleDrawer: l.XI.bound,
                            onToolboxItemClick: l.XI.bound,
                            onToolboxItemExpand: l.XI.bound,
                            getCategoryContents: l.XI.bound,
                            getAllCategories: l.XI.bound,
                            hasSubCategory: l.XI.bound,
                            onSearch: l.XI.bound,
                            onSearchBlur: l.XI.bound,
                            onSearchClear: l.XI.bound,
                            onSearchKeyUp: l.XI.bound,
                            showSearch: l.XI.bound
                        }), this.root_store = e, this.core = t
                    }
                }
                var td = i(28899);
                class tu {
                    get transactions() {
                        var e, t, i, s;
                        return (null == (t = this.core) || null == (e = t.client) ? void 0 : e.loginid) ? this.elements[null == (s = this.core) || null == (i = s.client) ? void 0 : i.loginid] ? ? [] : []
                    }
                    get statistics() {
                        let e = 0,
                            t = this.transactions.filter(e => e.type === td.b.CONTRACT && "object" == typeof e.data).reduce((t, i) => {
                                let {
                                    data: s
                                } = i, {
                                    profit: o = 0,
                                    is_completed: r = !1,
                                    buy_price: a = 0,
                                    payout: n,
                                    bid_price: l
                                } = s;
                                return r && (o > 0 ? (t.won_contracts += 1, t.total_payout += n ? ? l ? ? 0) : t.lost_contracts += 1, t.total_profit += o, t.total_stake += a, e += 1), t
                            }, {
                                lost_contracts: 0,
                                number_of_runs: 0,
                                total_profit: 0,
                                total_payout: 0,
                                total_stake: 0,
                                won_contracts: 0
                            });
                        return t.number_of_runs = e, t
                    }
                    onBotContractEvent(e) {
                        this.pushTransaction(e)
                    }
                    pushTransaction(e) {
                        var t, i, s, o, r, a, n, l, c;
                        let u = (0, d.plb)(e),
                            {
                                run_id: h
                            } = this.root_store.run_panel,
                            p = null == (i = this.core) || null == (t = i.client) ? void 0 : t.loginid,
                            _ = { ...e,
                                is_completed: u,
                                run_id: h,
                                date_start: (0, d.Yq5)(e.date_start, "YYYY-M-D HH:mm:ss [GMT]"),
                                entry_tick: e.entry_tick_display_value,
                                entry_tick_time: e.entry_tick_time && (0, d.Yq5)(e.entry_tick_time, "YYYY-M-D HH:mm:ss [GMT]"),
                                exit_tick: e.exit_tick_display_value,
                                exit_tick_time: e.exit_tick_time && (0, d.Yq5)(e.exit_tick_time, "YYYY-M-D HH:mm:ss [GMT]"),
                                profit: u ? e.profit : 0
                            };
                        this.elements[p] || (this.elements = { ...this.elements,
                            [p]: []
                        });
                        let g = null == (s = this.elements[p]) ? void 0 : s.findIndex(t => {
                            var i, s;
                            return "string" != typeof t.data && t.type === td.b.CONTRACT && (null == (i = t.data) ? void 0 : i.transaction_ids) && t.data.transaction_ids.buy === (null == (s = e.transaction_ids) ? void 0 : s.buy)
                        });
                        if (-1 === g) {
                            if ((null == (o = this.elements[p]) ? void 0 : o.length) > 0) {
                                let e = null == (a = this.elements[p]) ? void 0 : a[0];
                                e.type === td.b.CONTRACT && "object" == typeof e.data && _.run_id !== (null == e || null == (n = e.data) ? void 0 : n.run_id) && (null == (l = this.elements[p]) || l.unshift({
                                    type: td.b.DIVIDER,
                                    data: _.run_id
                                }))
                            }
                            null == (r = this.elements[p]) || r.unshift({
                                type: td.b.CONTRACT,
                                data: _
                            })
                        } else null == (c = this.elements[p]) || c.splice(g, 1, {
                            type: td.b.CONTRACT,
                            data: _
                        });
                        this.elements = { ...this.elements
                        }
                    }
                    clear() {
                        var e, t, i, s, o, r, a;
                        this.elements && (null == (e = this.elements[null == (i = this.core) || null == (t = i.client) ? void 0 : t.loginid]) ? void 0 : e.length) > 0 && (this.elements[null == (a = this.core) || null == (r = a.client) ? void 0 : r.loginid] = []), this.recovered_completed_transactions = null == (s = this.recovered_completed_transactions) ? void 0 : s.slice(0, 0), this.recovered_transactions = null == (o = this.recovered_transactions) ? void 0 : o.slice(0, 0), this.is_transaction_details_modal_open = !1
                    }
                    registerReactions() {
                        let {
                            client: e
                        } = this.core, t = (0, l.mJ)(() => this.elements[null == e ? void 0 : e.loginid], t => {
                            let i = ez(this.TRANSACTION_CACHE, {});
                            i[e.loginid] = (null == t ? void 0 : t.slice(0, 5e3)) ? ? [], eK(this.TRANSACTION_CACHE, i)
                        }), i = (0, l.mJ)(() => this.transactions.length, () => this.recoverPendingContracts());
                        return () => {
                            t(), i()
                        }
                    }
                    recoverPendingContracts() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                        this.transactions.forEach(t => {
                            let {
                                data: i
                            } = t;
                            "string" == typeof i || (null == i ? void 0 : i.is_completed) || !(null == i ? void 0 : i.contract_id) || this.recovered_transactions.includes(null == i ? void 0 : i.contract_id) || this.recoverPendingContractsById(i.contract_id, e)
                        })
                    }
                    updateResultsCompletedContract(e) {
                        let {
                            journal: t,
                            summary_card: i
                        } = this.root_store, {
                            contract_info: s
                        } = i, {
                            currency: o,
                            profit: r
                        } = e;
                        e.contract_id !== (null == s ? void 0 : s.contract_id) && (this.onBotContractEvent(e), e.contract_id && !this.recovered_transactions.includes(e.contract_id) && this.recovered_transactions.push(e.contract_id), e.contract_id && !this.recovered_completed_transactions.includes(e.contract_id) && (0, d.plb)(e) && (this.recovered_completed_transactions.push(e.contract_id), t.onLogSuccess({
                            log_type: r && r > 0 ? u.LogTypes.PROFIT : u.LogTypes.LOST,
                            extra: {
                                currency: o,
                                profit: r
                            }
                        })))
                    }
                    sortOutPositionsBeforeAction(e, t) {
                        null == e || e.forEach(e => {
                            if (!t || t && e.id === t) {
                                let t = e.contract_info;
                                this.updateResultsCompletedContract(t)
                            }
                        })
                    }
                    async recoverPendingContractsById(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                            i = [];
                        if (t && (this.is_called_proposal_open_contract = !0, t.contract_id === e && this.updateResultsCompletedContract(t)), !this.is_called_proposal_open_contract) {
                            var s, o, r, a, n, l;
                            if (null == (o = this.core) || null == (s = o.client) ? void 0 : s.loginid) {
                                let e = null == (a = this.core) || null == (r = a.client) ? void 0 : r.loginid;
                                (null == (n = this.elements[e]) ? void 0 : n.length) || this.sortOutPositionsBeforeAction(i);
                                let [t = null] = this.elements[e];
                                if ("object" == typeof(null == t ? void 0 : t.data) && !(null == t || null == (l = t.data) ? void 0 : l.profit)) {
                                    let e = t.data.contract_id;
                                    this.sortOutPositionsBeforeAction(i, e)
                                }
                            }
                        }
                    }
                    constructor(e, t) {
                        var i, s;
                        (0, a._)(this, "root_store", void 0), (0, a._)(this, "core", void 0), (0, a._)(this, "disposeReactionsFn", void 0), (0, a._)(this, "TRANSACTION_CACHE", "transaction_cache"), (0, a._)(this, "elements", eY(this.TRANSACTION_CACHE, null == (s = this.core) || null == (i = s.client) ? void 0 : i.loginid, [])), (0, a._)(this, "active_transaction_id", null), (0, a._)(this, "recovered_completed_transactions", []), (0, a._)(this, "recovered_transactions", []), (0, a._)(this, "is_called_proposal_open_contract", !1), (0, a._)(this, "is_transaction_details_modal_open", !1), (0, a._)(this, "toggleTransactionDetailsModal", e => {
                            this.is_transaction_details_modal_open = e
                        }), this.root_store = e, this.core = t, this.is_transaction_details_modal_open = !1, this.disposeReactionsFn = this.registerReactions(), (0, l.Gn)(this, {
                            elements: l.sH,
                            active_transaction_id: l.sH,
                            recovered_completed_transactions: l.sH,
                            recovered_transactions: l.sH,
                            is_called_proposal_open_contract: l.sH,
                            is_transaction_details_modal_open: l.sH,
                            transactions: l.EW,
                            onBotContractEvent: l.XI.bound,
                            pushTransaction: l.XI.bound,
                            clear: l.XI.bound,
                            registerReactions: l.XI.bound,
                            recoverPendingContracts: l.XI.bound,
                            updateResultsCompletedContract: l.XI.bound,
                            sortOutPositionsBeforeAction: l.XI.bound,
                            recoverPendingContractsById: l.XI.bound
                        })
                    }
                }
                var th = i(33048);
                class tp {
                    setIsTradingAssessmentForNewUserEnabled(e) {
                        this.is_trading_assessment_for_new_user_enabled = e
                    }
                    toggleAccountsDialog() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : !this.is_accounts_switcher_on;
                        this.is_accounts_switcher_on = e
                    }
                    toggleOnScreenKeyboard() {
                        this.is_onscreen_keyboard_active = null !== this.current_focus && this.is_mobile && (0, th.CN)()
                    }
                    setCurrentFocus(e) {
                        this.current_focus = e, this.toggleOnScreenKeyboard()
                    }
                    constructor() {
                        (0, a._)(this, "is_mobile", !0), (0, a._)(this, "is_desktop", !0), (0, a._)(this, "is_tablet", !1), (0, a._)(this, "is_chart_layout_default", !0), (0, a._)(this, "is_dark_mode_on", "dark" === localStorage.getItem("theme")), (0, a._)(this, "account_switcher_disabled_message", ""), (0, a._)(this, "current_focus", null), (0, a._)(this, "show_prompt", !1), (0, a._)(this, "is_trading_assessment_for_new_user_enabled", !1), (0, a._)(this, "is_accounts_switcher_on", !1), (0, a._)(this, "is_onscreen_keyboard_active", !1), (0, a._)(this, "setPromptHandler", e => {
                            this.show_prompt = e
                        }), (0, a._)(this, "setAccountSwitcherDisabledMessage", e => {
                            e ? this.account_switcher_disabled_message = e : this.account_switcher_disabled_message = ""
                        }), (0, a._)(this, "setDarkMode", e => {
                            this.is_dark_mode_on = e
                        }), (0, a._)(this, "setDevice", e => {
                            this.is_mobile = "mobile" === e, this.is_desktop = "desktop" === e, this.is_tablet = "tablet" === e
                        }), (0, l.Gn)(this, {
                            account_switcher_disabled_message: l.sH,
                            current_focus: l.sH,
                            is_accounts_switcher_on: l.sH,
                            is_dark_mode_on: l.sH,
                            is_desktop: l.sH,
                            is_mobile: l.sH,
                            is_tablet: l.sH,
                            is_trading_assessment_for_new_user_enabled: l.sH,
                            show_prompt: l.sH,
                            setAccountSwitcherDisabledMessage: l.XI.bound,
                            setCurrentFocus: l.XI.bound,
                            setDarkMode: l.XI.bound,
                            setDevice: l.XI.bound,
                            setPromptHandler: l.XI.bound,
                            setIsTradingAssessmentForNewUserEnabled: l.XI.bound,
                            toggleAccountsDialog: l.XI.bound,
                            toggleOnScreenKeyboard: l.XI.bound
                        })
                    }
                }
                class t_ {
                    constructor(e) {
                        (0, a._)(this, "dbot", void 0), (0, a._)(this, "app", void 0), (0, a._)(this, "summary_card", void 0), (0, a._)(this, "flyout", void 0), (0, a._)(this, "flyout_help", void 0), (0, a._)(this, "google_drive", void 0), (0, a._)(this, "journal", void 0), (0, a._)(this, "load_modal", void 0), (0, a._)(this, "run_panel", void 0), (0, a._)(this, "save_modal", void 0), (0, a._)(this, "transactions", void 0), (0, a._)(this, "toolbar", void 0), (0, a._)(this, "toolbox", void 0), (0, a._)(this, "quick_strategy", void 0), (0, a._)(this, "self_exclusion", void 0), (0, a._)(this, "dashboard", void 0), (0, a._)(this, "chart_store", void 0), (0, a._)(this, "blockly_store", void 0), (0, a._)(this, "data_collection_store", void 0), (0, a._)(this, "ui", void 0), (0, a._)(this, "client", void 0), (0, a._)(this, "common", void 0), (0, a._)(this, "core", {
                            ui: {},
                            client: {},
                            common: {}
                        }), this.dbot = e, this.ui = new tp, this.client = new S, this.common = new A, this.core.ui = this.ui, this.core.client = this.client, this.core.common = this.common, this.app = new _(this, this.core), this.summary_card = new tn(this, this.core), this.flyout = new eR(this), this.flyout_help = new eA(this), this.google_drive = new eL(this), this.journal = new eJ(this, this.core), this.load_modal = new e1(this, this.core), this.run_panel = new e6(this, this.core), this.save_modal = new ti(this), this.transactions = new tu(this, this.core), this.toolbar = new tl(this), this.toolbox = new tc(this, this.core), this.quick_strategy = new e7(this), this.self_exclusion = new to(this, this.core), this.dashboard = new P(this, this.core), this.chart_store = new f(this), this.blockly_store = new y(this), this.data_collection_store = new U(this, this.core)
                    }
                }
                var tg = i(97019);
                let tm = (0, r.createContext)(null),
                    ty = e => {
                        let {
                            children: t,
                            mockStore: i
                        } = e, [s, a] = (0, r.useState)(null), n = (0, r.useRef)(!1);
                        return ((0, r.useEffect)(() => {
                            let e = async () => {
                                a(new t_(tg.A))
                            };
                            s || n.current || (n.current = !0, i ? a(i) : e())
                        }, [s, i]), !s && i) ? null : (0, o.jsx)(tm.Provider, {
                            value: s,
                            children: t
                        })
                    },
                    tf = () => (0, r.useContext)(tm)
            },
            14601(e, t, i) {
                "use strict";
                var s = i(74848),
                    o = i(24509),
                    r = i(5338),
                    a = i(96540),
                    n = i(18987),
                    l = i(37448),
                    c = i(49043),
                    d = i(68034),
                    u = i(26008),
                    h = i(2168),
                    p = i(95526),
                    _ = i(13599),
                    g = i(84976),
                    m = i(47767),
                    y = i(7246),
                    f = i(33718),
                    b = i(77682);
                let k = (0, y.PA)(() => {
                    let {
                        ui: e
                    } = (0, f.Pj)() ? ? {
                        ui: {
                            show_prompt: !1
                        }
                    }, {
                        show_prompt: t
                    } = e, i = (0, m.KP)(e => {
                        let {
                            currentLocation: i,
                            nextLocation: s
                        } = e;
                        return t && i.pathname !== s.pathname
                    });
                    return a.useEffect(() => {
                        let e = e => {
                            t ? e.preventDefault() : delete e.returnValue
                        };
                        return window.addEventListener("beforeunload", e), () => {
                            window.removeEventListener("beforeunload", e)
                        }
                    }, [t]), (0, s.jsx)(b.A, {
                        title: (0, p.kg)("Leaving already?"),
                        confirm_button_text: (0, p.kg)("Yes, I'll come back later"),
                        cancel_button_text: (0, p.kg)("No, I'll stay"),
                        onConfirm: () => {
                            var e;
                            null == i || null == (e = i.proceed) || e.call(i)
                        },
                        onCancel: () => {
                            var e;
                            null == i || null == (e = i.reset) || e.call(i)
                        },
                        is_visible: "blocked" === i.state,
                        has_close_icon: !1,
                        children: (0, s.jsx)(p.we, {
                            i18n_default_text: "If you leave, your current contract will be completed, but your bot will stop running immediately."
                        })
                    })
                });
                var v = i(28176),
                    w = i(58826),
                    T = i(83290),
                    S = i(91345),
                    I = i(32321),
                    E = i(75628),
                    x = i(16115),
                    A = i(2457),
                    C = i(67774),
                    R = i(92424),
                    O = i(17605);
                let D = (0, y.PA)(e => {
                    let {
                        children: t
                    } = e, {
                        isAuthorizing: i,
                        isAuthorized: o,
                        connectionStatus: r,
                        accountList: l,
                        activeLoginid: c
                    } = (0, O.d)(), d = (0, a.useRef)(!1), h = (0, a.useRef)(!1), _ = (0, a.useRef)(null), g = (0, a.useRef)(null), m = (0, a.useRef)(!1), {
                        client: y,
                        common: b
                    } = (0, f.Pj)() ? ? {}, {
                        currentLang: k
                    } = (0, p.c3)(), {
                        oAuthLogout: w
                    } = (0, R.$)({
                        handleLogout: async () => y.logout(),
                        client: y
                    }), T = n.A.get("logged_state"), S = "false" === T;
                    (0, a.useEffect)(() => {
                        if (!m.current && (m.current = !0, (0, u.a8)())) return
                    }, []), (0, a.useEffect)(() => {
                        if (S && (null == y ? void 0 : y.is_logged_in) && void 0 !== T) {
                            let e = localStorage.getItem("accountsList");
                            e && Object.keys(JSON.parse(e)).length > 0 && w()
                        }
                    }, [S, T, w, null == y ? void 0 : y.is_logged_in]);
                    let I = (0, a.useMemo)(() => null == l ? void 0 : l.find(e => e.loginid === c), [c, l]);
                    (0, a.useEffect)(() => {
                        var e, t;
                        let i = null == y || null == (t = y.all_accounts_balance) || null == (e = t.accounts) ? void 0 : e[(null == I ? void 0 : I.loginid) ? ? ""];
                        i && (null == y || y.setBalance(i.balance.toFixed((0, v.QWi)(i.currency))), null == y || y.setCurrency(i.currency))
                    }, [null == I ? void 0 : I.loginid, null == y ? void 0 : y.all_accounts_balance]), (0, a.useEffect)(() => {
                        y && I && (null == y || y.setLoginId(c), null == y || y.setAccountList(l), null == y || y.setIsLoggedIn(!0))
                    }, [l, I, c, y]), (0, a.useEffect)(() => ((0, A.fh)({
                        empty_address: () => (0, p.kg)("This field is required"),
                        empty_barrier: () => (0, p.kg)("Barrier is a required field."),
                        address: () => (0, p.kg)("Use only the following special characters: {{permitted_characters}}", {
                            permitted_characters: x.BS,
                            interpolation: {
                                escapeValue: !1
                            }
                        }),
                        barrier: () => (0, p.kg)("Only numbers and these special characters are allowed: {{permitted_characters}}", {
                            permitted_characters: "+ - ."
                        }),
                        email: () => (0, p.kg)("Invalid email address."),
                        general: () => (0, p.kg)("Only letters, numbers, space, hyphen, period, and apostrophe are allowed."),
                        name: () => (0, p.kg)("Letters, spaces, periods, hyphens, apostrophes only."),
                        password: () => (0, p.kg)("Password should have lower and uppercase English letters with numbers."),
                        po_box: () => (0, p.kg)("P.O. Box is not accepted in address"),
                        phone: () => (0, p.kg)("Please enter a valid phone number (e.g. +15417541234)."),
                        postcode: () => (0, p.kg)("Only letters, numbers, space and hyphen are allowed."),
                        signup_token: () => (0, p.kg)("The length of token should be 8."),
                        tax_id: () => (0, p.kg)("Should start with letter or number, and may contain hyphen and underscore."),
                        number: () => (0, p.kg)("Should be a valid number."),
                        decimalPlaces: e => (0, p.kg)("Up to {{decimal_count}} decimal places are allowed.", {
                            decimal_count: e
                        }),
                        value: e => (0, p.kg)("Should be {{value}}", {
                            value: e
                        }),
                        betweenMinMax: (e, t) => (0, p.kg)("Should be between {{min_value}} and {{max_value}}", {
                            min_value: e,
                            max_value: t
                        }),
                        minNumber: e => (0, p.kg)("Should be more than {{min_value}}", {
                            min_value: e
                        }),
                        maxNumber: e => (0, p.kg)("Should be less than {{max_value}}", {
                            max_value: e
                        }),
                        password_warnings: {
                            use_a_few_words: () => (0, p.kg)("Use a few words, avoid common phrases"),
                            no_need_for_mixed_chars: () => (0, p.kg)("No need for symbols, digits, or uppercase letters"),
                            uncommon_words_are_better: () => (0, p.kg)("Add another word or two. Uncommon words are better."),
                            straight_rows_of_keys_are_easy: () => (0, p.kg)("Straight rows of keys are easy to guess"),
                            short_keyboard_patterns_are_easy: () => (0, p.kg)("Short keyboard patterns are easy to guess"),
                            use_longer_keyboard_patterns: () => (0, p.kg)("Use a longer keyboard pattern with more turns"),
                            repeated_chars_are_easy: () => (0, p.kg)('Repeats like "aaa" are easy to guess'),
                            repeated_patterns_are_easy: () => (0, p.kg)('Repeats like "abcabcabc" are only slightly harder to guess than "abc"'),
                            avoid_repeated_chars: () => (0, p.kg)("Avoid repeated words and characters"),
                            sequences_are_easy: () => (0, p.kg)("Sequences like abc or 6543 are easy to guess"),
                            avoid_sequences: () => (0, p.kg)("Avoid sequences"),
                            recent_years_are_easy: () => (0, p.kg)("Recent years are easy to guess"),
                            avoid_recent_years: () => (0, p.kg)("Avoid recent years"),
                            avoid_associated_years: () => (0, p.kg)("Avoid years that are associated with you"),
                            dates_are_easy: () => (0, p.kg)("Dates are often easy to guess"),
                            avoid_associated_dates_and_years: () => (0, p.kg)("Avoid dates and years that are associated with you"),
                            top10_common_password: () => (0, p.kg)("This is a top-10 common password"),
                            top100_common_password: () => (0, p.kg)("This is a top-100 common password"),
                            very_common_password: () => (0, p.kg)("This is a very common password"),
                            similar_to_common_password: () => (0, p.kg)("This is similar to a commonly used password"),
                            a_word_is_easy: () => (0, p.kg)("A word by itself is easy to guess"),
                            names_are_easy: () => (0, p.kg)("Names and surnames by themselves are easy to guess"),
                            common_names_are_easy: () => (0, p.kg)("Common names and surnames are easy to guess"),
                            capitalization_doesnt_help: () => (0, p.kg)("Capitalization doesn't help very much"),
                            all_uppercase_doesnt_help: () => (0, p.kg)("All-uppercase is almost as easy to guess as all-lowercase"),
                            reverse_doesnt_help: () => (0, p.kg)("Reversed words aren't much harder to guess"),
                            substitution_doesnt_help: () => (0, p.kg)("Predictable substitutions like '@' instead of 'a' don't help very much"),
                            user_dictionary: () => (0, p.kg)("This password is on the blacklist")
                        }
                    }), () => {
                        _.current && clearInterval(_.current)
                    }), []), (0, a.useEffect)(() => {
                        b && k && b.setCurrentLanguage(k)
                    }, [k, b]), (0, a.useEffect)(() => {
                        if (y && !i && !d.current) {
                            var e;
                            d.current = !0, null == (e = C.api_base.api) || e.websiteStatus().then(e => {
                                (null == e ? void 0 : e.website_status) && !e.error && y.setWebsiteStatus(e.website_status)
                            }).catch(e => {
                                console.error("Error fetching website status:", e)
                            }), _.current = setInterval(() => {
                                var e;
                                null == (e = C.api_base.api) || e.time().then(e => {
                                    (null == e ? void 0 : e.time) && !e.error && b.setServerTime((0, v.sf1)(e.time), !1)
                                }).catch(() => {
                                    b.setServerTime((0, v.sf1)(Date.now()), !0)
                                })
                            }, 1e4)
                        }
                    }, [y, b, i]);
                    let E = (0, a.useCallback)(async e => {
                        if (!e) return;
                        let t = e.data,
                            {
                                msg_type: i,
                                error: s
                            } = t;
                        if ((null == s ? void 0 : s.code) && ("AuthorizationRequired" === s.code || "DisabledClient" === s.code || "InvalidToken" === s.code) && localStorage.getItem("authToken") && await w(), "balance" === i && t && !s) {
                            let e = t.balance;
                            if (null == e ? void 0 : e.accounts) y.setAllAccountsBalance(e);
                            else if (null == e ? void 0 : e.loginid) {
                                var o;
                                if (!(null == y || null == (o = y.all_accounts_balance) ? void 0 : o.accounts) || !(null == e ? void 0 : e.loginid)) return;
                                let t = { ...{ ...y.all_accounts_balance.accounts
                                    }[e.loginid]
                                };
                                t.balance = e.balance;
                                let i = { ...y.all_accounts_balance,
                                    accounts: { ...y.all_accounts_balance.accounts,
                                        [e.loginid]: t
                                    }
                                };
                                y.setAllAccountsBalance(i)
                            }
                        }
                    }, [y, w]);
                    return (0, a.useEffect)(() => {
                        if (!i && y) {
                            var e;
                            let t = null === C.api_base || void 0 === C.api_base || null == (e = C.api_base.api) ? void 0 : e.onMessage().subscribe(E);
                            g.current = {
                                unsubscribe: null == t ? void 0 : t.unsubscribe
                            }
                        }
                        return () => {
                            if (g.current) {
                                var e, t;
                                null == (e = (t = g.current).unsubscribe) || e.call(t)
                            }
                        }
                    }, [r, E, i, o, y]), (0, a.useEffect)(() => {
                        !i && o && !h.current && y && (h.current = !0, C.api_base.api.getSettings().then(e => {
                            if ((null == e ? void 0 : e.get_settings) && !e.error) {
                                var t;
                                null == y || y.setAccountSettings(e.get_settings), C.api_base.api.landingCompany({
                                    landing_company: null == (t = e.get_settings) ? void 0 : t.country_code
                                }).then(e => {
                                    (null == e ? void 0 : e.landing_company) && !e.error && (null == y || y.setLandingCompany(e.landing_company))
                                }).catch(e => {
                                    console.error("Error fetching landing company:", e)
                                })
                            }
                        }).catch(e => {
                            console.error("Error fetching account settings:", e)
                        }), C.api_base.api.getAccountStatus().then(e => {
                            (null == e ? void 0 : e.get_account_status) && !e.error && (null == y || y.setAccountStatus(e.get_account_status))
                        }).catch(e => {
                            console.error("Error fetching account status:", e)
                        }))
                    }, [i, o, y]), (0, s.jsx)(s.Fragment, {
                        children: t
                    })
                });
                i(51017);
                var B = i(92509);
                let L = (0, a.lazy)(() => Promise.all([i.e("443"), i.e("141"), i.e("634")]).then(i.bind(i, 24310))),
                    P = (0, a.lazy)(() => Promise.all([i.e("328"), i.e("714")]).then(i.bind(i, 55281))),
                    {
                        TRANSLATIONS_CDN_URL: N,
                        R2_PROJECT_NAME: j,
                        CROWDIN_BRANCH_NAME: U
                    } = {
                        TRANSLATIONS_CDN_URL: void 0,
                        R2_PROJECT_NAME: void 0,
                        CROWDIN_BRANCH_NAME: void 0
                    },
                    M = (0, p.JL)({
                        cdnUrl: `${N}/${j}/${U}`
                    }),
                    H = (0, g.Ys)((0, m.Eu)((0, s.jsxs)(m.qh, {
                        path: "/",
                        element: (0, s.jsx)(a.Suspense, {
                            fallback: (0, s.jsx)(B.A, {
                                content: "Please wait while we connect to the server..."
                            }),
                            children: (0, s.jsx)(p.Dv, {
                                defaultLang: "EN",
                                i18nInstance: M,
                                children: (0, s.jsxs)(f.tv, {
                                    children: [(0, s.jsx)(k, {}), (0, s.jsx)(D, {
                                        children: (0, s.jsx)(L, {})
                                    })]
                                })
                            })
                        }),
                        children: [(0, s.jsx)(m.qh, {
                            index: !0,
                            element: (0, s.jsx)(P, {})
                        }), (0, s.jsx)(m.qh, {
                            path: "endpoint",
                            element: (0, s.jsx)(() => {
                                let e = (0, S.Wx)({
                                    initialValues: {
                                        appId: localStorage.getItem(_.ql.configAppId) ? ? (0, v.R7U)(),
                                        serverUrl: localStorage.getItem(_.ql.configServerURL) ? ? (0, v.J39)()
                                    },
                                    onSubmit: t => {
                                        localStorage.setItem(_.ql.configServerURL, t.serverUrl), localStorage.setItem(_.ql.configAppId, t.appId.toString()), e.resetForm({
                                            values: t
                                        })
                                    },
                                    validate: e => {
                                        let t = {};
                                        return e.serverUrl || (t.serverUrl = "This field is required"), e.appId ? /^(0|[1-9]\d*)(\.\d+)?$/.test(e.appId.toString()) || (t.appId = "Please enter a valid app ID") : t.appId = "This field is required", t
                                    }
                                });
                                return (0, s.jsxs)("div", {
                                    className: "endpoint",
                                    children: [(0, s.jsx)(I.E, {
                                        weight: "bold",
                                        className: "endpoint__title",
                                        children: "Change API endpoint"
                                    }), (0, s.jsxs)("form", {
                                        onSubmit: e.handleSubmit,
                                        className: "endpoint__form",
                                        children: [(0, s.jsx)(E.p, {
                                            "data-testid": "dt_endpoint_server_url_input",
                                            label: "Server",
                                            name: "serverUrl",
                                            message: e.errors.serverUrl,
                                            onBlur: e.handleBlur,
                                            onChange: e.handleChange,
                                            value: e.values.serverUrl
                                        }), (0, s.jsx)(E.p, {
                                            "data-testid": "dt_endpoint_app_id_input",
                                            label: "OAuth App ID",
                                            name: "appId",
                                            message: e.errors.appId,
                                            onBlur: e.handleBlur,
                                            onChange: e.handleChange,
                                            value: e.values.appId
                                        }), (0, s.jsxs)("div", {
                                            children: [(0, s.jsx)(T.$, {
                                                className: "endpoint__button",
                                                disabled: !e.dirty || !e.isValid,
                                                type: "submit",
                                                children: "Submit"
                                            }), (0, s.jsx)(T.$, {
                                                className: "endpoint__button",
                                                color: "black",
                                                onClick: () => {
                                                    let {
                                                        server_url: t,
                                                        app_id: i
                                                    } = (0, v.a8R)();
                                                    localStorage.setItem(_.ql.configServerURL, t), localStorage.setItem(_.ql.configAppId, i.toString()), e.resetForm({
                                                        values: {
                                                            appId: i,
                                                            serverUrl: t
                                                        }
                                                    }), window.location.reload()
                                                },
                                                variant: "outlined",
                                                type: "button",
                                                children: "Reset to original settings"
                                            })]
                                        })]
                                    })]
                                })
                            }, {})
                        }), (0, s.jsx)(m.qh, {
                            path: "callback",
                            element: (0, s.jsx)(() => (0, s.jsx)(w.YO, {
                                onSignInSuccess: async (e, t) => {
                                    var i, s, o;
                                    let r, a, l, h, p = {},
                                        _ = {};
                                    for (let [t, i] of Object.entries(e))
                                        if (t.startsWith("acct")) {
                                            let s = t.replace("acct", "token");
                                            e[s] && (p[i] = e[s], _[i] = {
                                                loginid: i,
                                                token: e[s],
                                                currency: ""
                                            })
                                        } else if (t.startsWith("cur")) {
                                        let s = t.replace("cur", "acct");
                                        e[s] && (_[e[s]].currency = i)
                                    }
                                    localStorage.setItem("accountsList", JSON.stringify(p)), localStorage.setItem("clientAccounts", JSON.stringify(_));
                                    let g = !1,
                                        m = await (0, c.TN)();
                                    if (m) {
                                        let {
                                            authorize: t,
                                            error: s
                                        } = await m.authorize(e.token1);
                                        if (m.disconnect(), s) "InvalidToken" === s.code && (g = !0, "true" === n.A.get("logged_state") && d.P.emit("InvalidToken", {
                                            error: s
                                        }), "false" === n.A.get("logged_state") && (0, u.m_)());
                                        else {
                                            localStorage.setItem("callback_token", t.toString());
                                            let e = Object.values(_),
                                                s = null == t || null == (i = t.account_list[0]) ? void 0 : i.loginid,
                                                o = e.filter(e => e.loginid === s);
                                            o.length && (localStorage.setItem("authToken", o[0].token), localStorage.setItem("active_loginid", o[0].loginid), g = !0)
                                        }
                                    }
                                    g || (localStorage.setItem("authToken", e.token1), localStorage.setItem("active_loginid", e.acct1));
                                    let y = (r = new URLSearchParams(window.location.search), a = t && (null == t ? void 0 : t.account) || r.get("account") || sessionStorage.getItem("query_param_currency") || "", l = (null == (s = _[e.acct1]) ? void 0 : s.currency) || null, console.log("Selected currency:", a), h = [...v.lpQ, ...v.qIf], a && h.includes(a.toUpperCase()) ? a : l || ((null == (o = e.acct1) ? void 0 : o.startsWith("VR")) ? "demo" : "USD"));
                                    window.location.replace(window.location.origin + `/?account=${y}`)
                                },
                                renderReturnButton: () => (0, s.jsx)(T.$, {
                                    className: "callback-return-button",
                                    onClick: () => {
                                        window.location.href = "/"
                                    },
                                    children: "Return to Bot"
                                })
                            }), {})
                        })]
                    }))),
                    F = function() {
                        let e = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent),
                            [t, i] = (0, a.useState)(!1);
                        return (0, a.useEffect)(() => {
                            let t = e && "true" !== localStorage.getItem("installPromptDismissed") && window.location === window.parent.location,
                                s = setTimeout(() => {
                                    t && i(!0)
                                }, 5e3);
                            return () => clearTimeout(s)
                        }, [e]), (0, a.useEffect)(() => {
                            var e, t;
                            return (0, o.nR)(), null == (t = window) || null == (e = t.dataLayer) || e.push({
                                event: "page_load"
                            }), () => {
                                let e = document.getElementById("survicate-box");
                                e && (e.style.display = "none")
                            }
                        }, []), (0, a.useEffect)(() => {
                            let e = localStorage.getItem("accountsList"),
                                t = localStorage.getItem("clientAccounts"),
                                i = new URLSearchParams(window.location.search).get("account"),
                                s = [...v.lpQ, ...v.qIf],
                                o = i && s.includes(null == i ? void 0 : i.toUpperCase());
                            if (e && t) try {
                                let s = JSON.parse(e),
                                    r = JSON.parse(t),
                                    a = (e, t) => {
                                        localStorage.setItem("authToken", e), localStorage.setItem("active_loginid", t)
                                    };
                                if ((null == i ? void 0 : i.toUpperCase()) === "DEMO") {
                                    let e = Object.entries(s).find(e => {
                                        let [t] = e;
                                        return t.startsWith("VR")
                                    });
                                    if (e) {
                                        let [t, i] = e;
                                        a(String(i), t);
                                        return
                                    }
                                }
                                if ((null == i ? void 0 : i.toUpperCase()) !== "DEMO" && o) {
                                    let e = Object.entries(r).find(e => {
                                        let [t, s] = e;
                                        return !t.startsWith("VR") && s.currency.toUpperCase() === (null == i ? void 0 : i.toUpperCase())
                                    });
                                    if (e) {
                                        let [t, i] = e;
                                        "token" in i && a(String(null == i ? void 0 : i.token), t);
                                        return
                                    }
                                }
                            } catch (e) {
                                console.warn("Error", e)
                            }
                        }, []), (0, s.jsxs)(s.Fragment, {
                            children: [t && (0, s.jsx)("div", {
                                className: "modal-overlay",
                                children: (0, s.jsxs)("div", {
                                    className: "modal-box",
                                    children: [(0, s.jsx)("h1", {
                                        className: "modal-heading",
                                        children: "Defen Traders"
                                    }), (0, s.jsx)("p", {
                                        className: "mains",
                                        children: "Install our mobile app for a better trading experience."
                                    }), (0, s.jsxs)("div", {
                                        className: "modal-buttons",
                                        children: [(0, s.jsx)("button", {
                                            className: "modal-ack-btn",
                                            onClick: () => {
                                                window.open("/app/defen-traders.apk"), localStorage.setItem("installPromptDismissed", "true"), i(!1)
                                            },
                                            children: "Install"
                                        }), (0, s.jsx)("button", {
                                            className: "modal-ack-btn cancel",
                                            onClick: () => {
                                                localStorage.setItem("installPromptDismissed", "true"), i(!1)
                                            },
                                            children: "Cancel"
                                        })]
                                    })]
                                })
                            }), (0, s.jsx)(g.pg, {
                                router: H
                            })]
                        })
                    },
                    W = async (e, t, i) => {
                        if (e.length) try {
                            if (!_.vk.getDefaultActiveAccount(e)) return;
                            let o = {},
                                r = {};
                            e.forEach(e => {
                                o[e.loginid] = e.token, r[e.loginid] = e
                            }), localStorage.setItem("accountsList", JSON.stringify(o)), localStorage.setItem("clientAccounts", JSON.stringify(r)), _.vk.filterSearchParams(t);
                            let a = await (0, c.TN)();
                            if (a) {
                                let {
                                    authorize: t,
                                    error: o
                                } = await a.authorize(e[0].token);
                                if (a.disconnect(), o) "InvalidToken" === o.code && (i(!0), "true" === n.A.get("logged_state") && d.P.emit("InvalidToken", {
                                    error: o
                                }), "false" === n.A.get("logged_state") && (0, u.m_)());
                                else {
                                    var s;
                                    let i = null == t || null == (s = t.account_list[0]) ? void 0 : s.loginid,
                                        o = e.filter(e => e.loginid === i);
                                    if (o.length) {
                                        localStorage.setItem("authToken", o[0].token), localStorage.setItem("active_loginid", o[0].loginid);
                                        return
                                    }
                                }
                            }
                            localStorage.setItem("authToken", e[0].token), localStorage.setItem("active_loginid", e[0].loginid)
                        } catch (e) {
                            console.error("Error setting up login info:", e)
                        }
                    };
                i(52782), (async () => {
                    var e, t;
                    null === v.Vse || void 0 === v.Vse || null == (t = v.Vse.get("active_loginid")) || null == (e = t.match(/[a-zA-Z]+/g)) || e.join("")
                })(), r.createRoot(document.getElementById("root")).render((0, s.jsx)(() => {
                    let [e, t] = a.useState(!1), {
                        loginInfo: i,
                        paramsToDelete: o
                    } = _.vk.getLoginInfoFromURL(), r = a.useRef(!1);
                    return (a.useEffect(() => {
                        (0, h.Ln)(), !r.current && (r.current = !0, (0, u.a8)()) || (async () => {
                            await W(i, o, t), _.vk.filterSearchParams(["lang"]), t(!0)
                        })()
                    }, [i, o]), e) ? (0, s.jsx)(F, {}) : (0, s.jsx)(l.A, {
                        message: (0, p.kg)("Initializing...")
                    })
                }, {}))
            },
            24020(e, t, i) {
                "use strict";
                i.d(t, {
                    Y: () => U
                });
                var s = i(67774),
                    o = i(95526),
                    r = i(3673),
                    a = i(74848);
                i(96540);
                let n = e => {
                        let {
                            max_payout: t,
                            max_ticks: i
                        } = e ? ? {
                            max_payout: 0,
                            max_ticks: 0
                        };
                        return (0, a.jsxs)("div", {
                            className: "sell_conditions",
                            children: [(0, a.jsxs)("div", {
                                className: "sell_conditions__take_profit",
                                children: [(0, a.jsx)("span", {
                                    children: (0, a.jsx)("strong", {
                                        children: (0, o.kg)("Take Profit: ")
                                    })
                                }), (0, a.jsx)("span", {
                                    children: (0, o.kg)("The position closes once its profit exceeds the take-profit amount")
                                })]
                            }), (0, a.jsxs)("div", {
                                className: "sell_conditions__tick_count",
                                children: [(0, a.jsx)("span", {
                                    children: (0, a.jsx)("strong", {
                                        children: (0, o.kg)("Tick Count: ")
                                    })
                                }), (0, a.jsx)("span", {
                                    children: (0, o.kg)("The holding period measured in ticks before the position is sold")
                                })]
                            }), (0, a.jsx)("div", {
                                children: (0, a.jsx)(o.we, {
                                    i18n_default_text: "The position closes when the input condition is met or upon reaching the maximum payout of {{ max_payout }} or maximum tick of {{ max_ticks }}, whichever occurs first.",
                                    values: {
                                        max_payout: t,
                                        max_ticks: i
                                    }
                                })
                            })]
                        })
                    },
                    l = () => ({
                        type: "label",
                        label: (0, o.kg)("Sell conditions"),
                        description: n
                    }),
                    c = () => ({
                        type: "label",
                        label: (0, o.kg)("Size"),
                        description: (0, o.kg)("The size used to multiply the stake after a losing trade for the next trade.")
                    }),
                    d = () => ({
                        type: "sell_conditions",
                        name: "sell_conditions"
                    }),
                    u = () => ({
                        type: "label",
                        label: (0, o.kg)("Growth rate"),
                        description: (0, o.kg)("Your stake will grow at the specified growth rate per tick as long as the current spot price remains within the range of the previous spot price.")
                    }),
                    h = () => ({
                        type: "growth_rate",
                        name: "growth_rate",
                        attached: !0,
                        validation: ["number", "required", "ceil"]
                    }),
                    p = () => ({
                        type: "label",
                        label: (0, o.kg)("Unit"),
                        description: (0, o.kg)("The unit used to multiply the stake after a losing trade for the next trade.")
                    }),
                    _ = () => ({
                        type: "number",
                        name: "take_profit",
                        should_have: [{
                            key: "boolean_tick_count",
                            value: !1
                        }],
                        hide_without_should_have: !0,
                        attached: !0,
                        has_currency_unit: !0,
                        validation: ["number", "required", "ceil", {
                            type: "min",
                            value: .35,
                            getMessage: e => (0, o.kg)("Minimum take profit allowed is {{ min }}", {
                                min: e
                            })
                        }]
                    }),
                    g = () => ({
                        type: "number",
                        name: "tick_count",
                        should_have: [{
                            key: "boolean_tick_count",
                            value: !0
                        }],
                        hide_without_should_have: !0,
                        attached: !0,
                        has_currency_unit: !1,
                        validation: ["number", "required", "ceil", {
                            type: "min",
                            value: 1,
                            getMessage: e => (0, o.kg)("Minimum tick count allowed is {{ min }}", {
                                min: e
                            })
                        }]
                    }),
                    m = () => ({
                        type: "min",
                        value: 1,
                        getMessage: e => (0, o.kg)("Must be a number higher than {{ min }}", {
                            min: Number(e) - 1
                        })
                    }),
                    y = () => ({
                        type: "label",
                        label: (0, o.kg)("Asset"),
                        description: (0, o.kg)("The underlying market your bot will trade with this strategy.")
                    }),
                    f = () => ({
                        type: "symbol",
                        name: "symbol"
                    }),
                    b = () => ({
                        type: "label",
                        label: (0, o.kg)("Contract type"),
                        description: (0, o.kg)("Your bot will use this contract type for every run")
                    }),
                    k = () => ({
                        type: "tradetype",
                        name: "tradetype",
                        dependencies: ["symbol"]
                    }),
                    v = () => ({
                        type: "label",
                        label: (0, o.kg)("Purchase condition"),
                        description: (0, o.kg)("Your bot uses a single trade type for each run.")
                    }),
                    w = () => ({
                        type: "contract_type",
                        name: "type",
                        dependencies: ["symbol", "tradetype"]
                    }),
                    T = () => ({
                        type: "label",
                        label: (0, o.kg)("Initial stake"),
                        description: (0, o.kg)("The amount that you stake for the first trade. Note that this is the minimum stake amount.")
                    }),
                    S = () => ({
                        type: "number",
                        name: "stake",
                        validation: ["number", "required", "ceil", {
                            type: "min",
                            value: .35,
                            getMessage: e => (0, o.kg)("Minimum stake allowed is {{ min }}", {
                                min: e
                            }),
                            getDynamicValue: e => {
                                var t, i;
                                return (null == (i = e.quick_strategy) || null == (t = i.additional_data) ? void 0 : t.min_stake) || .35
                            }
                        }, {
                            type: "max",
                            value: 1e3,
                            getMessage: e => (0, o.kg)("Maximum stake allowed is {{ max }}", {
                                max: e
                            }),
                            getDynamicValue: e => {
                                var t, i;
                                return (null == (i = e.quick_strategy) || null == (t = i.additional_data) ? void 0 : t.max_stake) || 1e3
                            }
                        }],
                        has_currency_unit: !0
                    }),
                    I = () => ({
                        type: "label",
                        label: (0, o.kg)("Duration"),
                        description: (0, o.kg)("How long each trade takes to expire.")
                    }),
                    E = () => ({
                        type: "durationtype",
                        name: "durationtype",
                        dependencies: ["symbol", "tradetype"],
                        attached: !0
                    }),
                    x = () => ({
                        type: "number",
                        name: "duration",
                        attached: !0,
                        validation: ["number", "required", "min", "max", "integer"]
                    }),
                    A = () => ({
                        type: "label",
                        label: (0, o.kg)("Profit threshold"),
                        description: (0, o.kg)("The bot will stop trading if your total profit exceeds this amount.")
                    }),
                    C = () => ({
                        type: "number",
                        name: "profit",
                        validation: ["number", "required", "ceil", m()],
                        has_currency_unit: !0
                    }),
                    R = () => ({
                        type: "label",
                        label: (0, o.kg)("Loss threshold"),
                        description: (0, o.kg)("The bot will stop trading if your total loss exceeds this amount.")
                    }),
                    O = () => ({
                        type: "number",
                        name: "loss",
                        validation: ["number", "required", "ceil", m()],
                        has_currency_unit: !0
                    }),
                    D = () => ({
                        type: "number",
                        name: "size",
                        validation: ["number", "required", "floor", {
                            type: "min",
                            value: String((0, s.config)().QUICK_STRATEGY.DEFAULT.size),
                            getMessage: e => (0, o.kg)("The value must be equal or greater than {{ min }}", {
                                min: e
                            })
                        }]
                    }),
                    B = () => ({
                        type: "number",
                        name: "unit",
                        validation: ["number", "required", "ceil", m()]
                    }),
                    L = () => ({
                        type: "checkbox",
                        name: "boolean_max_stake",
                        label: (0, o.kg)("Max stake"),
                        description: (0, o.kg)("The stake for your next trade will reset to the initial stake if it exceeds this value."),
                        attached: !0
                    }),
                    P = () => ({
                        type: "number",
                        name: "max_stake",
                        validation: ["number", "required", "ceil", "min"],
                        should_have: [{
                            key: "boolean_max_stake",
                            value: !0
                        }],
                        hide_without_should_have: !0,
                        attached: !0,
                        has_currency_unit: !0
                    }),
                    N = () => ({
                        type: "label",
                        name: "label_last_digit_prediction",
                        label: (0, o.kg)("Last Digit Prediction"),
                        description: (0, o.kg)("Your prediction of the last digit of the asset price."),
                        should_have: [{
                            key: "tradetype",
                            value: "",
                            multiple: ["matchesdiffers", "overunder"]
                        }],
                        hide_without_should_have: !0
                    }),
                    j = () => ({
                        type: "number",
                        name: "last_digit_prediction",
                        validation: ["number", "required", "min", "max", "integer"],
                        should_have: [{
                            key: "tradetype",
                            value: "",
                            multiple: ["matchesdiffers", "overunder"]
                        }],
                        hide_without_should_have: !0
                    }),
                    U = () => ({
                        MARTINGALE: {
                            name: "martingale_max-stake",
                            label: (0, o.kg)("Martingale"),
                            rs_strategy_name: "martingale",
                            description: (0, r.MARTINGALE)(),
                            fields: [
                                [y(), f(), b(), k(), v(), w(), N(), j(), T(), S(), I(), E(), x()],
                                [A(), C(), R(), O(), {
                                    type: "label",
                                    label: (0, o.kg)("Size"),
                                    description: (0, o.kg)("The size used to multiply the stake after a losing trade for the next trade.")
                                }, D(), L(), P()]
                            ]
                        },
                        D_ALEMBERT: {
                            name: "dalembert_max-stake",
                            label: (0, o.kg)("D’Alembert"),
                            rs_strategy_name: "d'alembert",
                            description: (0, r.D_ALEMBERT)(),
                            fields: [
                                [y(), f(), b(), k(), v(), w(), N(), j(), T(), S(), I(), E(), x()],
                                [A(), C(), R(), O(), {
                                    type: "label",
                                    label: (0, o.kg)("Unit"),
                                    description: (0, o.kg)("Number of unit(s) to be added to the next trade after a losing trade. One unit is equivalent to the amount of initial stake.")
                                }, B(), L(), P()]
                            ]
                        },
                        OSCARS_GRIND: {
                            name: "oscars_grind_max-stake",
                            label: (0, o.kg)("Oscar’s Grind"),
                            rs_strategy_name: "oscar's-grind",
                            description: (0, r.OSCARS_GRIND)(),
                            fields: [
                                [y(), f(), b(), k(), v(), w(), N(), j(), T(), S(), I(), E(), x()],
                                [A(), C(), R(), O(), L(), P()]
                            ]
                        },
                        REVERSE_MARTINGALE: {
                            name: "reverse_martingale",
                            label: (0, o.kg)("Reverse Martingale"),
                            rs_strategy_name: "reverse martingale",
                            description: (0, r.REVERSE_MARTINGALE)(),
                            fields: [
                                [y(), f(), b(), k(), v(), w(), N(), j(), T(), S(), I(), E(), x()],
                                [A(), C(), R(), O(), {
                                    type: "label",
                                    label: (0, o.kg)("Size"),
                                    description: (0, o.kg)("The size used to multiply the stake after a successful trade for the next trade.")
                                }, D(), L(), P()]
                            ]
                        },
                        REVERSE_D_ALEMBERT: {
                            name: "reverse_dalembert",
                            label: (0, o.kg)("Reverse D’Alembert"),
                            rs_strategy_name: "reverse d'alembert",
                            description: (0, r.REVERSE_D_ALEMBERT)(),
                            fields: [
                                [y(), f(), b(), k(), v(), w(), N(), j(), T(), S(), I(), E(), x()],
                                [A(), C(), R(), O(), {
                                    type: "label",
                                    label: (0, o.kg)("Unit"),
                                    description: (0, o.kg)("Number of unit(s) to be added to the next trade after a successful trade. One unit is equivalent to the amount of initial stake.")
                                }, B(), L(), P()]
                            ]
                        },
                        STRATEGY_1_3_2_6: {
                            name: "1_3_2_6",
                            label: (0, o.kg)("1-3-2-6"),
                            rs_strategy_name: "1-3-2-6",
                            description: (0, r.STRATEGY_1_3_2_6)(),
                            fields: [
                                [y(), f(), b(), k(), v(), w(), N(), j(), T(), S(), I(), E(), x()],
                                [A(), C(), R(), O()]
                            ]
                        },
                        ACCUMULATORS_MARTINGALE: {
                            name: "accumulators_martingale",
                            label: (0, o.kg)("Martingale"),
                            rs_strategy_name: "accumulators_martingale",
                            description: [],
                            fields: [
                                [y(), f(), T(), S(), u(), h()],
                                [A(), C(), R(), O(), c(), D(), l(), d(), _(), g(), L(), P()]
                            ]
                        },
                        ACCUMULATORS_DALEMBERT: {
                            name: "accumulators_dalembert",
                            label: (0, o.kg)("D’Alembert"),
                            rs_strategy_name: "accumulators_dalembert",
                            description: [],
                            fields: [
                                [y(), f(), T(), S(), u(), h()],
                                [A(), C(), R(), O(), p(), B(), l(), d(), _(), g(), L(), P()]
                            ]
                        },
                        ACCUMULATORS_MARTINGALE_ON_STAT_RESET: {
                            name: "accumulators_martingale_on_stat_reset",
                            label: (0, o.kg)("Martingale on Stat Reset"),
                            rs_strategy_name: "accumulators_martingale_on_stat_reset",
                            description: [],
                            fields: [
                                [y(), f(), T(), S(), u(), h()],
                                [A(), C(), R(), O(), c(), D(), l(), d(), _(), g(), L(), P()]
                            ]
                        },
                        ACCUMULATORS_DALEMBERT_ON_STAT_RESET: {
                            name: "accumulators_dalembert_on_stat_reset",
                            label: (0, o.kg)("D'Alembert on Stat Reset"),
                            rs_strategy_name: "accumulators_dalembert_on_stat_reset",
                            description: [],
                            fields: [
                                [y(), f(), T(), S(), u(), h()],
                                [A(), C(), R(), O(), p(), B(), l(), d(), _(), g(), L(), P()]
                            ]
                        },
                        ACCUMULATORS_REVERSE_MARTINGALE: {
                            name: "accumulators_reverse_martingale",
                            label: (0, o.kg)("Reverse Martingale"),
                            rs_strategy_name: "accumulators_reverse_martingale",
                            description: [],
                            fields: [
                                [y(), f(), T(), S(), u(), h()],
                                [A(), C(), R(), O(), c(), D(), l(), d(), _(), g(), L(), P()]
                            ]
                        },
                        ACCUMULATORS_REVERSE_MARTINGALE_ON_STAT_RESET: {
                            name: "accumulators_reverse_martingale_on_stat_reset",
                            label: (0, o.kg)("Reverse Martingale on Stat Reset"),
                            rs_strategy_name: "accumulators_reverse_martingale_on_stat_reset",
                            description: [],
                            fields: [
                                [y(), f(), T(), S(), u(), h()],
                                [A(), C(), R(), O(), c(), D(), l(), d(), _(), g(), L(), P()]
                            ]
                        },
                        ACCUMULATORS_REVERSE_DALEMBERT: {
                            name: "accumulators_reverse_dalembert",
                            label: (0, o.kg)("Reverse D'Alembert"),
                            rs_strategy_name: "accumulators_reverse_dalembert",
                            description: [],
                            fields: [
                                [y(), f(), T(), S(), u(), h()],
                                [A(), C(), R(), O(), p(), B(), l(), d(), _(), g(), L(), P()]
                            ]
                        },
                        ACCUMULATORS_REVERSE_DALEMBERT_ON_STAT_RESET: {
                            name: "accumulators_reverse_dalembert_on_stat_reset",
                            label: (0, o.kg)("Reverse D'Alembert on Stat Reset"),
                            rs_strategy_name: "accumulators_reverse_dalembert_on_stat_reset",
                            description: [],
                            fields: [
                                [y(), f(), T(), S(), u(), h()],
                                [A(), C(), R(), O(), p(), B(), l(), d(), _(), g(), L(), P()]
                            ]
                        }
                    })
            },
            92509(e, t, i) {
                "use strict";
                i.d(t, {
                    A: () => o
                });
                var s = i(74848);
                i(96540);
                let o = e => {
                    let {
                        content: t
                    } = e;
                    return (0, s.jsx)("div", {
                        className: "parent",
                        children: (0, s.jsxs)("div", {
                            className: "container",
                            children: [(0, s.jsxs)("h1", {
                                className: "brand",
                                children: ["Defen", (0, s.jsx)("span", {
                                    children: "Traders"
                                })]
                            }), (0, s.jsx)("p", {
                                className: "subtitles",
                                children: "Making Deriv Easy"
                            }), (0, s.jsx)("p", {
                                className: "subtitle",
                                children: "Deriv AI Trading Tool"
                            }), (0, s.jsxs)("div", {
                                className: "features",
                                children: [(0, s.jsxs)("div", {
                                    className: "feature",
                                    children: [(0, s.jsx)("img", {
                                        src: "https://img.icons8.com/fluency/48/combo-chart.png",
                                        alt: "Analysis Tool"
                                    }), (0, s.jsx)("p", {
                                        children: "Analysis Tool"
                                    })]
                                }), (0, s.jsxs)("div", {
                                    className: "feature",
                                    children: [(0, s.jsx)("img", {
                                        src: "https://img.icons8.com/fluency/48/robot-2.png",
                                        alt: "AI Bots"
                                    }), (0, s.jsx)("p", {
                                        children: "AI Bots"
                                    })]
                                }), (0, s.jsxs)("div", {
                                    className: "feature",
                                    children: [(0, s.jsx)("img", {
                                        src: "https://img.icons8.com/fluency/48/robot-2.png",
                                        alt: "Free Bots"
                                    }), (0, s.jsx)("p", {
                                        children: "Free Bots"
                                    })]
                                }), (0, s.jsxs)("div", {
                                    className: "feature",
                                    children: [(0, s.jsx)("img", {
                                        src: "https://img.icons8.com/fluency/48/graph-report.png",
                                        alt: "Live Signals"
                                    }), (0, s.jsx)("p", {
                                        children: "Live Signals"
                                    })]
                                })]
                            }), (0, s.jsx)("div", {
                                className: "loader",
                                children: (0, s.jsx)("div", {
                                    className: "bar"
                                })
                            }), (0, s.jsx)("p", {
                                className: "loading-text",
                                children: t
                            }), (0, s.jsxs)("p", {
                                className: "powered",
                                children: ["Powered by ", (0, s.jsx)("strong", {
                                    children: "Deriv"
                                })]
                            })]
                        })
                    })
                }
            },
            67212(e, t, i) {
                "use strict";
                i.d(t, {
                    BI: () => a,
                    DD: () => c,
                    EC: () => u,
                    d6: () => r,
                    n9: () => d,
                    ni: () => l
                });
                var s = i(24509),
                    o = i(95526);
                let r = "user guide",
                    a = "videos on Defen Traders",
                    n = "quick strategy guides",
                    l = () => [{
                        id: 1,
                        type: "Tour",
                        subtype: "OnBoard",
                        content: (0, o.kg)("Get started on Defen Traders"),
                        src: (0, s.hx)("dbot-onboard-tour.png"),
                        search_id: `${r}-0`
                    }, {
                        id: 2,
                        type: "Tour",
                        subtype: "BotBuilder",
                        content: (0, o.kg)("Let’s build a bot!"),
                        src: (0, s.hx)("bot-builder-tour.png"),
                        search_id: `${r}-1`
                    }],
                    c = () => [{
                        id: 1,
                        type: "DBotVideo",
                        content: (0, o.kg)("An introduction to Defen Traders"),
                        url: "https://www.youtube.com/embed/lthEgaIY1uw",
                        src: (0, s.hx)("intro_to_deriv_bot.png"),
                        search_id: `${a}-0`
                    }, {
                        id: 2,
                        type: "DBotVideo",
                        content: (0, o.kg)("How to build a basic trading bot with Defen Traders"),
                        url: "https://www.youtube.com/embed/mnpi2g7YakU",
                        src: (0, s.hx)("build_a_bot.png"),
                        search_id: `${a}-1`
                    }, {
                        id: 3,
                        type: "DBotVideo",
                        content: (0, o.kg)("How to use Martingale strategy on Defen Traders"),
                        url: "https://www.youtube.com/embed/FSslvF7P00I",
                        src: (0, s.hx)("how_to_use_martingale.jpg"),
                        search_id: `${a}-2`
                    }, {
                        id: 4,
                        type: "DBotVideo",
                        content: (0, o.kg)("Introducing Accumulator Options on Defen Traders: Available for automated trading"),
                        url: "https://www.youtube.com/embed/uMBBmdNaadU",
                        src: (0, s.hx)("introducing_accumulators_on_deriv_bot.png"),
                        search_id: `${a}-3`
                    }],
                    d = () => [{
                        title: (0, o.kg)("What is Defen Traders?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("Defen Traders is a web-based strategy builder for trading digital options. It’s a platform where you can build your own automated trading bot using drag-and-drop 'blocks'.")
                        }],
                        search_id: "faq-0"
                    }, {
                        title: (0, o.kg)("Where do I find the blocks I need?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("Follow these steps:")
                        }, {
                            type: "text",
                            content: (0, o.kg)("1. Go to <strong>Bot Builder</strong>.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("2. Under the <strong>Blocks menu</strong>, you'll see a list of categories. Blocks are grouped within these categories. Choose the block you want and drag them to the workspace.")
                        }, {
                            type: "image",
                            src: (0, s.hx)("blocks_menu.png")
                        }, {
                            type: "text",
                            content: (0, o.kg)("3. You can also search for the blocks you want using the search bar above the categories.")
                        }, {
                            type: "image",
                            src: (0, s.hx)("blocks_menu_search.png")
                        }, {
                            type: "text",
                            content: (0, o.kg)('For more info, <a href="https://deriv.com/academy/blog/posts/how-to-build-a-basic-trading-bot-with-dbot/" target="_blank">check out this blog post</a> on the basics of building a trading bot.')
                        }],
                        search_id: "faq-1"
                    }, {
                        title: (0, o.kg)("How do I remove blocks from the workspace?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("Click on the block you want to remove and press <strong>Delete</strong> on your keyboard.")
                        }],
                        search_id: "faq-2"
                    }, {
                        title: (0, o.kg)("How do I create variables?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("1. Under the <strong>Blocks</strong> menu, go to <strong>Utility > Variables</strong>.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("2. Enter a name for your variable, and hit <strong>Create</strong>. New blocks containing your new variable will appear below.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("3. Choose the block you want and drag it to the workspace.")
                        }],
                        search_id: "faq-3"
                    }, {
                        title: (0, o.kg)("Do you offer pre-built trading bots on Defen Traders?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("Yes, you can get started with a pre-built bot using the <strong>Quick strategy</strong> feature. You’ll find some of the most popular trading strategies here: Martingale, D'Alembert, and Oscar's Grind. Just select the strategy, enter your trade parameters, and your bot will be created for you. You can always tweak the parameters later.")
                        }],
                        search_id: "faq-4"
                    }, {
                        title: (0, o.kg)("What is a quick strategy?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("A quick strategy is a ready-made strategy that you can use in Defen Traders. There are 3 quick strategies you can choose from: Martingale, D'Alembert, and Oscar's Grind.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("<strong>Using a quick strategy</strong>")
                        }, {
                            type: "text",
                            content: (0, o.kg)("1. Go to <strong>Quick strategy</strong> and select the strategy you want.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("2. Select the asset and trade type.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("3. Set your trade parameters and hit <strong>Run</strong>.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("4. Once the blocks are loaded onto the workspace, tweak the parameters if you want, or hit <strong>Run</strong> to start trading.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("5. Hit <strong>Save</strong> to download your bot. You can choose to download your bot to your device or your Google Drive.")
                        }],
                        search_id: "faq-5"
                    }, {
                        title: (0, o.kg)("How do I save my strategy?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("In <strong>Bot Builder</strong>, hit <strong>Save</strong> on the toolbar at the top to download your bot. Give your bot a name, and choose to download your bot to your device or Google Drive. Your bot will be downloaded as an XML file.")
                        }],
                        search_id: "faq-6"
                    }, {
                        title: (0, o.kg)("How do I import my own trading bot into Defen Traders?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("Just drag the XML file from your computer onto the workspace, and your bot will be loaded accordingly. Alternatively, you can hit <strong>Import</strong> in <strong>Bot Builder</strong>, and choose to import your bot from your computer or from your Google Drive.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("<strong>Import from your computer</strong>")
                        }, {
                            type: "text",
                            content: (0, o.kg)("1. After hitting <strong>Import</strong>, select <strong>Local</strong> and click <strong>Continue</strong>.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("2. Select your XML file and hit <strong>Open</strong>.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("3. Your bot will be loaded accordingly.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("<strong>Import from your Google Drive</strong>")
                        }, {
                            type: "text",
                            content: (0, o.kg)("1. After hitting <strong>Import</strong>, select <strong>Google Drive</strong> and click <strong>Continue</strong>.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("2. Select your XML file and hit <strong>Select</strong>.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("3. Your bot will be loaded accordingly.")
                        }],
                        search_id: "faq-7"
                    }, {
                        title: (0, o.kg)("How do I reset the workspace?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("In <strong>Bot Builder</strong>, hit <strong>Reset</strong> on the toolbar at the top. This will clear the workspace. Please note that any unsaved changes will be lost.")
                        }],
                        search_id: "faq-8"
                    }, {
                        title: (0, o.kg)("How do I clear my transaction log?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("1. Hit <strong>Reset</strong> at the bottom of stats panel.")
                        }, {
                            type: "image",
                            src: (0, s.hx)("reset_transaction_log.png")
                        }, {
                            type: "text",
                            content: (0, o.kg)("2. Hit <strong>Ok</strong> to confirm.")
                        }, {
                            type: "image",
                            src: (0, s.hx)("reset_transaction_log_message.png")
                        }],
                        search_id: "faq-9"
                    }, {
                        title: (0, o.kg)("How do I control my losses with Defen Traders?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("There are several ways to control your losses with Defen Traders. Here’s a simple example of how you can implement loss control in your strategy:")
                        }, {
                            type: "image",
                            src: (0, s.hx)("loss_control_all_block.png"),
                            imageclass: "loss-control"
                        }, {
                            type: "text",
                            content: (0, o.kg)("<strong>1.</strong> Create the following variables and place them under <strong>Run once at start</strong>:")
                        }, {
                            type: "text",
                            content: (0, o.kg)("• <strong>Stop loss threshold</strong>: Use this variable to store your loss limit. You can assign any amount you want. Your bot will stop when your losses hits or exceeds this amount.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("Example:")
                        }, {
                            type: "image",
                            src: (0, s.hx)("loss_control_set_stop_loss.png")
                        }, {
                            type: "text",
                            content: (0, o.kg)("• <strong>Current stake</strong>: Use this variable to store the stake amount. You can assign any amount you want, but it must be a positive number.")
                        }, {
                            type: "text",
                            content: (0, o.kg)("Example:")
                        }, {
                            type: "image",
                            src: (0, s.hx)("loss_control_set_current_stake.png")
                        }, {
                            type: "text",
                            content: (0, o.kg)("This is how your trade parameters, variables, and trade options should look like:")
                        }, {
                            type: "image",
                            src: (0, s.hx)("loss_control_trade_parameters.png")
                        }, {
                            type: "text",
                            content: (0, o.kg)("<strong>2.</strong> Set the <strong>Purchase conditions</strong>. In this example, your bot will purchase a <strong>Rise</strong> contract when it starts and after a contract closes.")
                        }, {
                            type: "image",
                            src: (0, s.hx)("loss_control_purchase_conditions.png")
                        }, {
                            type: "text",
                            content: (0, o.kg)("<strong>3.</strong> Use a logic block to check if <strong>Total profit/loss</strong> is more than the <strong>Stop loss threshold</strong> amount. You can find the <strong>Total profit/loss</strong> variable under <strong>Analysis > Stats</strong> on the <strong>Blocks menu</strong> on the left. Your bot will continue to purchase new contracts until the <strong>Total profit/loss</strong> amount exceeds the <strong>Stop loss threshold</strong> amount.")
                        }, {
                            type: "image",
                            src: (0, s.hx)("loss_control_restart_trade_conditions.png")
                        }],
                        search_id: "faq-10"
                    }, {
                        title: (0, o.kg)("Can I run Defen Traders on multiple tabs in my web browser?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)('Yes, you can. However, there are limits on your account, such as maximum number of open positions and maximum aggregate payouts on open positions. So, just keep these limits in mind when opening multiple positions. You can find more info about these limits at <a href="https://app.deriv.com/account/account-limits" target="_blank">Settings > Account limits</a>.')
                        }],
                        search_id: "faq-11"
                    }, {
                        title: (0, o.kg)("Can I trade cryptocurrencies on Defen Traders?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("No, we don't offer cryptocurrencies on Defen Traders.")
                        }],
                        search_id: "faq-12"
                    }, {
                        title: (0, o.kg)("Do you sell trading bots?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("No, we don't. However, you'll find quick strategies on Defen Traders that'll help you build your own trading bot for free.")
                        }],
                        search_id: "faq-13"
                    }, {
                        title: (0, o.kg)("In which countries is Defen Traders available?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)('We offer our services in all countries, except for the ones <a href="https://deriv.com/tnc/general-terms.pdf" target="_blank">mentioned in our terms and conditions.</a>')
                        }],
                        search_id: "faq-14"
                    }, {
                        title: (0, o.kg)("If I close my web browser, will Defen Traders continue to run?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("No, Defen Traders will stop running when your web browser is closed.")
                        }],
                        search_id: "faq-15"
                    }, {
                        title: (0, o.kg)("What are the most popular strategies for automated trading?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)("Three of the most commonly used strategies in automated trading are Martingale, D'Alembert, and Oscar's Grind — you can find them all ready-made and waiting for you in Defen Traders.")
                        }],
                        search_id: "faq-16"
                    }, {
                        title: (0, o.kg)("How do I build a trading bot?"),
                        description: [{
                            type: "text",
                            content: (0, o.kg)('<a href="https://www.youtube.com/watch?v=QdI5zCkO4Gk&t=203s" target="_blank">Watch this video</a> to learn how to build a trading bot on Defen Traders. Also, <a href="https://deriv.com/academy/blog/posts/how-to-build-a-basic-trading-bot-with-dbot/" target="_blank">check out this blog post</a> on building a trading bot.')
                        }],
                        search_id: "faq-17"
                    }],
                    u = () => [{
                        qs_name: "MARTINGALE",
                        type: (0, o.kg)("About Martingale"),
                        content: [(0, o.kg)("Exploring the Martingale strategy in Defen Traders"), (0, o.kg)("An example of Martingale strategy")],
                        search_id: `${n}-0`
                    }, {
                        qs_name: "D_ALEMBERT",
                        type: (0, o.kg)("About D'Alembert"),
                        content: [(0, o.kg)("Exploring the D’Alembert strategy in Defen Traders"), (0, o.kg)("An example of D’Alembert strategy")],
                        search_id: `${n}-1`
                    }, {
                        qs_name: "OSCARS_GRIND",
                        type: (0, o.kg)("About Oscar's Grind"),
                        content: [(0, o.kg)("Exploring the Oscar’s Grind strategy in Defen Traders"), (0, o.kg)("An example of Oscar’s Grind strategy")],
                        search_id: `${n}-2`
                    }, {
                        qs_name: "REVERSE_MARTINGALE",
                        type: (0, o.kg)("About Reverse Martingale"),
                        content: [(0, o.kg)("Exploring the Reverse Martingale strategy in Defen Traders"), (0, o.kg)("An example of Reverse Martingale strategy")],
                        search_id: `${n}-3`
                    }, {
                        qs_name: "REVERSE_D_ALEMBERT",
                        type: (0, o.kg)("About Reverse D’Alembert"),
                        content: [(0, o.kg)("Exploring the Reverse D’Alembert strategy in Defen Traders"), (0, o.kg)("An example of Reverse D’Alembert strategy")],
                        search_id: `${n}-4`
                    }, {
                        qs_name: "STRATEGY_1_3_2_6",
                        type: (0, o.kg)("About 1-3-2-6"),
                        content: [(0, o.kg)("Exploring the 1-3-2-6 strategy in Defen Traders"), (0, o.kg)("An example of 1-3-2-6 strategy")],
                        search_id: `${n}-5`
                    }]
            },
            15292(e, t, i) {
                "use strict";
                i.d(t, {
                    U9: () => a,
                    ei: () => r,
                    m0: () => o,
                    mu: () => n
                });
                var s = i(42643);
                let o = {
                    key: "onboard_tour"
                };
                o.key;
                let r = (e, t) => {
                        let i = document.querySelector("#db-toolbar__import-button");
                        e && 1 === t ? null == i || i.classList.add("dbot-tour-blink") : null == i || i.classList.remove("dbot-tour-blink")
                    },
                    a = (e, t) => (0, s.Gf)(t, e),
                    n = Object.freeze({
                        0: "onboarding",
                        1: "bot_builder"
                    })
            },
            24509(e, t, i) {
                "use strict";
                var s;
                i.d(t, {
                    hx: () => o,
                    nR: () => a
                });
                let o = e => `assets/images/${e}`,
                    r = !1,
                    a = () => {
                        if (r) return;
                        r = !0;
                        let e = localStorage.getItem("active_loginid"),
                            t = JSON.parse(localStorage.getItem("accountsList")) || void 0,
                            i = () => {
                                if (e && t) {
                                    let {
                                        residence: i,
                                        account_type: s,
                                        created_at: o
                                    } = t[e] || {};
                                    window.Survicate && (i && window.Survicate.track("userCountry", i), s && window.Survicate.track("accountType", s), o && window.Survicate.track("accountCreationDate", o))
                                }
                            };
                        if (document.getElementById("dbot-survicate")) {
                            let e = document.getElementById("survicate-box");
                            e && (e.style.display = "block"), i()
                        } else {
                            let e, t;
                            (e = document.createElement("script")).id = "dbot-survicate", e.async = !0, e.src = "https://survey.survicate.com/workspaces/83b651f6b3eca1ab4551d95760fe5deb/web_surveys.js", e.onload = i, (null == (t = document.getElementsByTagName("script")[0]) ? void 0 : t.parentNode) ? t.parentNode.insertBefore(e, t) : document.body.appendChild(e)
                        }
                    };
                s = function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                        t = window.location;
                    if (!/^\/(br_)/.test(t.pathname)) return e;
                    let i = e.startsWith("/") ? e : `/${e}`;
                    return `/${t.pathname.split("/")[1]}${i}`
                }("/"), window.__webpack_public_path__ = "", window.__webpack_public_path__ = s
            },
            26008(e, t, i) {
                "use strict";
                i.d(t, {
                    Md: () => o,
                    a8: () => a,
                    m_: () => r
                });
                var s = i(18987);
                let o = () => {
                        let e = document.cookie.split(";"),
                            t = [`.${document.domain.split(".").slice(-2).join(".")}`, `.${document.domain}`, document.domain],
                            i = ["/", window.location.pathname],
                            o = window.location.pathname.split("/", 2)[1];
                        o && i.push(`/${o}`), e.forEach(e => {
                            let s = e.split("=")[0].trim();
                            s && (t.forEach(e => {
                                i.forEach(t => {
                                    document.cookie = `${s}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${t}; domain=${e}`, document.cookie = `${s}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${t}`
                                })
                            }), document.cookie = `${s}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/`)
                        }), ["logged_state", "utm_data"].forEach(e => {
                            t.forEach(t => {
                                i.forEach(i => {
                                    s.A.remove(e, {
                                        path: i,
                                        domain: t
                                    })
                                })
                            }), s.A.remove(e)
                        })
                    },
                    r = () => {
                        localStorage.removeItem("accountsList"), localStorage.removeItem("clientAccounts"), localStorage.removeItem("callback_token"), localStorage.removeItem("authToken"), localStorage.removeItem("active_loginid"), localStorage.removeItem("client.accounts"), o(), location.reload()
                    },
                    a = () => {
                        let e = s.A.get("logged_state"),
                            t = localStorage.getItem("accountsList"),
                            i = t && JSON.parse(t || "{}"),
                            o = i && Object.keys(i).length > 0;
                        return "false" === e && !o && (r(), !0)
                    }
            },
            55875(e, t, i) {
                "use strict";
                i.d(t, {
                    t: () => s
                });
                let s = (e, t) => new Promise(i => {
                    if (document.querySelector(e)) return void i(document.querySelector(e));
                    let s = new MutationObserver(() => {
                        document.querySelector(e) && (i(document.querySelector(e)), s.disconnect())
                    });
                    s.observe(t ? ? document.body, {
                        childList: !0,
                        subtree: !0
                    })
                })
            },
            28362(e, t, i) {
                "use strict";
                let s, o, r, a;
                i.d(t, {
                    default: () => l
                });
                var n = i(27813);
                let l = (o = !1, r = e => {
                    var t;
                    null == (t = window.dataLayer) || t.push(e)
                }, a = (e, t, i) => {
                    try {
                        let s = `${e}-${t}`,
                            o = {
                                counters: `tr:${i.number_of_runs},\
                ts:${i.total_stake},\
                py:${i.total_payout},\
                lc:${i.lost_contracts},\
                wc:${i.won_contracts},\
                pr:${i.total_profit}`.replace(/\s/g, ""),
                                event: "dbot_run",
                                run_id: s
                            };
                        r(o)
                    } catch (e) {
                        console.warn("Error pushing run data to datalayer ", e)
                    }
                }, {
                    init: e => {
                        if (!o) {
                            o = !0, setTimeout(() => {
                                ! function() {
                                    var e, t, i;
                                    let s, o;
                                    e = window, t = document, e[i = "dataLayer"] = e[i] || [], e[i].push({
                                        "gtm.start": new Date().getTime(),
                                        event: "gtm.js"
                                    }), s = t.getElementsByTagName("script")[0], (o = t.createElement("script")).defer = !0, o.src = "https://www.googletagmanager.com/gtm.js?id=GTM-NF7884S", s.parentNode.insertBefore(o, s)
                                }()
                            }, 3e3);
                            try {
                                let {
                                    run_panel: t,
                                    transactions: i,
                                    client: o,
                                    common: r
                                } = e;
                                (0, n.mJ)(() => t.is_running, () => {
                                    t.is_running && (clearTimeout(s), s = setTimeout(() => {
                                        var e;
                                        a(null == o ? void 0 : o.loginid, null == r || null == (e = r.server_time) ? void 0 : e.unix(), null == i ? void 0 : i.statistics)
                                    }, 500))
                                })
                            } catch (e) {
                                console.warn("Error initializing GTM reactions ", e)
                            }
                        }
                    },
                    pushDataLayer: r,
                    onTransactionClosed: e => {
                        r({
                            event: "dbot_run_transaction",
                            reference_id: (null == e ? void 0 : e.contract_id) ? ? ""
                        })
                    },
                    onRunBot: a
                })
            },
            82215(e, t, i) {
                "use strict";
                i.d(t, {
                    Z: () => l,
                    c: () => s
                });
                let s = {
                        TEXT: "text",
                        VIDEO: "video",
                        IMAGE: "image",
                        BLOCK: "block",
                        EXAMPLE: "example"
                    },
                    {
                        TEXT: o,
                        IMAGE: r,
                        BLOCK: a,
                        EXAMPLE: n
                    } = s,
                    l = e => (window.__webpack_public_path__ = e, {
                        procedures_ifreturn: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "if-return"
                        }],
                        math_arithmetic: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }],
                        math_single: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }],
                        math_constrain: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "constrain"
                        }],
                        text_print: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }],
                        text_prompt_ext: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }],
                        tick_analysis: [{
                            type: o
                        }, {
                            type: a
                        }],
                        read_details: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }],
                        last_digit: [{
                            type: o
                        }, {
                            type: a
                        }],
                        read_ohlc: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "in_candle_list_read"
                        }],
                        read_ohlc_obj: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "read_candle_value"
                        }],
                        check_direction: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }],
                        get_ohlc: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "get_candle"
                        }, {
                            type: o
                        }],
                        ohlc: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "candle_list_1"
                        }],
                        ohlc_values: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "candle_list"
                        }],
                        is_candle_black: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: r,
                            width: "100%",
                            url: `${window.__webpack_public_path__}assets/media/is_candle_black.jpeg`
                        }, {
                            type: o
                        }, {
                            type: r,
                            width: "100%",
                            url: `${window.__webpack_public_path__}assets/media/is_candle_black_1.jpeg`
                        }, {
                            type: o
                        }],
                        ohlc_values_in_list: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "candle_list_1"
                        }],
                        variables_gets: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }],
                        variables_set: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: r,
                            width: "100%",
                            url: `${window.__webpack_public_path__}assets/media/create_variable.jpg`
                        }, {
                            type: o
                        }, {
                            type: r,
                            width: "100%",
                            url: `${window.__webpack_public_path__}assets/media/set_variable.png`
                        }],
                        epoch: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "epoch"
                        }],
                        todatetime: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "todatetime"
                        }, {
                            type: o
                        }],
                        totimestamp: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "totimestamp"
                        }, {
                            type: o
                        }],
                        notify_telegram: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "notify_telegram"
                        }],
                        console: [{
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }],
                        balance: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }],
                        sma_statement: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: r,
                            width: "60%",
                            url: `${window.__webpack_public_path__}assets/media/sma_formula.png`
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: r,
                            width: "100%",
                            url: `${window.__webpack_public_path__}assets/media/sma_chart_1.png`
                        }, {
                            type: o
                        }, {
                            type: r,
                            width: "100%",
                            url: `${window.__webpack_public_path__}assets/media/sma_chart_2.png`
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "sma_block_example"
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "sma_block_example_1"
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "sma_array"
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: r,
                            width: "100%",
                            url: `${window.__webpack_public_path__}assets/media/sma_array_explanation.jpeg`
                        }],
                        trade_definition: [{
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: a
                        }],
                        trade_definition_tradeoptions: [{
                            type: o
                        }, {
                            type: a
                        }],
                        trade_definition_multiplier: [{
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }],
                        before_purchase: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }],
                        during_purchase: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "sell_available"
                        }],
                        sell_at_market: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "sell_available"
                        }],
                        after_purchase: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }],
                        trade_again: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "trade_again"
                        }],
                        contract_check_result: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "check_result"
                        }],
                        sell_price: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "sell_pl"
                        }],
                        controls_if: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "controls_if"
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "compare_logic"
                        }, {
                            type: n,
                            example_id: "compare_logic_1"
                        }],
                        logic_operation: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: r,
                            width: "40%",
                            url: `${window.__webpack_public_path__}assets/media/logic.png`
                        }],
                        controls_whileUntil: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "repeat_while"
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "repeat_until"
                        }],
                        controls_for: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "controls_for"
                        }, {
                            type: o
                        }, {
                            type: o
                        }],
                        controls_forEach: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "controls_forEach"
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: o
                        }],
                        controls_flow_statements: [{
                            type: o
                        }, {
                            type: a
                        }, {
                            type: o
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "break_out"
                        }, {
                            type: o
                        }, {
                            type: n,
                            example_id: "continue"
                        }]
                    })
            },
            33172(e, t, i) {
                "use strict";
                i.d(t, {
                    C: () => s
                });
                let s = () => /\.(com|be|me|app)$/i.test(window.location.hostname) || "localhost" === window.location.hostname
            },
            42643(e, t, i) {
                "use strict";
                i.d(t, {
                    Gf: () => r,
                    PL: () => o,
                    lk: () => a
                });
                let s = () => JSON.parse(localStorage.getItem("dbot_settings")),
                    o = e => {
                        let t = s();
                        return t ? t[e] : null
                    },
                    r = (e, t) => {
                        let i = s() || {};
                        i[e] = t, localStorage.setItem("dbot_settings", JSON.stringify(i))
                    },
                    a = e => {
                        let t = s() || {};
                        delete t[e], localStorage.setItem("dbot_settings", JSON.stringify(t))
                    }
            },
            2351(e, t, i) {
                "use strict";
                i.d(t, {
                    qX: () => n,
                    rE: () => a,
                    sf: () => r
                });
                var s = i(95093),
                    o = i.n(s);
                let r = e => {
                        if (!e || !o()(e).isValid()) return o()().utc();
                        if (o().isMoment(e) && e.isValid() && e.isUTC()) return e;
                        if ("number" == typeof e) return o().unix(e).utc();
                        return o().utc(e)
                    },
                    a = "YYYY-MM-DD HH:mm:ss [GMT]",
                    n = "YYYY-MM-DD HH:mm:ss Z"
            },
            39706(e, t, i) {
                "use strict";
                i.d(t, {
                    I: () => o
                });
                var s = i(74848);
                let o = (0, i(96540).memo)(e => {
                    let {
                        icon: t,
                        ...i
                    } = e;
                    return (0, s.jsx)("div", {
                        className: "dummy-icon",
                        ...i,
                        children: (0, s.jsx)("img", {
                            src: `assets/icons/${t}.svg`,
                            alt: t,
                            onError: e => {
                                e.target.src = "assets/icons/IcDashboard.svg"
                            }
                        })
                    })
                })
            },
            14892() {}
        },
        c = {};

    function d(e) {
        var t = c[e];
        if (void 0 !== t) return t.exports;
        var i = c[e] = {
            id: e,
            loaded: !1,
            exports: {}
        };
        return l[e].call(i.exports, i, i.exports, d), i.loaded = !0, i.exports
    }
    if (d.m = l, d.n = e => {
            var t = e && e.__esModule ? () => e.default : () => e;
            return d.d(t, {
                a: t
            }), t
        }, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__, d.t = function(i, s) {
            if (1 & s && (i = this(i)), 8 & s || "object" == typeof i && i && (4 & s && i.__esModule || 16 & s && "function" == typeof i.then)) return i;
            var o = Object.create(null);
            d.r(o);
            var r = {};
            e = e || [null, t({}), t([]), t(t)];
            for (var a = 2 & s && i;
                ("object" == typeof a || "function" == typeof a) && !~e.indexOf(a); a = t(a)) Object.getOwnPropertyNames(a).forEach(e => {
                r[e] = () => i[e]
            });
            return r.default = () => i, d.d(o, r), o
        }, d.d = (e, t) => {
            for (var i in t) d.o(t, i) && !d.o(e, i) && Object.defineProperty(e, i, {
                enumerable: !0,
                get: t[i]
            })
        }, d.f = {}, d.e = e => Promise.all(Object.keys(d.f).reduce((t, i) => (d.f[i](e, t), t), [])), d.hmd = e => ((e = Object.create(e)).children || (e.children = []), Object.defineProperty(e, "exports", {
            enumerable: !0,
            set: () => {
                throw Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " + e.id)
            }
        }), e), d.u = e => "static/js/async/" + (({
            113: "accumulators_reverse_dalembert-xml",
            212: "oscars_grind-xml",
            22: "accumulators_martingale-xml",
            230: "oscars_grind_max-stake-xml",
            3: "accumulators_dalembert_on_stat_reset-xml",
            432: "accumulators_dalembert-xml",
            489: "accumulators_martingale_on_stat_reset-xml",
            561: "accumulators_reverse_martingale-xml",
            588: "dalembert_max-stake-xml",
            603: "1_3_2_6-xml",
            630: "dalembert-xml",
            668: "martingale-xml",
            790: "accumulators_reverse_martingale_on_stat_reset-xml",
            811: "reverse_martingale-xml",
            822: "martingale_max-stake-xml",
            862: "dbot-collection",
            870: "accumulators_reverse_dalembert_on_stat_reset-xml",
            883: "reverse_dalembert-xml"
        })[e] || e) + "." + ({
            113: "e67cd763",
            134: "77bae1d0",
            141: "eebf9be6",
            175: "5334e893",
            212: "0685fd10",
            22: "82cd73a0",
            230: "46c04ac3",
            25: "d24905eb",
            280: "a2eeac51",
            289: "385fc368",
            3: "0b2a4e30",
            328: "0ec1cca9",
            341: "d482788f",
            385: "f36e9fa3",
            432: "81c777eb",
            443: "9397ccf1",
            484: "6e9eebdc",
            489: "deb5847b",
            500: "8a544a87",
            561: "c06d35db",
            588: "b749e554",
            603: "60471aef",
            630: "931a0844",
            634: "201dc115",
            668: "5bdb9c89",
            714: "e9f4a47a",
            776: "780d953a",
            790: "0e4fc845",
            811: "c47482a5",
            822: "3bdadf9a",
            850: "10d642a9",
            862: "6002d73e",
            870: "ca2a58cb",
            883: "96e6983a",
            899: "17caa475",
            97: "620e10cb"
        })[e] + ".js", d.miniCssF = e => "static/css/async/" + e + "." + ({
            134: "cb28e558",
            141: "094dd4d0",
            175: "43690df5",
            443: "943f1ac1",
            500: "1ca7c4b6",
            634: "d7272a95",
            714: "69850dd6",
            97: "ddb80b8d"
        })[e] + ".css", d.g = (() => {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || Function("return this")()
            } catch (e) {
                if ("object" == typeof window) return window
            }
        })(), d.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i = {}, s = "bot:", d.l = function(e, t, o, r) {
            if (i[e]) return void i[e].push(t);
            if (void 0 !== o)
                for (var a, n, l = document.getElementsByTagName("script"), c = 0; c < l.length; c++) {
                    var u = l[c];
                    if (u.getAttribute("src") == e || u.getAttribute("data-rspack") == s + o) {
                        a = u;
                        break
                    }
                }
            a || (n = !0, (a = document.createElement("script")).timeout = 120, d.nc && a.setAttribute("nonce", d.nc), a.setAttribute("data-rspack", s + o), a.src = e), i[e] = [t];
            var h = function(t, s) {
                    a.onerror = a.onload = null, clearTimeout(p);
                    var o = i[e];
                    if (delete i[e], a.parentNode && a.parentNode.removeChild(a), o && o.forEach(function(e) {
                            return e(s)
                        }), t) return t(s)
                },
                p = setTimeout(h.bind(null, void 0, {
                    type: "timeout",
                    target: a
                }), 12e4);
            a.onerror = h.bind(null, a.onerror), a.onload = h.bind(null, a.onload), n && document.head.appendChild(a)
        }, d.r = e => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, d.nmd = e => (e.paths = [], e.children || (e.children = []), e), o = [], d.O = (e, t, i, s) => {
            if (t) {
                s = s || 0;
                for (var r = o.length; r > 0 && o[r - 1][2] > s; r--) o[r] = o[r - 1];
                o[r] = [t, i, s];
                return
            }
            for (var a = 1 / 0, r = 0; r < o.length; r++) {
                for (var [t, i, s] = o[r], n = !0, l = 0; l < t.length; l++)(!1 & s || a >= s) && Object.keys(d.O).every(e => d.O[e](t[l])) ? t.splice(l--, 1) : (n = !1, s < a && (a = s));
                if (n) {
                    o.splice(r--, 1);
                    var c = i();
                    void 0 !== c && (e = c)
                }
            }
            return e
        }, d.p = "/", "undefined" != typeof document) {
        var u = function(e, t, i, s, o) {
                var r = document.createElement("link");
                return r.rel = "stylesheet", r.type = "text/css", d.nc && (r.nonce = d.nc), r.href = t, r.onerror = r.onload = function(i) {
                    if (r.onerror = r.onload = null, "load" === i.type) s();
                    else {
                        var a = i && ("load" === i.type ? "missing" : i.type),
                            n = i && i.target && i.target.href || t,
                            l = Error("Loading CSS chunk " + e + " failed.\\n(" + n + ")");
                        l.code = "CSS_CHUNK_LOAD_FAILED", l.type = a, l.request = n, r.parentNode && r.parentNode.removeChild(r), o(l)
                    }
                }, i ? i.parentNode.insertBefore(r, i.nextSibling) : document.head.appendChild(r), r
            },
            h = function(e, t) {
                for (var i = document.getElementsByTagName("link"), s = 0; s < i.length; s++) {
                    var o = i[s],
                        r = o.getAttribute("data-href") || o.getAttribute("href");
                    if (r && (r = r.split("?")[0]), "stylesheet" === o.rel && (r === e || r === t)) return o
                }
                for (var a = document.getElementsByTagName("style"), s = 0; s < a.length; s++) {
                    var o = a[s],
                        r = o.getAttribute("data-href");
                    if (r === e || r === t) return o
                }
            },
            p = {
                410: 0
            };
        d.f.miniCss = function(e, t) {
            if (p[e]) t.push(p[e]);
            else 0 !== p[e] && ({
                134: 1,
                141: 1,
                175: 1,
                443: 1,
                500: 1,
                634: 1,
                714: 1,
                97: 1
            })[e] && t.push(p[e] = new Promise(function(t, i) {
                var s = d.miniCssF(e),
                    o = d.p + s;
                if (h(s, o)) return t();
                u(e, o, null, t, i)
            }).then(function() {
                p[e] = 0
            }, function(t) {
                throw delete p[e], t
            }))
        }
    }
    r = {
        410: 0
    }, d.f.j = function(e, t) {
        var i = d.o(r, e) ? r[e] : void 0;
        if (0 !== i)
            if (i) t.push(i[2]);
            else {
                var s = new Promise((t, s) => i = r[e] = [t, s]);
                t.push(i[2] = s);
                var o = d.p + d.u(e),
                    a = Error();
                d.l(o, function(t) {
                    if (d.o(r, e) && (0 !== (i = r[e]) && (r[e] = void 0), i)) {
                        var s = t && ("load" === t.type ? "missing" : t.type),
                            o = t && t.target && t.target.src;
                        a.message = "Loading chunk " + e + " failed.\n(" + s + ": " + o + ")", a.name = "ChunkLoadError", a.type = s, a.request = o, i[1](a)
                    }
                }, "chunk-" + e, e)
            }
    }, d.O.j = e => 0 === r[e], a = (e, t) => {
        var i, s, [o, a, n] = t,
            l = 0;
        if (o.some(e => 0 !== r[e])) {
            for (i in a) d.o(a, i) && (d.m[i] = a[i]);
            if (n) var c = n(d)
        }
        for (e && e(t); l < o.length; l++) s = o[l], d.o(r, s) && r[s] && r[s][0](), r[s] = 0;
        return d.O(c)
    }, (n = self.webpackChunkbot = self.webpackChunkbot || []).forEach(a.bind(null, 0)), n.push = a.bind(null, n.push.bind(n));
    var _ = d.O(void 0, ["783", "535", "226"], () => d(14601));
    _ = d.O(_)
})();